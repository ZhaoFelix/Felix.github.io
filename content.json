{"meta":{"title":"Swift 博文","subtitle":"","description":"","author":"异思维","url":"https://swift.qingmaoedu.com","root":"/"},"pages":[{"title":"关于","date":"2023-08-20T08:05:12.000Z","updated":"2023-08-27T01:54:43.670Z","comments":true,"path":"about/index.html","permalink":"https://swift.qingmaoedu.com/about/index.html","excerpt":"","text":"这是一个聚焦于 Swift 相关学习的博客!后续将逐步加入以下的相关知识模块： 一、Swift 基础语法 Swift 一种强大且易学的编程语言。 Swift 是一种强大直观的编程语言，适用于所有 Apple 平台。Swift 语法简洁但表现力强，更包含了深受喜爱的现代功能，可轻松上手使用。Swift 代码从设计上保证安全，并能开发出运行快如闪电的软件。 二、SwiftUI 基础 借助 SwiftUI，你可以利用 Swift 的强大功能打造适合各个 Apple 平台的精美 App，而无需编写大量代码。你只需使用一套工具和 API，就能在任何 Apple 设备上为所有人带来更加出色的体验。 三、Xcode 高效使用技巧 Xcode 15 让你能够开发、测试和分发适用于所有 Apple 平台的 App。借助增强的代码补齐功能、交互式预览和实时动画，更快地推进 App 的编码和设计。利用 Git 暂存功能直接改进下次要提交的文件，而不必离开代码界面。你还能借助重新设计的测试报告及其视频录制功能，探索并诊断测试结果，并着手从 Xcode Cloud 将你的 App 无缝部署到 TestFlight 和 App Store。打造出色的 App，从未如此简单。 四、ARKit 开发 AR 应用 ARKit 6 引入 4K 视频，助你拍摄出令人惊艳的高清 AR 体验视频 — 让专业视频编辑、影片制作、社交媒体 App 等更上一层楼。支持 HDR 视频和高清背景图像捕捉，扩展了视频和拍摄功能。ARKit 6 还为新的城市添加了位置锚点，如蒙特利尔、悉尼、新加坡和东京，并对动作捕捉进行了改进。 五、RealityKit 和 SwiftUI 开发 versionOS 应用 RealityKit 框架专门为增强现实量身定制，能够提供逼真的图像渲染、相机特效、动画、物理特效等等。借助原生的 Swift API、ARKit 整合、基于物理的超逼真渲染、变换和骨骼动画、空间音频和刚体物理，RealityKit 让你可以比以往更加快速轻松地进行 AR 开发。 可以借助 ARKit、 RealityKit 和 SwiftUI 在 Apple 全新的 versionOS 平台上开发全方位沉浸式的 AR 应用。 六、iOS 开发技巧"},{"title":"分类","date":"2023-08-20T08:04:52.000Z","updated":"2023-08-22T05:02:29.637Z","comments":true,"path":"categories/index.html","permalink":"https://swift.qingmaoedu.com/categories/index.html","excerpt":"","text":""},{"title":"sitemap","date":"2023-08-20T08:05:42.000Z","updated":"2023-08-20T08:05:42.443Z","comments":true,"path":"sitemap/index.html","permalink":"https://swift.qingmaoedu.com/sitemap/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-08-20T08:00:37.000Z","updated":"2023-08-22T05:02:36.172Z","comments":true,"path":"tags/index.html","permalink":"https://swift.qingmaoedu.com/tags/index.html","excerpt":"","text":""},{"title":"更新进度","date":"2023-09-26T09:10:46.000Z","updated":"2023-10-15T01:54:00.257Z","comments":true,"path":"update/index.html","permalink":"https://swift.qingmaoedu.com/update/index.html","excerpt":"","text":""}],"posts":[{"title":"SwiftUI控件NavigationStack进阶","slug":"SwiftUI控件NavigationStack进阶","date":"2023-10-25T01:27:01.000Z","updated":"2023-10-25T02:24:26.428Z","comments":true,"path":"posts/307cc34b.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/307cc34b.html","excerpt":"在SwiftUI中，如果我们想要给app添加一个到导航栏，可以使用NavigationStack控件，需要注意的是NavigationStack是iOS 16之后增加的，旨在替代原来的NavigationView，所以如果你的app 运行在iOS 16之前的版本需要使用NavigationView。 在之前的文章中，我们已经接受了NavigationStack的基本使用，接下来我们将主要介绍NavigationStack自定义，即自定义导航栏样式。 初始项目代码如下： 1234567891011121314151617181920212223struct ContentView: View &#123; var books: [String] = [&quot;三国演义&quot;,&quot;水浒传&quot;, &quot;红楼梦&quot;, &quot;西游记&quot;] var body: some View &#123; NavigationStack &#123; List(books, id: \\.self) &#123; book in NavigationLink &#123; DetailContentView(book: book) &#125; label: &#123; Text(book) .bold() &#125; &#125; .navigationTitle(&quot;四大名著&quot;) &#125; &#125;&#125;struct DetailContentView: View &#123; var book: String var body: some View &#123; Text(book) &#125;&#125;","text":"在SwiftUI中，如果我们想要给app添加一个到导航栏，可以使用NavigationStack控件，需要注意的是NavigationStack是iOS 16之后增加的，旨在替代原来的NavigationView，所以如果你的app 运行在iOS 16之前的版本需要使用NavigationView。 在之前的文章中，我们已经接受了NavigationStack的基本使用，接下来我们将主要介绍NavigationStack自定义，即自定义导航栏样式。 初始项目代码如下： 1234567891011121314151617181920212223struct ContentView: View &#123; var books: [String] = [&quot;三国演义&quot;,&quot;水浒传&quot;, &quot;红楼梦&quot;, &quot;西游记&quot;] var body: some View &#123; NavigationStack &#123; List(books, id: \\.self) &#123; book in NavigationLink &#123; DetailContentView(book: book) &#125; label: &#123; Text(book) .bold() &#125; &#125; .navigationTitle(&quot;四大名著&quot;) &#125; &#125;&#125;struct DetailContentView: View &#123; var book: String var body: some View &#123; Text(book) &#125;&#125; 自定义导航栏字体和文字颜色目前，SwiftUI中并没有提供可以定义导航栏样式的修饰器，这里我们需要使用UIKit提供的UINavigationBarAppearance API 来实现。 例如，如果我们想要自定义导航栏上的标题字体和颜色，可以使用下面的方式： 123456789101112init() &#123; let navigationBarAppearance = UINavigationBarAppearance() // 大标题字体样式 navigationBarAppearance.largeTitleTextAttributes = [.foregroundColor: UIColor.red, .font: UIFont(name: &quot;Nunito-Regular&quot;, size: 30)!] // 小标题字体样式 navigationBarAppearance.titleTextAttributes = [.foregroundColor: UIColor.red, .font: UIFont(name: &quot;Nunito-Regular&quot;, size: 20)!] // 标准样式 UINavigationBar.appearance().standardAppearance = navigationBarAppearance UINavigationBar.appearance().scrollEdgeAppearance = navigationBarAppearance UINavigationBar.appearance().compactAppearance = navigationBarAppearance &#125; 这里我们是在ContetnView进行初始化的时候就来设置导航栏的标题，即 12345678910struct ContentView: View &#123; var body: some View &#123; &#125; // ContentView的初始化方法 init() &#123; &#125;&#125; 自定义返回按钮的图片和颜色如果我们只是想要改变默认的返回按钮的图片和颜色，那么我们只需修改UINavigationBarAppearance实例对象的属性即可，即 1navigationBarAppearance.setBackIndicatorImage(UIImage(systemName: &quot;arrow.turn.up.left&quot;), transitionMaskImage: UIImage(systemName: &quot;arrow.turn.up.left&quot;)) 如果是改变返回按钮字体的颜色，只需要修改NavigationStack强调色或者说添加tint修饰器，即 1234NavigationStack &#123; &#125;.tint(.black) 但是，如果我们想要完全自定义个返回按钮，就需要先隐藏NavigationStack原来默认的按钮，使用SwiftUI 提供的navigationBarBackButtonHidden修饰器。 需要注意的是，这个修饰器需要添加到跳转后的子视图上面，在这个例子中就是我们的DetailContentView视图，即 12DetailContentView(book: book) .navigationBarBackButtonHidden(true) 此时，当我们再点击跳转过去的时候，下一个页面已经没有默认的返回按钮了。 接着，我们可以使用toolBar给DetailContentView自定义一个返回的按钮，具体实现的代码如下： 12345678910111213141516171819struct DetailContentView: View &#123; var book: String @Environment(\\.dismiss) var dismiss // 通过dismiss 关键字获取dismiss方法，实现返回上一页 var body: some View &#123; Text(book) .toolbar &#123; ToolbarItem(placement: .cancellationAction) &#123; Button(action: &#123; dismiss() &#125;, label: &#123; Text(&quot;\\(Image(systemName: &quot;chevron.left&quot;)) \\(book)&quot;) .foregroundStyle(.blue) &#125;) &#125; &#125; // 导航栏调整为小标题样式 .navigationBarTitleDisplayMode(.inline) &#125;&#125; 在上面的代码中，我们使用toolBar修饰器和ToolBarItem控件去定义了一个位于左上角的返回按钮，然后使用Environment获取到了dismiss方法来帮助我们返回上一页。 需要注意的一点是，在iOS 15.0之前的系统中，想要实现返回上一页需要使用下面的这种方法： 1@Environment(\\.presentationMode) var presentationMode 然后在按钮的action部分调用下面的代码： 1presentationMode.wrappedValue.dismiss()","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"NavigationStack","slug":"NavigationStack","permalink":"https://swift.qingmaoedu.com/tags0/NavigationStack/"},{"name":"NavigationView","slug":"NavigationView","permalink":"https://swift.qingmaoedu.com/tags0/NavigationView/"}]},{"title":"SwiftUI 之 List 常见设置","slug":"SwiftUI-之-List-常见设置","date":"2023-10-23T07:27:40.000Z","updated":"2023-10-23T08:53:32.559Z","comments":true,"path":"posts/4c9505b9.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/4c9505b9.html","excerpt":"在 SwiftUI 中，List 是非常常用的一个组件。它可以帮助我们快速实现一个列表视图。 假设，我们现在下面这样的一个List示例： 示例代码如下： 1234567891011struct ContentView: View &#123; var books: [String] = [&quot;三国演义&quot;,&quot;水浒传&quot;, &quot;红楼梦&quot;, &quot;西游记&quot;] var body: some View &#123; VStack &#123; List(books, id: \\.self) &#123; book in Text(book) &#125; .listStyle(.inset) &#125; &#125;&#125; 针对List，我们可以进行很多的样式设置。","text":"在 SwiftUI 中，List 是非常常用的一个组件。它可以帮助我们快速实现一个列表视图。 假设，我们现在下面这样的一个List示例： 示例代码如下： 1234567891011struct ContentView: View &#123; var books: [String] = [&quot;三国演义&quot;,&quot;水浒传&quot;, &quot;红楼梦&quot;, &quot;西游记&quot;] var body: some View &#123; VStack &#123; List(books, id: \\.self) &#123; book in Text(book) &#125; .listStyle(.inset) &#125; &#125;&#125; 针对List，我们可以进行很多的样式设置。 改变 List 中分割线的颜色默认情况下，List中分割线的颜色默认的灰色。想改变它的默认颜色，可以使用下面的这个修饰器： 1.listRowSeparatorTint(.green) 但是，这这里需要注意的一点就是，这个修饰器我们需要添加到List里面的子视图中，在本示例中为Text，即 12Text(book) .listRowSeparatorTint(.green) 隐藏分割线隐藏List中的分割线可以使用listRowSeparator修饰器，它的参数为hidden或visible。 1.listRowSeparator(.hidden) 自定义 List 滚动区域的背景在 iOS 16 之后，List支持自定义它的背景。例如，如果我们要想给 List添加一个背景色： 首先，需要隐藏List的滚动内容背景，即 1.scrollContentBackground(.hidden) 然后，可以使用background修饰器设置新的背景： 1234.background( // 使用渐变色作为背景 LinearGradient(colors: [.red, .green], startPoint: .top, endPoint: .center) ) 此时，效果如下： 如果想要让List的显示内容也使用我们自定义的背景颜色，可以让List中的每一行颜色都变为透明色即可 1.listRowBackground(Color.clear) 效果如下： 完整代码如下： 1234567891011121314151617181920struct ContentView: View &#123; var books: [String] = [&quot;三国演义&quot;,&quot;水浒传&quot;, &quot;红楼梦&quot;, &quot;西游记&quot;] var body: some View &#123; VStack &#123; List(books, id: \\.self) &#123; book in Text(book) .listRowSeparator(.visible) .listRowBackground(Color.clear) .foregroundStyle(.white) .bold() .listRowSeparatorTint(.white.opacity(0.5)) &#125; .scrollContentBackground(.hidden) .background( // 使用渐变色作为背景 LinearGradient(colors: [.red, .green], startPoint: .top, endPoint: .center) ) &#125; &#125;&#125;","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"List","slug":"List","permalink":"https://swift.qingmaoedu.com/tags0/List/"}]},{"title":"SwiftUI中 TabView 使用的一些问题","slug":"SwiftUI中-TabView-使用的一些问题","date":"2023-10-16T11:59:05.000Z","updated":"2023-10-18T05:56:19.436Z","comments":true,"path":"posts/a939c106.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/a939c106.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SwiftUI中的基础动画和过渡（三）","slug":"SwiftUI中的基础动画和过渡（三）","date":"2023-10-16T03:03:43.000Z","updated":"2023-10-20T09:57:04.582Z","comments":true,"path":"posts/9d6e228c.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/9d6e228c.html","excerpt":"在之前关于隐式动画和显式动画的文章中，我们都是将动画添加给一个已经存在的视图。在 SwiftUI，它允许我们去定义一个视图的出现和移除，这被叫做过渡（Transitions）。 默认情况下，SwiftUI 中的视图的出现和移除使用的fade-in和fade-out过渡效果。除此之外，SwiftUI 也内置了slide、move、opacity等过渡效果。 构建一个简单的过渡效果12345678910111213141516171819202122232425struct ContentView: View &#123; var body: some View &#123; VStack &#123; RoundedRectangle(cornerRadius: 10) .frame(width: 300, height: 300) .foregroundStyle(.green) .overlay &#123; Text(&quot;显示详情&quot;) .font(.system(.largeTitle, design: .rounded)) .bold() .foregroundStyle(.white) &#125; RoundedRectangle(cornerRadius: 10) .frame(width: 300, height: 300) .foregroundStyle(.purple) .overlay &#123; Text(&quot;哇哦，详情信息&quot;) .font(.system(.largeTitle, design: .rounded)) .bold() .foregroundStyle(.white) &#125; &#125; &#125;&#125;","text":"在之前关于隐式动画和显式动画的文章中，我们都是将动画添加给一个已经存在的视图。在 SwiftUI，它允许我们去定义一个视图的出现和移除，这被叫做过渡（Transitions）。 默认情况下，SwiftUI 中的视图的出现和移除使用的fade-in和fade-out过渡效果。除此之外，SwiftUI 也内置了slide、move、opacity等过渡效果。 构建一个简单的过渡效果12345678910111213141516171819202122232425struct ContentView: View &#123; var body: some View &#123; VStack &#123; RoundedRectangle(cornerRadius: 10) .frame(width: 300, height: 300) .foregroundStyle(.green) .overlay &#123; Text(&quot;显示详情&quot;) .font(.system(.largeTitle, design: .rounded)) .bold() .foregroundStyle(.white) &#125; RoundedRectangle(cornerRadius: 10) .frame(width: 300, height: 300) .foregroundStyle(.purple) .overlay &#123; Text(&quot;哇哦，详情信息&quot;) .font(.system(.largeTitle, design: .rounded)) .bold() .foregroundStyle(.white) &#125; &#125; &#125;&#125; 在上面的代码中，我们使用VStack布局管理了两个RoundedRectangle。接着，我们先让第二个紫色的RoundedRectangle隐藏，当我们点击第一个绿色的RoundedRectangle时在显示。 这里，我们先来定义一个状态变量，用来控制第二个紫色RoundedRectangle的显示或隐藏。 1@State var isShow: Bool = false 然后将第二个RoundedRectangle使用if语句进行包裹： 1234567891011if isShow &#123; RoundedRectangle(cornerRadius: 10) .frame(width: 300, height: 300) .foregroundStyle(.purple) .overlay &#123; Text(&quot;哇哦，详情信息&quot;) .font(.system(.largeTitle, design: .rounded)) .bold() .foregroundStyle(.white) &#125; &#125; 此时，因为isShow值为false，所以第二个RoundedRectangle是不会显示的。 接着，我们给绿色的RoundedRectangle添加onTaGesture修饰器去识别点击手势，当点击手势发生后，对isShow的状态值为取反，并使用withAnimation添加一个默认的过渡动画。 12345.onTapGesture &#123; withAnimation &#123; isShow.toggle() &#125; &#125; 默认的过渡动画如下： 如果想要改变过渡的动画效果，可以给第二个紫色的RoundedRectangle添加transition修饰器，这个修饰器需要一个动画效果的参数，例如： 1.transition(.scale(scale: 0, anchor: .center)) scale是一个缩放的效果，它需要两个参数，一个是开始时的比例；另一个是缩放开始的锚点。除了scale效果，还有slide、offset、move、opaque等。 组合过渡效果如果我们想要要视图呈现多个过渡效果，可以使用combined方法来组合多个动画效果，例如 1.transition(.offset(x: -600, y:0).combined(with: .scale(scale: 0, anchor: .leading))) 当然我们也可以组合多个： 1.transition(.offset(x: -600, y:0).combined(with: .scale(scale: 0, anchor: .leading)).combined(with: .opacity)) 定义重复使用的动画有时候，我们可能想要重复使用一个动画效果。这种情况下，我们可以通用定义一个AnyTransition的扩展来实现，例如： 12345extension AnyTransition &#123; static var offsetScaleOpacity: AnyTransition &#123; AnyTransition.offset(x: -600, y:0).combined(with: .scale).combined(with: .opacity) &#125;&#125; 使用方式： 1.transition(.offsetScaleOpacity) 动画练习练习一使用动画和过渡创建下面的效果： 完整代码和注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778struct ContentView: View &#123; @State private var processing = false // 是否正在处理中 @State private var completed = false // 是否已处理完成 @State private var loading = false // 是否正在加载中 var body: some View &#123; ZStack &#123; RoundedRectangle(cornerRadius: 30) .frame(width: processing ? 250 : 200, height: 60) .foregroundStyle(completed ? .red : .green) // 如果不是在处理过程中 if !processing &#123; Text(&quot;Submit&quot;) .font(.system(.title, design: .rounded)) .bold() .foregroundStyle(.white) .transition(.move(edge: .top)) &#125; // 正在处理并且处于未完成状态 if processing &amp;&amp; !completed &#123; HStack &#123; Circle() .trim(from: 0, to: 0.7) .stroke(Color.white, lineWidth: 3) .frame(width: 20, height: 30) .rotationEffect(.degrees(loading ? 360 : 0 )) .animation(.easeInOut.repeatForever(autoreverses: false), value: loading) Text(&quot;Processing&quot;) .font(.system(.title, design: .rounded)) .bold() .foregroundStyle(.white) &#125; .transition(.opacity) .onAppear &#123; // 页面出现时调用 startProcessing() &#125; &#125; // 完成后显示 if completed &#123; Text(&quot;Done&quot;) .font(.system(.title, design: .rounded)) .bold() .foregroundStyle(.white) .onAppear &#123; self.endProcessing() &#125; &#125; &#125; .animation(.spring, value: loading) .onTapGesture &#123; if !loading &#123; processing.toggle() &#125; &#125; &#125; // 开始处理 private func startProcessing() &#123; self.loading = true // 模拟处理过程，4s 后更新为处理完成状态 DispatchQueue.main.asyncAfter(deadline: .now() + 4) &#123; self.completed = true &#125; &#125; // 结束处理 private func endProcessing() &#123; // 3s 后重置按钮的所有状态 DispatchQueue.main.asyncAfter(deadline: .now() + 3) &#123; self.processing = false self.completed = false self.loading = false &#125; &#125;&#125;","categories":[{"name":"SwiftUI 进阶","slug":"SwiftUI-进阶","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"withAnimation","slug":"withAnimation","permalink":"https://swift.qingmaoedu.com/tags0/withAnimation/"},{"name":"Animation","slug":"Animation","permalink":"https://swift.qingmaoedu.com/tags0/Animation/"}]},{"title":"Xcode必备技巧（一）","slug":"Xcode必备技巧（一）","date":"2023-10-15T01:58:27.000Z","updated":"2023-10-15T03:48:54.272Z","comments":true,"path":"posts/3249ee52.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/3249ee52.html","excerpt":"Xcode 中常用的快捷键1. Command + 0 显示&#x2F;隐藏左侧文件导航栏 2. Command + Shift + O","text":"Xcode 中常用的快捷键1. Command + 0 显示&#x2F;隐藏左侧文件导航栏 2. Command + Shift + O 打开有一个快捷搜索，通过关键字快速定位到对应的文件、函数或者变量。 3. Command + Shift + J 快速定位当前文件的所在的位置。 4. Command + Shift + Y 快速显示&#x2F;隐藏Xcode 底部的调试区域，即输出控制台部分。 5. Command + Option + [ 光标所在行的代码向上移动。 6.Command + Option + ] 光标所在行的代码向下移动。 7. Command + Option + 0 显示&#x2F;隐藏右侧区域。 8. Control + I 光标所在行的代码进行随进对齐。 经常和Command + A 一起使用，即全选当前文件的所有代码，然后对所有的代码进行美化操作。 Xcode 中的多光标编辑Xcode 和很多的其他开发工具一样，也支持多光标的编辑操作。 Xcode 中有多种添加多光标的方式： 方式一：Control + Shift + 单击鼠标左键。 方式二： Control + Shift + 方向上下键(推荐方式)。 Xcode 中开启拼写检查在开发过程中，我们会经常遇到各种命名拼写错误的情况，为了尽量避免这个情况的出现，Xcode 给我们提供了一个拼写检查的功能。 开启路径如下： Xcode 左上角的菜单栏中Edit -&gt; Format -&gt; Spelling and Grammar -&gt; Check Spelling While Typing， 勾选住这个设置选项即可。 开启前的效果： 开启后的效果： 当出现拼写错误的时候，可以选中这个拼写错误的单词，然后鼠标右键就可以看到 Xcode 给我们提供的修改建议和处理方法了。","categories":[{"name":"Xcode 使用技巧","slug":"Xcode-使用技巧","permalink":"https://swift.qingmaoedu.com/categories/Xcode-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://swift.qingmaoedu.com/tags0/Xcode/"},{"name":"快捷键","slug":"快捷键","permalink":"https://swift.qingmaoedu.com/tags0/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}]},{"title":"SwiftUI 中的基础动画和过渡（二）","slug":"SwiftUI-中的基础动画和过渡（二）","date":"2023-10-14T08:53:53.000Z","updated":"2023-10-16T03:01:39.601Z","comments":true,"path":"posts/a0094105.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/a0094105.html","excerpt":"在上一篇文章中，我们已经介绍了 SwiftUI 中的隐式动画和显式动画。 在 SwiftUI中，只需要更多的关注动画的开始和结束，动画的过程由 SwiftUI 帮我们自动完成。接着我们来实现一些常见的动画效果。 创建一个加载动画1234567891011121314151617struct ContentView: View &#123; @State var isLoading: Bool = false var body: some View &#123; ZStack() &#123; Circle() .trim(from: 0, to: 0.8) .stroke(lineWidth: 10) .fill(.green) .rotationEffect(.degrees(isLoading ? 360 : 0)) .animation(.default.repeatForever(autoreverses: false), value: isLoading) &#125; .frame(width: 100, height: 100) .onAppear &#123; isLoading = true &#125; &#125;&#125;","text":"在上一篇文章中，我们已经介绍了 SwiftUI 中的隐式动画和显式动画。 在 SwiftUI中，只需要更多的关注动画的开始和结束，动画的过程由 SwiftUI 帮我们自动完成。接着我们来实现一些常见的动画效果。 创建一个加载动画1234567891011121314151617struct ContentView: View &#123; @State var isLoading: Bool = false var body: some View &#123; ZStack() &#123; Circle() .trim(from: 0, to: 0.8) .stroke(lineWidth: 10) .fill(.green) .rotationEffect(.degrees(isLoading ? 360 : 0)) .animation(.default.repeatForever(autoreverses: false), value: isLoading) &#125; .frame(width: 100, height: 100) .onAppear &#123; isLoading = true &#125; &#125;&#125; 在上面的代码中， 使用 Circle创建了一个非闭合的圆环； 给Cricle添加了rotationEffect修饰器实现旋转的效果，它需要一个角度作为参数； 给Circle添加了隐式动画和动态变量isLoading进行绑定； 当整个视图显式的时候，将动态变量isLoading的值改为true，开始动画； 这里的animation动画的效果我们使用的是默认default，然后链式调用了 repeatForever方法，这个方法中可以设置动画是否反转。 不反转： 反转： 即设置为反转后，动画结束后会回到动画开始前的效果。 如果我们想要改变动画的速度，只需要将默认default动画设置为linear，然后修改duration参数即可。如下： 1.animation(.linear(duration: 1).repeatForever(autoreverses: false), value: isLoading) duration值越大，动画速度越慢，即持续时间越长。 另外，onAppear修饰器是 SwiftUI 中视图的生命周期函数，类似于 UIKit的中viewDidAppear方法，它的作用是当视图出现在屏幕是自动调用。 类似地，我们可以对代码稍加修改即可实习下面的这样效果： 修改后的代码如下： 1234567891011121314151617181920struct ContentView: View &#123; @State var isLoading: Bool = false var body: some View &#123; ZStack() &#123; Circle() .stroke(lineWidth: 10) .fill(Color(.systemGray5)) Circle() .trim(from: 0, to: 0.2) .stroke(lineWidth: 10) .fill(.green) .rotationEffect(.degrees(isLoading ? 360 : 0)) .animation(.linear(duration: 1).repeatForever(autoreverses: false), value: isLoading) &#125; .frame(width: 100, height: 100) .onAppear &#123; isLoading = true &#125; &#125;&#125; 动画延迟通过设置duration可以修改动画的速度，同样地可以通过设置delay来设置的延迟效果。 1234567891011121314151617struct ContentView: View &#123; @State var isLoading: Bool = false var body: some View &#123; HStack() &#123; ForEach(0..&lt;4, id: \\.self) &#123; index in Circle() .fill(.green) .frame(width: 10, height: 10) .scaleEffect(isLoading ? 0.3 : 1) .animation(.linear(duration: 0.6).repeatForever(autoreverses: true).delay(0.2 * Double(index)), value: isLoading) &#125; &#125; .onAppear &#123; isLoading = true &#125; &#125;&#125; 在上面的代码中，我们使用ForEach创建了四个相同的Circle，然后都给它们添加了一个大小改变的修饰器sacleEffect，动画效果我们设置为linear，链式调用了repeatForever和deplay方法。 delay通过0.2*Double(index)设置，即四个Circle的延迟动画时间分别为：0，0.2，0.4，0.6。通过设置延迟时间，可以让Circle动画的开始时间不同。 如果没有这个延迟时间，所有的Circle都将同时开始出现动画效果。 效果如下： 矩形变换为圆1234567891011121314151617181920212223242526272829303132struct ContentView: View &#123; @State var recordBegin: Bool = false @State var recording: Bool = false var body: some View &#123; ZStack &#123; RoundedRectangle(cornerRadius: recordBegin ? 30 : 5) .fill(recordBegin ? .red : .green) .frame(width: recordBegin ? 60 : 240, height: 60) .overlay &#123; Image(systemName: &quot;mic.fill&quot;) .font(.title) .foregroundStyle(.white) .scaleEffect(recording ? 0.7 : 1.0) &#125; RoundedRectangle(cornerRadius: recordBegin ? 35 : 10) .trim(from: 0, to: recordBegin ? 0 : 1) .stroke(lineWidth: 5) .fill(.green) .frame(width: recordBegin ? 70 : 250, height: 70) &#125; .onTapGesture &#123; withAnimation(.linear(duration: 0.3)) &#123; recordBegin.toggle() &#125; withAnimation(.default.repeatForever().delay(0.5)) &#123; recording.toggle() &#125; &#125; &#125;&#125; 在上面的代码中，我们通过两个状态变量控制RoundedRectangle的frame和cornerRadius来实现一个圆角矩形到圆的变换效果。 效果如下：","categories":[{"name":"SwiftUI 进阶","slug":"SwiftUI-进阶","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"withAnimation","slug":"withAnimation","permalink":"https://swift.qingmaoedu.com/tags0/withAnimation/"},{"name":"Animation","slug":"Animation","permalink":"https://swift.qingmaoedu.com/tags0/Animation/"}]},{"title":"SwiftUI 中的基础动画和过渡（一）","slug":"SwiftUI-中的基础动画和过渡（一）","date":"2023-10-13T01:47:49.000Z","updated":"2023-10-14T08:36:46.476Z","comments":true,"path":"posts/b2c22197.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/b2c22197.html","excerpt":"SwiftUI 给我们提供了两种动画的实现方式： 隐式(implicit)动画 和显式(explicit)动画。这两种动画方式都可以让我们给视图添加动画和过渡。隐式动画通过修饰器animation给视图添加动画效果，显式动画则是使用withAnimation代码块的方式添加到视图。 隐式动画12345678910111213141516171819202122struct ContentView: View &#123; @State var circleColor: Bool = false @State var heartColor: Bool = false @State var heartSize: Bool = false var body: some View &#123; ZStack() &#123; Circle() .frame(width: 150, height: 150) .foregroundStyle(circleColor ? Color(.systemGray5) : .red) Image(systemName: &quot;heart.fill&quot;) .foregroundStyle(heartColor ? .red : .white) .font(.system(size: 80)) .scaleEffect(heartSize ? 1.0 : 0.5) &#125; .onTapGesture &#123; // 每次点击之后，三个状态值都进行取反操作 circleColor.toggle() heartColor.toggle() heartSize.toggle() &#125; &#125;&#125; 在上面的代码中，我们实现了： 使用@State定义了三个状态变量，用来控制圆的颜色、❤️的颜色以及大小； 使用Circle绘制了一个圆，然后在这个圆显示一个系统的图标，将二者使用ZStack进行组合； 给ZStack添加 一个点击手势onTapGesture，每次点击都对三个状态值进行取反操作，即toggle； 运用三目运算符 根据不同的状态值显式不同的颜色和大小。","text":"SwiftUI 给我们提供了两种动画的实现方式： 隐式(implicit)动画 和显式(explicit)动画。这两种动画方式都可以让我们给视图添加动画和过渡。隐式动画通过修饰器animation给视图添加动画效果，显式动画则是使用withAnimation代码块的方式添加到视图。 隐式动画12345678910111213141516171819202122struct ContentView: View &#123; @State var circleColor: Bool = false @State var heartColor: Bool = false @State var heartSize: Bool = false var body: some View &#123; ZStack() &#123; Circle() .frame(width: 150, height: 150) .foregroundStyle(circleColor ? Color(.systemGray5) : .red) Image(systemName: &quot;heart.fill&quot;) .foregroundStyle(heartColor ? .red : .white) .font(.system(size: 80)) .scaleEffect(heartSize ? 1.0 : 0.5) &#125; .onTapGesture &#123; // 每次点击之后，三个状态值都进行取反操作 circleColor.toggle() heartColor.toggle() heartSize.toggle() &#125; &#125;&#125; 在上面的代码中，我们实现了： 使用@State定义了三个状态变量，用来控制圆的颜色、❤️的颜色以及大小； 使用Circle绘制了一个圆，然后在这个圆显示一个系统的图标，将二者使用ZStack进行组合； 给ZStack添加 一个点击手势onTapGesture，每次点击都对三个状态值进行取反操作，即toggle； 运用三目运算符 根据不同的状态值显式不同的颜色和大小。 具体效果如下： 通过上面的效果我们会发现，每次点击之后对应视图的颜色和大小都会发生变化，但是这个变化是比较生硬的，这是因为我们没有给视图添加动画的原因。接着我们就分别给Circle和Image添加一个隐式的动画效果，即给每一个视图添加一个animation修饰器。 Circle的动画如下 ： 1.animation(.easeInOut, value: circleColor) Image的动画如下： 1.animation(.easeInOut, value: heartColor) 这里我们使用的animation修饰器需要两个参数，一个是动画类型，另一个是对应的一个动态变量的值。它的含义是当对应状态变量的值发生变化时，实现相关的动画效果。 此时的点击切换效果如下： SwiftUI 中给我们提供了很多种的动画类型，包括各种的ease、linear、spring等。关于不同的ease动画，可以到Easing Functions Cheat Sheet (easings.net) 查看。 显式动画上面的动画效果，我们同样可以使用显式动画来实现，在onTapGesture中将三个状态值的取反操作包裹在一个withAnimation代码块中，即： 12345withAnimation &#123; circleColor.toggle() heartColor.toggle() heartSize.toggle()&#125; 此时点击，视图已经有了一个默认的动画效果。当然，我们也可以去定义动画的类型： 12345withAnimation(.spring(duration: 1.2, bounce: 1, blendDuration: 3) &#123; circleColor.toggle() heartColor.toggle() heartSize.toggle()&#125; 效果如下： 在显式动画中，我们能很好的控制视图的动画效果。例如，如果我们不希望给❤️图标的大小变化添加任何的动画效果，只需要把heartSize.toggle()这行代码移到withAnimation代码块外面即可。如下： 12345withAnimation(.spring(duration: 1.2, bounce: 1, blendDuration: 3) &#123; circleColor.toggle() heartColor.toggle() &#125;heartSize.toggle() 如果我们想要在隐式动画 中实现和上面同样的效果，我们可以通过重新排序修饰器的方式来进行。 123456789101112131415161718192021222324struct ContentView: View &#123; @State var circleColor: Bool = false @State var heartColor: Bool = false @State var heartSize: Bool = false var body: some View &#123; ZStack() &#123; Circle() .frame(width: 150, height: 150) .foregroundStyle(circleColor ? Color(.systemGray5) : .red) .animation(.spring(duration: 1.0, bounce: 1,blendDuration: 3), value: circleColor) Image(systemName: &quot;heart.fill&quot;) .foregroundStyle(heartColor ? .red : .white) .font(.system(size: 80)) .animation(.spring(duration: 1.0, bounce: 1,blendDuration: 3), value: heartColor) .scaleEffect(heartSize ? 0.7 : 0.5) &#125; .onTapGesture &#123; circleColor.toggle() heartColor.toggle() heartSize.toggle() &#125; &#125;&#125; 在上面的代码中，针对Image的动画，我们将animation修饰器放在了scaleEffect 前面，那么当对应的状态值heartColor发生变化时这个动画效果就不会作用在scaleEffect上，即❤️的图标不会有尺寸变化的效果。","categories":[{"name":"SwiftUI 进阶","slug":"SwiftUI-进阶","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"withAnimation","slug":"withAnimation","permalink":"https://swift.qingmaoedu.com/tags0/withAnimation/"},{"name":"Animation","slug":"Animation","permalink":"https://swift.qingmaoedu.com/tags0/Animation/"}]},{"title":"SwiftUI 之使用 Path 和 Shape 进行形状绘制","slug":"SwiftUI-之使用-Path-和-Shape-进行形状绘制","date":"2023-10-10T01:19:29.000Z","updated":"2023-10-13T01:47:03.101Z","comments":true,"path":"posts/cde0e673.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/cde0e673.html","excerpt":"了解 Path在 SwiftUI 中，如果想要绘制线条或者形状，可以使用Path，Path 是一个结构体用来实现2D 形状的绘制。 如果我们想要绘制下面的形状， 代码如下： 1234567Path() &#123; path in path.move(to: CGPoint(x: 20, y: 20)) path.addLine(to: CGPoint(x: 300, y: 20)) path.addLine(to: CGPoint(x: 300, y: 200)) path.addLine(to: CGPoint(x: 20, y: 200)) &#125; .fill(.green) // 填充色","text":"了解 Path在 SwiftUI 中，如果想要绘制线条或者形状，可以使用Path，Path 是一个结构体用来实现2D 形状的绘制。 如果我们想要绘制下面的形状， 代码如下： 1234567Path() &#123; path in path.move(to: CGPoint(x: 20, y: 20)) path.addLine(to: CGPoint(x: 300, y: 20)) path.addLine(to: CGPoint(x: 300, y: 200)) path.addLine(to: CGPoint(x: 20, y: 200)) &#125; .fill(.green) // 填充色 在上面的代码中： 使用move明确形状起点为(20,20)； 使用addLine绘制点(20,20)到点(300,20)的线 ； 使用addLine绘制点(300,20)到点(300,200)的线 ； 使用addLine绘制点(300,200)到点(20,200)的线 ； 使用fill进行形状的颜色填充。 使用 Stroke 绘制形状边框有时候，绘制的形状我们不一定是需要完全填充的，我们仅仅需要使用线条呈现出形状即可。这样的效果可以使用stroke修饰器实现。 1234567Path() &#123;path in path.move(to: CGPoint(x: 20, y: 20)) path.addLine(to: CGPoint(x: 300, y: 20)) path.addLine(to: CGPoint(x: 300, y: 200)) path.addLine(to: CGPoint(x: 20, y: 200)) &#125; .stroke(.green, lineWidth: 5) stroke提供了线条颜色和线条宽度两个参数。 此时的效果如下： 我们会发现此时的形状有一边是缺失的，在使用fill修饰器的时候，因为是整个面积都使用了颜色进行填充，所以我们没有发现这个问题。为什么会出现这样的问题呢，如果我们再去回看我们绘制形状的步骤，我们会发现我们并没有添加点(20,200)和点(20,20)的线。 解决这个问题有两中方法，一是添加回到起点的线： 1path.addLine(to: CGPoint(x: 20, y: 20)) 另一种就是使用Path提供了方法，让形状自动闭合： 1path.closeSubpath() 绘制CurvesPath内置的很多 API 可以帮助我们绘制很多的形状，不仅仅是局限于直线。addQuadCurve、addCurve和addArc可以帮助我们绘制曲线和圆弧。 如果我们想要绘制下面的形状效果，就可以使用addQuadCurve方法，这个方法需要两个参数锚点和控制点。 针对上面的曲线部分，它有两个锚点，分别是(40,60)和(210,60)， 它的控制点是(125,0)。当然，控制点是不是固定的，我们可以通过调节控制点的坐标来实现不同的曲线效果。 12345678910Path() &#123;path in path.move(to: CGPoint(x: 20, y: 60)) path.addLine(to: CGPoint(x: 40, y: 60)) path.addQuadCurve(to: CGPoint(x: 210, y: 60), control: CGPoint(x: 125, y: 0)) path.addLine(to: CGPoint(x: 230, y: 60)) path.addLine(to: CGPoint(x: 230, y: 100)) path.addLine(to: CGPoint(x: 20, y: 100)) path.closeSubpath() &#125; .fill(.purple) 绘制圆弧和饼状图如果我们想要绘制圆弧或者饼状图，可以使用addArc方法。addArc方法需要多个参数，包括中心点、半径、开始角度、结束角度以及绘制方向。 12345Path() &#123; path in path.move(to: CGPoint(x: 200, y: 200)) path.addArc(center: CGPoint(x: 200, y: 200), radius: 150, startAngle: .degrees(0), endAngle: .degrees(60), clockwise: true) &#125; .fill(.green) 使用形状创建一个进度条指示器首先，使用LinearGradient定义一个渐变色： 123456// 进度条渐变色 private var purpleGradient = LinearGradient(gradient: Gradient(colors: [ Color(red:207/255 , green: 207/255, blue: 207/255), Color(red:107/255 , green: 116/255, blue: 179/255) ]), startPoint: .trailing, endPoint: .leading) 使用内置形状Circle绘制一个圆： 123Circle() .stroke(Color(.systemGray6), lineWidth: 10) .frame(width: 300, height: 300) 接着，在灰色圆的上面再添加一个使用渐变色定义的圆： 1234567891011121314151617Circle() .trim(from: 0, to: 0.85) // 从起点裁剪到 85%的位置 .stroke(purpleGradient, lineWidth: 10) .frame(width: 300, height: 300) .overlay &#123; VStack(spacing: 5) &#123; Text(&quot;85%&quot;) .font(.title) .fontWeight(.bold) .foregroundColor(.red) Text(&quot;完成度&quot;) .font(.body) .fontWeight(.bold) .foregroundStyle(.gray) &#125; &#125; 这里，我们用到了trim修饰器，它可以帮助我们定义Circle裁切。 此时效果如下： 绘制一个环状图使用上面trim，我们可以使用Circle绘制一个环状图。 12345678910111213141516171819202122232425262728293031323334struct ContentView: View &#123; var body: some View &#123; ZStack() &#123; Circle() .trim(from: 0, to: 0.3) .stroke(Color(.systemBrown), lineWidth: 50) Circle() .trim(from: 0.3, to: 0.5) .stroke(Color(.systemBlue), lineWidth: 50) Circle() .trim(from: 0.5, to: 0.8) .stroke(Color(.systemMint), lineWidth: 50) Circle() .trim(from: 0.8, to: 0.9) .stroke(Color(.systemPink), lineWidth: 50) Circle() .trim(from: 0.9, to: 1) .stroke(Color(.systemTeal), lineWidth: 50) .overlay &#123; Text(&quot;10%&quot;) .offset(CGSize(width: 90, height: -120)) .fontWeight(.bold) .font(.headline) .foregroundStyle(.white) &#125; &#125; .frame(width: 300, height: 300) &#125;&#125; 效果如下：","categories":[{"name":"SwiftUI 进阶","slug":"SwiftUI-进阶","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"Shape","slug":"Shape","permalink":"https://swift.qingmaoedu.com/tags0/Shape/"},{"name":"Path","slug":"Path","permalink":"https://swift.qingmaoedu.com/tags0/Path/"},{"name":"Stroke","slug":"Stroke","permalink":"https://swift.qingmaoedu.com/tags0/Stroke/"}]},{"title":"SwiftUI中的状态管理和绑定","slug":"SwiftUI中的状态管理和绑定","date":"2023-10-08T01:37:10.000Z","updated":"2023-10-08T05:23:08.097Z","comments":true,"path":"posts/72b6a6d3.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/72b6a6d3.html","excerpt":"在 SwiftUI 中，状态管理是一个非常重要的概念。假设我们有一个播放音乐的 app，当我们点击播放按钮▶️后，按钮的状态从暂停状态⏸️切换到了播放状态。这里我们可以理解为播放的状态从一个状态转移到了另一个状态，当然，在实际的应用中，我们可能存在很多个状态，当状态发生变化时，app 需要根据状态切换到对应用户界面，即 UI。 SwiftUI内置了状态管理的方式，它使用@State属性包装器去修饰一个变量，这个状态变量会被 SwiftUI 自动存储到应用内，当这个变量的值发生变化时，SwiftUI 会自动重新计算和更新视图，即更新 UI。 @State的基本使用首先，我们来看一下下面的代码： 123456789101112131415struct ContentView: View &#123; @State var playStatus: Bool = false // 当为 true 表示正在播放 var body: some View &#123; VStack &#123; Button(action: &#123; playStatus.toggle() // 布尔值取反 &#125;, label: &#123; Image(systemName: playStatus ? &quot;stop.circle.fill&quot; : &quot;play.circle.fill&quot; ) .resizable() .frame(width: 80, height: 80) .foregroundStyle(playStatus ? .red : .green) &#125;) &#125; &#125;&#125;","text":"在 SwiftUI 中，状态管理是一个非常重要的概念。假设我们有一个播放音乐的 app，当我们点击播放按钮▶️后，按钮的状态从暂停状态⏸️切换到了播放状态。这里我们可以理解为播放的状态从一个状态转移到了另一个状态，当然，在实际的应用中，我们可能存在很多个状态，当状态发生变化时，app 需要根据状态切换到对应用户界面，即 UI。 SwiftUI内置了状态管理的方式，它使用@State属性包装器去修饰一个变量，这个状态变量会被 SwiftUI 自动存储到应用内，当这个变量的值发生变化时，SwiftUI 会自动重新计算和更新视图，即更新 UI。 @State的基本使用首先，我们来看一下下面的代码： 123456789101112131415struct ContentView: View &#123; @State var playStatus: Bool = false // 当为 true 表示正在播放 var body: some View &#123; VStack &#123; Button(action: &#123; playStatus.toggle() // 布尔值取反 &#125;, label: &#123; Image(systemName: playStatus ? &quot;stop.circle.fill&quot; : &quot;play.circle.fill&quot; ) .resizable() .frame(width: 80, height: 80) .foregroundStyle(playStatus ? .red : .green) &#125;) &#125; &#125;&#125; 上面的代码中有以下的几个步骤： 使用@State修饰了 一个名为playStatus的变量，这个变量用来管理后面视图中的状态，这个状态变量是一个Bool类型，所以这个变量只有true和false两种状态； 在视图部分，有一个Button，按钮根据playStatus状态值的不同显示不用的颜色和按钮图片； 在点击按钮的时候，切换playStatus的状态，即有 true-&gt;false或者 false-&gt;true。 效果如下： 状态值和视图进行双向绑定现在，我们想创建一个计数的按钮，每当按钮被点击一次，按钮上的文字次数都加一。 123456789101112131415161718192021struct ContentView: View &#123; @State var counter: Int = 0 var body: some View &#123; VStack &#123; Button(action: &#123; counter += 1 // 每点击一次，counter + 1 &#125;, label: &#123; Circle() .fill(.red) .frame(width: 120,height: 120) .shadow(radius: 8) .overlay &#123; Text(&quot;\\(counter)&quot;) .font(.largeTitle) .foregroundStyle(.white) &#125; &#125;) &#125; &#125;&#125; 效果如下： 这里我们设想一下，如果我们需要创建多个相同的Button，那么我们应该如何操作呢？在这种情况下，我们都会专门定义一个子视图，如果是定义一个子视图，那么就需要父视图的状态值传递给到子视图，这是就需要使用到@Binding属性包装器。 12345678910111213141516171819struct CounterButton: View &#123; @Binding var counter: Int var body: some View &#123; Button(action: &#123; counter += 1 // 每点击一次，counter + 1 &#125;, label: &#123; Circle() .fill(.red) .frame(width: 120,height: 120) .shadow(radius: 8) .overlay &#123; Text(&quot;\\(counter)&quot;) .font(.largeTitle) .foregroundStyle(.white) &#125; &#125;) &#125;&#125; 在上面的代码中，同样地需要在子视图中定义一个变量，用来接收从父视图传过来的，因为我们这里要接收的是从父视图传过来的使用@State定义的变量，所以子视图中的变量就需要使用@Binding进行修饰。 接着就是在父视图中使用这个子视图： 1CounterButton(counter: $counter) 此时的效果和之前的是一样的，但是这里如果我们想要重复定义多个类似的Button只需要使用CounterButton这个子视图就好。 另外就是，这里的$符号是 SwiftUI 的一种语法格式，它表示让使用@State定义的变量counter和子视图CounterButton进行一个双向绑定。即，当这个值发生变化时，子视图同步重新进行计算和渲染。","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"State","slug":"State","permalink":"https://swift.qingmaoedu.com/tags0/State/"},{"name":"Binding","slug":"Binding","permalink":"https://swift.qingmaoedu.com/tags0/Binding/"}]},{"title":"SwiftUI 控件之 Button(二)","slug":"SwiftUI-控件之-Button-二","date":"2023-10-06T01:18:39.000Z","updated":"2023-10-06T02:51:28.680Z","comments":true,"path":"posts/c45d65f5.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/c45d65f5.html","excerpt":"使用渐变色作为按钮的背景颜色在 SwiftUI 中，我们不仅仅能使用一个明确的颜色作为按钮的背景色，也可以使用渐变色作为按钮的背景色。 12345678Button(action: &#123;&#125;, label: &#123; Text(&quot;Button&quot;)&#125;).padding().foregroundStyle(.white).background(.linearGradient(Gradient(colors: [.red, .blue]), startPoint: .leading, endPoint: .trailing)).clipShape(RoundedRectangle(cornerRadius: 10, style: .circular)) 在上面的示例中，我们使用了linearGradient创建了一个线性渐变色作为按钮的背景颜色，linearGradient需要三个参数， 参数一是一个Gradient类型的对象，需要给它设置一个Color类型数组作为渐变的颜色； 参数二和参数三分别是渐变的开始点和结束点，例如示例中表示的是渐变从左到右进行。 具体的效果如下：","text":"使用渐变色作为按钮的背景颜色在 SwiftUI 中，我们不仅仅能使用一个明确的颜色作为按钮的背景色，也可以使用渐变色作为按钮的背景色。 12345678Button(action: &#123;&#125;, label: &#123; Text(&quot;Button&quot;)&#125;).padding().foregroundStyle(.white).background(.linearGradient(Gradient(colors: [.red, .blue]), startPoint: .leading, endPoint: .trailing)).clipShape(RoundedRectangle(cornerRadius: 10, style: .circular)) 在上面的示例中，我们使用了linearGradient创建了一个线性渐变色作为按钮的背景颜色，linearGradient需要三个参数， 参数一是一个Gradient类型的对象，需要给它设置一个Color类型数组作为渐变的颜色； 参数二和参数三分别是渐变的开始点和结束点，例如示例中表示的是渐变从左到右进行。 具体的效果如下： 创建一个屏幕与屏幕等宽的按钮当一个按钮越大时，越能吸引到用户的注意力。所以，在一些情况下下，我们需要创建一个和屏幕完全等宽的按钮。想要实现这样的效果，我们可以给按钮添加frame修饰器，然后通过设置frame的参数来进行设置。 在上面示例的基础上添加frame修饰器，如下： 1.frame(minWidth: 0, maxWidth: .infinity) 在上面的代码中，我们给按钮设置了最小的宽度为 0，最大的宽度为无限，这意味着按钮将以尽可能的宽度填充在容器视图中。 效果如下： 需要注意的一点是：在 SwiftUI 中，同时添加padding和frame修饰器时，应当将frame修饰器置于padding前面。即 12.frame(minWidth: 0, maxWidth: .infinity).padding() 而不是： 12.padding().frame(minWidth: 0, maxWidth: .infinity) 类似地，还有padding和background。 12.padding().background(.linearGradient(Gradient(colors: [.red, .blue]), startPoint: .leading, endPoint: .trailing)) 而不是： 12.background(.linearGradient(Gradient(colors: [.red, .blue]), startPoint: .leading, endPoint: .trailing)).padding() 使用 ButtonStyle 定义按钮的样式在实际开发一个app 的过程中，我们都会让整个 app 中的按钮风格统一，这就意味这所有的按钮都会用到相同的修饰器。为了减少相同代码的冗余，我们可以通过自定义修饰器的方式来将一些需要重复使用的风格样式进行单独定义。针对Button而言，我们就可以通过ButtonStyle来重新定义一个新的按钮样式。 首先，自定义一个结构体，这个结构体需要实现ButtonStyle协议，在实现这个协议之后，这个协议需要实现一个makeBody的协议方法。 makeBody有一个configuration的参数，它是Configuration类型，configuration包含了一个名为label的属性，将我们通用的样式修饰器添加到这个属性上即可修改按钮的样式。 123456789101112struct GradientBackgroundStyle: ButtonStyle &#123; func makeBody(configuration: Configuration) -&gt; some View &#123; configuration.label .frame(minWidth: 0, maxWidth: .infinity) .padding() .foregroundStyle(.white) .background(.linearGradient(Gradient(colors: [.red, .blue]), startPoint: .leading, endPoint: .trailing)) .clipShape(RoundedRectangle(cornerRadius: 20, style: .circular)) .padding(.horizontal, 20) &#125;&#125; 定义好这个风格样式之后，只需要在原来的Button之后添加buttonStyle修饰器，然后创建一个GradientBackgroundStyle的对象作为参数传进去即可。 12345Button(action: &#123; &#125;, label: &#123; Text(&quot;Delete&quot;) &#125;) .buttonStyle(GradientBackgroundStyle()) 效果还是和之前一样，只是我们可以将相同的样式应用到多个按钮上。 使用 Button Role在 iOS 15 之后，SwiftUI 为 Button提供了一个role选项，设置了这个选项之后，SwiftUI 会根据设置的选项进行渲染。role选项提供了两种不同的类型，分别是cancel和destructive。 123456789Button(role: .cancel) &#123; &#125; label: &#123; Text(&quot;Delete&quot;) &#125; .buttonStyle(.borderedProminent) VStack(alignment: .leading) &#123; Text(&quot;.cancel&quot;) Text(&quot;.borderedProminent&quot;) &#125;.fontWeight(.bold) 不同的样式效果如下：","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"Button","slug":"Button","permalink":"https://swift.qingmaoedu.com/tags0/Button/"},{"name":"Gradient","slug":"Gradient","permalink":"https://swift.qingmaoedu.com/tags0/Gradient/"},{"name":"Modifier","slug":"Modifier","permalink":"https://swift.qingmaoedu.com/tags0/Modifier/"}]},{"title":"如何让 Text 中的文本内容自动进行调整","slug":"如何让-Text-中的文本内容自动进行调整","date":"2023-10-02T02:28:16.000Z","updated":"2023-10-02T02:58:13.530Z","comments":true,"path":"posts/585c3fa7.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/585c3fa7.html","excerpt":"在 SwiftUI 中，使用Text 添加了frame修饰器后文本内容经常出现显示不完整的情况，例如下面的场景： 如果我们希望在指定控件的范围内让文本内容尽可能地显示完整，我们可以给Text添加 minimumScaleFactor修饰器，即设置Text的最小比例因子。它的作用就是指定文本内容能按照设定的font原始尺寸缩小的最小比例，从而让文本内容尽可能的显示完整。例如： 12345678910VStack(spacing:20) &#123; Text(&quot;Swift is a powerful and intuitive programming language for all Apple platforms. It’s easy to get started using Swift, with a concise-yet-expressive syntax and modern features you’ll love. Swift code is safe by design and produces software that runs lightning-fast.&quot;) .font(.headline) Text(&quot;Swift is a powerful and intuitive programming language for all Apple platforms. It’s easy to get started using Swift, with a concise-yet-expressive syntax and modern features you’ll love. Swift code is safe by design and produces software that runs lightning-fast.&quot;) .font(.headline) .minimumScaleFactor(0.5) &#125; .padding() .frame(height: 200) 因为我们给HStack设置了frame，并把高度限制为200，所以在这个高度范围内是无法完整显示两个Text内容的。如果不给最后一个Text设置minimumScaleFator，它展示的效果如下： 设置后的效果如下： 通过前后两种效果的比较我们可以发现，在设置了minimumScaleFactor为 0.5后，后一个Text的字体大小在原来设置的font(.headline)的基础上进行缩小操作。","text":"在 SwiftUI 中，使用Text 添加了frame修饰器后文本内容经常出现显示不完整的情况，例如下面的场景： 如果我们希望在指定控件的范围内让文本内容尽可能地显示完整，我们可以给Text添加 minimumScaleFactor修饰器，即设置Text的最小比例因子。它的作用就是指定文本内容能按照设定的font原始尺寸缩小的最小比例，从而让文本内容尽可能的显示完整。例如： 12345678910VStack(spacing:20) &#123; Text(&quot;Swift is a powerful and intuitive programming language for all Apple platforms. It’s easy to get started using Swift, with a concise-yet-expressive syntax and modern features you’ll love. Swift code is safe by design and produces software that runs lightning-fast.&quot;) .font(.headline) Text(&quot;Swift is a powerful and intuitive programming language for all Apple platforms. It’s easy to get started using Swift, with a concise-yet-expressive syntax and modern features you’ll love. Swift code is safe by design and produces software that runs lightning-fast.&quot;) .font(.headline) .minimumScaleFactor(0.5) &#125; .padding() .frame(height: 200) 因为我们给HStack设置了frame，并把高度限制为200，所以在这个高度范围内是无法完整显示两个Text内容的。如果不给最后一个Text设置minimumScaleFator，它展示的效果如下： 设置后的效果如下： 通过前后两种效果的比较我们可以发现，在设置了minimumScaleFactor为 0.5后，后一个Text的字体大小在原来设置的font(.headline)的基础上进行缩小操作。 注意，它并不是缩小为原来尺寸的0.5，它只是在能显示完整内容的基础上进行了缩小，只是我们设定了最小能缩小的值为原来的0.5。 当我们把HStack的frame的height设置能完整显示两个Text时，字体就不会进行缩放了。 1.frame(height: 500) 同样地，如果把height设置的很小，后一个文本字体最小能缩放的范围也只是原来的0.5. 1.frame(height: 100) 如果把minimumScaleFactor设置为 0.1，它就可以缩的更小。","categories":[{"name":"SwiftUI 技巧","slug":"SwiftUI-技巧","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"Text","slug":"Text","permalink":"https://swift.qingmaoedu.com/tags0/Text/"}]},{"title":"SwiftUI控件之 PhotosPicker","slug":"SwiftUI控件之-PhotoPicker","date":"2023-09-28T01:02:09.000Z","updated":"2023-09-28T02:24:05.498Z","comments":true,"path":"posts/3f68e07.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/3f68e07.html","excerpt":"在 SwiftUI 中，有一个特殊的Picker（选择器），叫做PhotosPicker（相册选择器），使用它可以帮助快速获取手机相册中的照片。 创建一个 PhotosPickerPhotosPicker本身并不属于 SwiftUI这个模块中，它属于PhotosUI模块，所以我们首先需要在头部导入这个模块： 1import PhotosUI 使用 @State 定义一个变量用来和PhotosPicker进行绑定： 1@State var selectedImages: PhotosPickerItem? 创建PhotoPicker： 1PhotosPicker(&quot;选择喜欢的照片&quot;, selection: $selectedImages) 此时的效果如下： 注意：上图的效果为 iOS 17 以后的效果。","text":"在 SwiftUI 中，有一个特殊的Picker（选择器），叫做PhotosPicker（相册选择器），使用它可以帮助快速获取手机相册中的照片。 创建一个 PhotosPickerPhotosPicker本身并不属于 SwiftUI这个模块中，它属于PhotosUI模块，所以我们首先需要在头部导入这个模块： 1import PhotosUI 使用 @State 定义一个变量用来和PhotosPicker进行绑定： 1@State var selectedImages: PhotosPickerItem? 创建PhotoPicker： 1PhotosPicker(&quot;选择喜欢的照片&quot;, selection: $selectedImages) 此时的效果如下： 注意：上图的效果为 iOS 17 以后的效果。 因为相册里面的照片属于用户的敏感隐私数据，所以访问的时候会有隐私数据的提示。一般情况下，Apple 希望我们在隐私设置中添加访问敏感隐私数据的使用说明。 点击我们都项目根目录，在TARGETS中找到Info选项，在Custom iOS Target Properties中添加一个访问手机相册说明。 添加的记录如下，它是以Key-Value的形式存在的： 使用选中后的照片使用PhotosPicker选中后的照片为 PhotosPickerItem类型，我们要想让选中的照片使用Image进行显示需要使用 loadTransferable(type:completionHandler:) 方法，具体使用如下： 1234567891011121314151617181920212223242526struct ContentView: View &#123; @State var selectedImages: PhotosPickerItem? @State var avatarImage: Image? var body: some View &#123; VStack &#123; PhotosPicker(&quot;选择喜欢的照片&quot;, selection: $selectedImages) // 非空时显示 if let avatarImage &#123; avatarImage .resizable() .frame(width: 200, height: 200) &#125; &#125; // 当前 selectedImages的值发生变化时调用 .onChange(of: selectedImages) &#123; _ in // 创建一个异步任务 Task &#123; // 将选中的 PhotosPickerItem 类型转换为要显示的 Image if let image = try? await selectedImages?.loadTransferable(type: Image.self) &#123; avatarImage = image return &#125; &#125; &#125; &#125;&#125; 在上面的代码中，实现的步骤如下： 使用@State 定义一个 Image类型的变量用来接收转换后的照片； 使用onChange修饰器监听selectedImages变量值的的变化，当发生变化时将新的值转换为Image进行显示； 转换的过程中使用了Task创建了异步任务配合loadTransferable方法使用； 当avataImage的值不为nil时显示照片。 配置 PhotosPicker 可选择的范围在 iOS ，我们平时拍的照片、截图、录的视频或者下载保存的视频都是存储在相册中的，PhotosPicker提供了一个matching参数用来设置应用可以选择的相册范围。 例如，如果想要应用只能选择视频，可以像下面这样设置： 1PhotosPicker(&quot;选择喜欢的照片&quot;, selection: $selectedImages, matching: .videos) 它来提供了很多的范围可选，例如： panoramas：全景照片； images: 所有照片； videos: 所有视频； screenshots: 截图 ……","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"Picker","slug":"Picker","permalink":"https://swift.qingmaoedu.com/tags0/Picker/"},{"name":"PhotosPicker","slug":"PhotosPicker","permalink":"https://swift.qingmaoedu.com/tags0/PhotosPicker/"}]},{"title":"SwiftUI 控件之 ColorPicker","slug":"SwiftUI-控件之-ColorPicker","date":"2023-09-26T06:26:51.000Z","updated":"2023-09-26T06:56:10.149Z","comments":true,"path":"posts/d1bc9d76.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/d1bc9d76.html","excerpt":"在 SwiftUI 中，除了常见的Picker和DatePicker ，还有一个ColorPicker（颜色选择器），它在我们需要进行颜色选择时非常有用。 创建一个颜色选择器首先，使用@State创建一个Color类型的变量作为ColorPicker选中绑定值： 1@State var selectedOptions:Color = .red 创建ColorPicker： 123ColorPicker(selection: $selectedOptions, label: &#123; Text(&quot;选择你最喜欢的颜色&quot;) &#125;) 运行项目，点击的效果如下：","text":"在 SwiftUI 中，除了常见的Picker和DatePicker ，还有一个ColorPicker（颜色选择器），它在我们需要进行颜色选择时非常有用。 创建一个颜色选择器首先，使用@State创建一个Color类型的变量作为ColorPicker选中绑定值： 1@State var selectedOptions:Color = .red 创建ColorPicker： 123ColorPicker(selection: $selectedOptions, label: &#123; Text(&quot;选择你最喜欢的颜色&quot;) &#125;) 运行项目，点击的效果如下： 默认情况下，ColorPicker也支持颜色的透明度选择，如果不想用户选择颜色的透明度，可以将ColorPicker的参数supportsOpacity设置为false即可。如： 123ColorPicker(selection: $selectedOptions, supportsOpacity: false, label: &#123; Text(&quot;选择你最喜欢的颜色&quot;) &#125;) 此时的效果如下： ColorPicker并不支持我们过多的进行自定义，很多场景下，我们使用它的默认样式即可。","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"Picker","slug":"Picker","permalink":"https://swift.qingmaoedu.com/tags0/Picker/"},{"name":"ColorPicker","slug":"ColorPicker","permalink":"https://swift.qingmaoedu.com/tags0/ColorPicker/"}]},{"title":"SwiftUI 控件之 DatePicker","slug":"SwiftUI-控件之-DatePicker","date":"2023-09-25T01:09:28.000Z","updated":"2023-09-26T07:39:01.504Z","comments":true,"path":"posts/b30b2594.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/b30b2594.html","excerpt":"在 SwiftUI 中，Picker可以帮助我们实现一些常见的选择器应用场景。除此之外，SwiftUI 还给我们提供了其他两种常见的选择器，DatePicker（时间选择器）和 ColorPicker （选择器）。 创建一个 DatePickerDatePicker的创建和Picker创建一样，需要使用@State定义一个类型为Date的动态变量，然后将这个动态变量和DatePicker进行绑定： 1@State var selectedOptions:Date = Date() 1DatePicker(&quot;选择日期&quot;, selection: $selectedOptions) 默认情况下的效果如下：","text":"在 SwiftUI 中，Picker可以帮助我们实现一些常见的选择器应用场景。除此之外，SwiftUI 还给我们提供了其他两种常见的选择器，DatePicker（时间选择器）和 ColorPicker （选择器）。 创建一个 DatePickerDatePicker的创建和Picker创建一样，需要使用@State定义一个类型为Date的动态变量，然后将这个动态变量和DatePicker进行绑定： 1@State var selectedOptions:Date = Date() 1DatePicker(&quot;选择日期&quot;, selection: $selectedOptions) 默认情况下的效果如下： 默认情况下，我们可以选择日期和时间两种格式。我们也可以通过给DatePicker添加displayedComponents来配置可选项，例如： 1DatePicker(&quot;选择日期&quot;, selection: $selectedOptions, displayedComponents: [.date]) // 只可选择日期 或者 1DatePicker(&quot;选择日期&quot;, selection: $selectedOptions, displayedComponents: [.hourAndMinute]) // 只可选择时间 以及 1DatePicker(&quot;选择日期&quot;, selection: $selectedOptions, displayedComponents: [.hourAndMinute, .date]) // 默认均可选 不同样式的效果如下： 设置 DatePicker 的不同样式DatePicker的样式可以通过datePickerStyle修饰器来进行设置，它提供了compact、graphical和wheel三种样式。 12DatePicker(&quot;选择日期&quot;, selection: $selectedOptions, displayedComponents: [.hourAndMinute, .date]) // 默认均可选 .datePickerStyle(.graphical) 不同的样式如下： 设置可选择的日期范围在一些情况下，我们可能需要将可选择的日期限定在一定的范围内，这只需要我们给DatePicker添加一个in参数即可。in参数要求的是ClosedRange&lt;Date&gt;类型的一个范围区间， 12345678var bounds: ClosedRange&lt;Date&gt; &#123; let calendar = Calendar.current // 开始日期为当前的日期的前三天 let start = calendar.date(byAdding: .day, value: -3, to: .now)! // 结束日期为当前日期的未来三天 let end = calendar.date(byAdding: .day, value: 3, to: .now)! return start...end // 返回一个开区间 &#125; 使用： 12DatePicker(&quot;选择日期&quot;, selection: $date, in: bounds, displayedComponents: [.date]) .datePickerStyle(.graphical) 效果如下： DatePicker 本地化默认情况下，DatePicker 以英文的形式进行显示，如果我们需要让它显示为中文，就需要进行本地化处理。本地化处理的流程就是给DatePicker添加一个environment修饰器，然后将本地的语言设置为中文即可，具体如下： 123DatePicker(&quot;选择日期&quot;, selection: $selectedOptions) .datePickerStyle(.graphical) .environment(\\.locale, Locale.init(identifier: &quot;zh&quot;)) 本地化前后对比： 注意：在 Xcode 15.0 Beta中，并没有针对星期的显示进行本地化处理，无法确定是 Xcode 15.0 本身的问题还是最新的SwiftUI更新后的特性，在之前的的 Xcode 14.0中 本地化的处理也会对星期进行本地化，如下： 具体原因待后续观察！ MultiDatePicker（多日期选择器）有时间我们可能需要选择多个日期，这是就需要使用到MultiDatePicker。与DatePicker不同，MultiDatePicker的绑定值为DateComponents的元组Set类型，即： 12MultiDatePicker(&quot;选择日期&quot;, selection: $dates) .frame(height: 200) 效果如下： 注意，MultiDatePciker 的风格样式只支持graphical样式。不支持其他的风格。需要注意的另外一点就是，在设置MultiDatePicker的可选时间范围时，同样是给它添加一个in参数，但是它需要的是一个Range&lt;Date&gt;类型的日期范围而不是ClosedRange&lt;Date&gt;类型，前者要求的开区间范围，而后者要求的是一个闭区间范围。","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"DatePicker","slug":"DatePicker","permalink":"https://swift.qingmaoedu.com/tags0/DatePicker/"},{"name":"Picker","slug":"Picker","permalink":"https://swift.qingmaoedu.com/tags0/Picker/"},{"name":"MultiDatePicker","slug":"MultiDatePicker","permalink":"https://swift.qingmaoedu.com/tags0/MultiDatePicker/"},{"name":"Range","slug":"Range","permalink":"https://swift.qingmaoedu.com/tags0/Range/"}]},{"title":"SwiftUI控件之 Picker","slug":"SwiftUI控件之-Picker","date":"2023-09-23T02:30:27.000Z","updated":"2023-09-24T02:59:42.246Z","comments":true,"path":"posts/bd95df5.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/bd95df5.html","excerpt":"在我们做一些信息表单填写时，经常需要用到选择器（Picker）。 创建 Picker123456789Picker(&quot;今天周几&quot;, selection: $selectedOptions) &#123; Text(&quot;星期一&quot;) Text(&quot;星期二&quot;) Text(&quot;星期三&quot;) Text(&quot;星期四&quot;) Text(&quot;星期五&quot;) Text(&quot;星期六&quot;) Text(&quot;星期天&quot;)&#125; 使用@State创建一个动态响应的变量，用于和Picker进行绑定，当选中某一项时，这个变量对应的值也会发生变化。 1@State var selectedOptions:Int = 0 此时默认的效果如下： 但是如果我们此时选择任意一个其他的选项，发现并没有什么变化，而且控制台会输入下面的信息： Picker: the selection “0” is invalid and does not have an associated tag, this will give undefined results.","text":"在我们做一些信息表单填写时，经常需要用到选择器（Picker）。 创建 Picker123456789Picker(&quot;今天周几&quot;, selection: $selectedOptions) &#123; Text(&quot;星期一&quot;) Text(&quot;星期二&quot;) Text(&quot;星期三&quot;) Text(&quot;星期四&quot;) Text(&quot;星期五&quot;) Text(&quot;星期六&quot;) Text(&quot;星期天&quot;)&#125; 使用@State创建一个动态响应的变量，用于和Picker进行绑定，当选中某一项时，这个变量对应的值也会发生变化。 1@State var selectedOptions:Int = 0 此时默认的效果如下： 但是如果我们此时选择任意一个其他的选项，发现并没有什么变化，而且控制台会输入下面的信息： Picker: the selection “0” is invalid and does not have an associated tag, this will give undefined results. 这是因为我们没有给Picker的每一个选项设置一个不同的Tag值，我们只需要做下面的修改就可以解决这个问题。 12345678910111213141516Picker(&quot;今天周几&quot;, selection: $selectedOptions) &#123; Text(&quot;星期一&quot;) .tag(0) Text(&quot;星期二&quot;) .tag(1) Text(&quot;星期三&quot;) .tag(2) Text(&quot;星期四&quot;) .tag(3) Text(&quot;星期五&quot;) .tag(4) Text(&quot;星期六&quot;) .tag(5) Text(&quot;星期天&quot;) .tag(6)&#125; 这样解释了为什么我们在声明绑定的动态变量selectedOptions时，将它声明为Int类型了。 使用循环遍历的方式创建选项在上面的示例中，我们都是直接定义每个选项的内容，当我们的选项很多的时候我们可以使用ForEach循环创建选项： 123456Picker(&quot;今天周几&quot;, selection: $selectedOptions) &#123; ForEach(0..&lt;7) &#123; index in Text(&quot;选项\\(index+1)&quot;) .tag(index) &#125;&#125; 这里我们直接使用每次循环的索引作为选项的Tag值。 设置 Picker的不同风格和 SwiftUI 中很多其他的控件一样，Picker也提供了很多的样式，我们可以通过pickerStyle进行设置。 1234567Picker(&quot;今天周几&quot;, selection: $selectedOptions) &#123; ForEach(0..&lt;7) &#123; index in Text(&quot;选项\\(index+1)&quot;) .tag(index) &#125; &#125; .pickerStyle(.inline) 我们可以设置这些风格 inline、segmented、wheel、palette、menu、navigationLink。 不同风格的样式呈现如下： 注意：，navigationLinke样式需要和 NavigationStack 一起配合使用，即在父视图外面嵌套一个NavigationStack，具体如下： 123456789NavigationStack &#123; Picker(&quot;今天周几&quot;, selection: $selectedOptions) &#123; ForEach(0..&lt;7) &#123; index in Text(&quot;选项\\(index+1)&quot;) .tag(index) &#125; &#125; .pickerStyle(.navigationLink)&#125; 它的展示效果如下： 除了基础的Picker外，还有DatePicker（日期选择器） 和 ColorPicker（颜色选择器），我们将在后面的内容中详细介绍它们的使用。","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"Picker","slug":"Picker","permalink":"https://swift.qingmaoedu.com/tags0/Picker/"}]},{"title":"SwiftUI控件之 NavigationStack","slug":"SwiftUI控件之-NavigationStack","date":"2023-09-20T05:09:09.000Z","updated":"2023-09-20T06:40:49.375Z","comments":true,"path":"posts/80d98b55.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/80d98b55.html","excerpt":"在 SwiftUI 中，NavigationStack 用来作为一个根视图（root view）使得我们能够将一个新的视图展示在这个根视图上。 创建一个带导航栏和标题的app123456789101112struct ContentView: View &#123; var body: some View &#123; NavigationStack &#123; List &#123; ForEach(0..&lt;10,id: \\.self) &#123; index in Text(&quot;当前行\\(index)&quot;) &#125; &#125; .navigationTitle(&quot;导航栏标题&quot;) &#125; &#125;&#125;","text":"在 SwiftUI 中，NavigationStack 用来作为一个根视图（root view）使得我们能够将一个新的视图展示在这个根视图上。 创建一个带导航栏和标题的app123456789101112struct ContentView: View &#123; var body: some View &#123; NavigationStack &#123; List &#123; ForEach(0..&lt;10,id: \\.self) &#123; index in Text(&quot;当前行\\(index)&quot;) &#125; &#125; .navigationTitle(&quot;导航栏标题&quot;) &#125; &#125;&#125; 在上面的代码中， 将一个NavigationStack 作为整个页面的根视图； 给 NavigationStack 的第一个子视图List添加navigationTitle修饰器，注意，这个修饰器的作为就是给导航栏添加标题。 使用ForEach创建List的显示内容。 此时，效果如下： 导航栏风格在默认情况下，iOS 中的导航栏为大标题的样式。可以通过navigationBarTitleDisplayMode修改标题的样式： inline：小标题样式，之前 UIKit中常用的样式； larget：大标题样式，SwiftUI app 中的默认样式。 不过，即使在大标题的样式下，当我们向下滑动时，当标题样式也会变为小标题样式，向上滑动到顶部时又会重新变为原来的样式。 使用NavigationLink 实现页面跳转和展示文章开头我们说过，使用NavigationStack作为根视图来实现页面的展示。要想实现其他视图的展示或者常见的导航栏页面跳转需要和NavigationLink一起使用。 123456NavigationLink &#123; // 要展示的视图 Text(&quot;当前页面\\(index)&quot;)&#125; label: &#123; Text(&quot;当前行\\(index)&quot;)&#125; 这里，我们使用的是 NavigationLink(destination: () -&gt; View, label: () -&gt; View)函数，destination参数表示的展示的视图，label表示通过那个视图来触发展示的内容，即被点击的视图。 当我们添加了NavigationLink之后，List中的每一行视图都会变成可点击的样式，然后我们点击任意一行之后都将跳转或者展示对应的页面。具体效果如下： 在上面的演示效果中，我们会发现，当我们进入展示的目标视图页面，目标视图页面本身也会带上导航栏并且自带返回功能。 注意，在一些旧版本的 SwiftUI 代码中，使用的是NavigationView实现相同的功能，目前NavigationView已被逐步放弃，官方更推荐我们使用NavigationLink。","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"NavigationStack","slug":"NavigationStack","permalink":"https://swift.qingmaoedu.com/tags0/NavigationStack/"},{"name":"NavigationLink","slug":"NavigationLink","permalink":"https://swift.qingmaoedu.com/tags0/NavigationLink/"}]},{"title":"SwiftUI控件之 ScrollView(二)","slug":"SwiftUI控件之-ScrollView-二","date":"2023-09-18T01:22:33.000Z","updated":"2023-09-18T04:40:08.199Z","comments":true,"path":"posts/ff84e235.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/ff84e235.html","excerpt":"实现快速滚动到顶部或底部的效果在很多的ScrollView 的应用中，我们经常见到点击“回到顶部”按钮实现快速回到顶部的效果。 在 SwiftUI中，如果我们想要实现这样的效果，我们可以使用ScrollViewRader和ScrollView来实现。ScrollViewRader可以让我们通过编程的方式实现滚动到一个已知的子视图的位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct ContentView: View &#123; @Namespace var topID @Namespace var bottomID var body: some View &#123; ScrollViewReader &#123; proxy in ScrollView &#123; // 顶部的按钮 Button &#123; withAnimation &#123; proxy.scrollTo(bottomID) &#125; &#125; label: &#123; Text(&quot;滚动到底部&quot;) &#125; .id(topID) // 滚动视图 VStack(spacing: 0.1) &#123; ForEach(0..&lt;100) &#123;i in color(fraction: Double(i) / 100) .frame(height: 32) &#125; &#125; // 顶部的按钮 Button(action: &#123; withAnimation &#123; proxy.scrollTo(topID) &#125; &#125;, label: &#123; Text(&quot;滚动到顶部&quot;) &#125;) .id(bottomID) &#125; &#125; &#125; // 创建颜色 func color(fraction: Double) -&gt; Color &#123; Color(red: fraction, green: 1 - fraction, blue: 0.5) &#125;&#125;","text":"实现快速滚动到顶部或底部的效果在很多的ScrollView 的应用中，我们经常见到点击“回到顶部”按钮实现快速回到顶部的效果。 在 SwiftUI中，如果我们想要实现这样的效果，我们可以使用ScrollViewRader和ScrollView来实现。ScrollViewRader可以让我们通过编程的方式实现滚动到一个已知的子视图的位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct ContentView: View &#123; @Namespace var topID @Namespace var bottomID var body: some View &#123; ScrollViewReader &#123; proxy in ScrollView &#123; // 顶部的按钮 Button &#123; withAnimation &#123; proxy.scrollTo(bottomID) &#125; &#125; label: &#123; Text(&quot;滚动到底部&quot;) &#125; .id(topID) // 滚动视图 VStack(spacing: 0.1) &#123; ForEach(0..&lt;100) &#123;i in color(fraction: Double(i) / 100) .frame(height: 32) &#125; &#125; // 顶部的按钮 Button(action: &#123; withAnimation &#123; proxy.scrollTo(topID) &#125; &#125;, label: &#123; Text(&quot;滚动到顶部&quot;) &#125;) .id(bottomID) &#125; &#125; &#125; // 创建颜色 func color(fraction: Double) -&gt; Color &#123; Color(red: fraction, green: 1 - fraction, blue: 0.5) &#125;&#125; 在上面的示例代码中，实现了一下几个步骤： 在ScrollView外面嵌套了一层ScrollViewReader； ScrollView的子视图包括顶部按钮、 100 个渐变颜色子视图和底部按钮是三个部分； 使用@NameSpace创建了topID 和bottomID 两个变量，然后将它们分别给到顶部和底部按钮； 利用ScrollViewRader 提供的proxy 在点击两个按钮的时候滚动到指定的 ID 的子视图位置。 效果如下： 实现滚动到指定索引的位置创建一个数据结构： 12345struct NameModel: Identifiable &#123; let name:String let id: String = UUID().uuidString let index: Int&#125; 生成一些测试使用的数据源： 12345678// 数据源var nameDatas:[NameModel] &#123; get &#123; (0..&lt;100).map &#123; NameModel(name: &quot;我是-\\($0)&quot;, index: $0) &#125; &#125;&#125; 界面布局： 12345678910111213141516171819var body: some View &#123; ScrollViewReader &#123; proxy in ScrollView &#123; Button(action: &#123; withAnimation &#123; proxy.scrollTo(nameDatas[scrollToIndex].index) &#125; &#125;, label: &#123; Text(&quot;滚动到索引为\\(scrollToIndex)的地方&quot;) &#125;) ForEach(nameDatas) &#123; data in Text(data.name) .padding(4) .id(data.index) &#125; &#125; &#125; &#125; 此时的效果为当我们点击按钮后，ScrollView将滚动到子视图 ID为 70 的位置： 注意：这里目前依然存在一个问题，当我们使用数据模型的id属性作为ScrollView子视图的ID 时，即 .id(data.id)，无法实现类似的效果。","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"ScrollView","slug":"ScrollView","permalink":"https://swift.qingmaoedu.com/tags0/ScrollView/"},{"name":"ScrollViewReader","slug":"ScrollViewReader","permalink":"https://swift.qingmaoedu.com/tags0/ScrollViewReader/"}]},{"title":"SwiftUI 控件之 ScrollView(一)","slug":"SwiftUI-控件之-ScrollView（一）","date":"2023-09-17T01:43:58.000Z","updated":"2023-09-17T03:16:47.443Z","comments":true,"path":"posts/35d3a19e.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/35d3a19e.html","excerpt":"在 SwiftUI 中，ScrollView 是一个可滚动的视图。 创建一个 ScrollView当我们使用ForEach 循环创建超出一整个屏幕的内容时： 12345VStack &#123; ForEach(0..&lt;100) &#123; index in Text(&quot;当前行\\(index)&quot;) &#125; &#125; 在上面的代码中，我们使用VStack和ForEach 创建了 100 个Text，此时要显示的内容已经超出了一个屏幕所能显示的内容，我们无法看到超出屏幕范围的内容。为了解决这个问题，我们就可以在最外层嵌套一个ScrollView，让整个视图变成滚动显示的。 1234567ScrollView &#123; VStack &#123; ForEach(0..&lt;100) &#123; index in Text(&quot;当前行\\(index)&quot;) &#125; &#125; &#125; 此时，我们就可以通过上下滚动的方式查看所有的Text 了。","text":"在 SwiftUI 中，ScrollView 是一个可滚动的视图。 创建一个 ScrollView当我们使用ForEach 循环创建超出一整个屏幕的内容时： 12345VStack &#123; ForEach(0..&lt;100) &#123; index in Text(&quot;当前行\\(index)&quot;) &#125; &#125; 在上面的代码中，我们使用VStack和ForEach 创建了 100 个Text，此时要显示的内容已经超出了一个屏幕所能显示的内容，我们无法看到超出屏幕范围的内容。为了解决这个问题，我们就可以在最外层嵌套一个ScrollView，让整个视图变成滚动显示的。 1234567ScrollView &#123; VStack &#123; ForEach(0..&lt;100) &#123; index in Text(&quot;当前行\\(index)&quot;) &#125; &#125; &#125; 此时，我们就可以通过上下滚动的方式查看所有的Text 了。 ScrollView的相关配置控制 ScrollView 的滚动位置可以通过defaultScrollAnchor 修饰器配置ScrollView的开始滚动的起始位置，它支持以下几个位置： top : 从顶部开始滚动； bottom : 从底部开始滚动； center： 从中间位置开始滚动； leading: 从左侧开始滚动； trailing： 从右侧开始滚动； topLeading：从左上开始滚动； topTrailing：从右上开始滚动； bottomLeading：从左下开始滚动； bottomTrailing：从右下开始滚动。 1.defaultScrollAnchor(.center) 控制 ScrollView 滚动的方向ScrollView 支持水平horizontal和垂直vertical方向的滚动。 123ScrollView(.vertical) &#123; &#125; 控制 ScrollView 滚动指示器的显示&#x2F;隐藏ScrollView 滚动的时候，视图边缘会有一个滚动的指示器。可以使用scrollIndicators 修饰器来控制它的显示或者隐藏。 1.scrollIndicators(.hidden) hidden: 表示隐藏； visible: 表示显示； never：和hidden 一致； 指定水平或垂直方向上的显示或者隐藏： 1.scrollIndicators(.hidden, axes: [.horizontal])","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"ScrollView","slug":"ScrollView","permalink":"https://swift.qingmaoedu.com/tags0/ScrollView/"}]},{"title":"SwiftUI控件之 List（二）","slug":"SwiftUI控件之-List（二）","date":"2023-09-16T00:37:34.000Z","updated":"2023-09-16T02:45:11.219Z","comments":true,"path":"posts/37193cc1.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/37193cc1.html","excerpt":"创建 List在之前的List 使用中，我们是直接使用ForEach 循环遍历一个数组来实现的，在遍历的时候我们把self 作为List中必须的ID。接下来，我们通过自定义一个数据对象同时让它实现Identifiable。 1234struct Ocean: Identifiable &#123; let name: String let id: String = UUID().uuidString&#125; 在上面的代码中，我们自定义了一个结构体类型的对象Ocean ，同时让它实现了Identifiable 协议。在实现这个协议之后，它需要结构体的有一个名为id的成员属性，然后这个属性的值我们直接通过UUID().uuisString 创建一个字符串类型的值给它，这样可以实现之后创建的每一个Ocean 实例对象都有一个唯一的ID，便于我们在List 遍历时使用。","text":"创建 List在之前的List 使用中，我们是直接使用ForEach 循环遍历一个数组来实现的，在遍历的时候我们把self 作为List中必须的ID。接下来，我们通过自定义一个数据对象同时让它实现Identifiable。 1234struct Ocean: Identifiable &#123; let name: String let id: String = UUID().uuidString&#125; 在上面的代码中，我们自定义了一个结构体类型的对象Ocean ，同时让它实现了Identifiable 协议。在实现这个协议之后，它需要结构体的有一个名为id的成员属性，然后这个属性的值我们直接通过UUID().uuisString 创建一个字符串类型的值给它，这样可以实现之后创建的每一个Ocean 实例对象都有一个唯一的ID，便于我们在List 遍历时使用。 同样地，使用数组的方式创建一些数据源。 1234567private var oceans = [ Ocean(name: &quot;Pacific&quot;), Ocean(name: &quot;Atlantic&quot;), Ocean(name: &quot;Indian&quot;), Ocean(name: &quot;Southern&quot;), Ocean(name: &quot;Arctic&quot;)] 使用List 和 ForEach创建一个List： 12345List &#123; ForEach(oceans) &#123; ocean in Text(ocean.name) &#125;&#125; 注意：在上面的代码中，由于ForEach遍历的对象实现了Identifiable协议，所以我们就不再需要去单独设置id。 或者可以直接讲数据源给到List来创建： 123List(oceans) &#123; ocean in Text(ocean.name)&#125; 上面的代码也可以通过语法进行简写： 123List(oceans) &#123; Text($0.name) &#125; 简写前和简写后的效果是一样的，简写代码中的$0表示遍历的第一个参数，还可以有类似于$1、$2 …等这样的形式。 List 中的多选首先将List嵌套到NavigationStack中实现一个带顶部导航栏的样式： 123456NavigationStack &#123; List(oceans) &#123; Text($0.name) &#125; .navigationTitle(&quot;Oceans&quot;) // 导航栏的标题&#125; 同时，通过toolBar添加一个EditButton 按钮： 123.toolbar &#123; EditButton() &#125; 完整代码如下： 12345678910111213141516171819202122struct ContentView: View &#123; private var oceans = [ Ocean(name: &quot;Pacific&quot;), Ocean(name: &quot;Atlantic&quot;), Ocean(name: &quot;Indian&quot;), Ocean(name: &quot;Southern&quot;), Ocean(name: &quot;Arctic&quot;) ] @State private var multiSelection = Set&lt;String&gt;() var body: some View &#123; NavigationStack &#123; List(oceans, selection: $multiSelection) &#123; Text($0.name) &#125; .navigationTitle(&quot;Oceans&quot;) // 导航栏的标题 .toolbar &#123; EditButton() &#125; Text(&quot;当前选中：\\(multiSelection.count)&quot;) &#125; &#125;&#125; 在上面的代码中，实现了一下几步： 通过NavigationStack 实现了导航栏； 在toolBar上添加了一个EditButton，当点击 EditButton后List 将进入可编辑模式； 使用@State 定义了一个元素类型和Ocean 中id 类型（String）一致的动态元祖变量，然后将这个变量和List中的selection绑定，当 List 进入编辑模式之后我们就可以获取到被选中的List中唯一的ID。 效果如下： List 的下拉刷新加载首先将数据源oceans 使用@State 声明为动态的响应式类型： 1234567@State private var oceans = [ Ocean(name: &quot;Pacific&quot;), Ocean(name: &quot;Atlantic&quot;), Ocean(name: &quot;Indian&quot;), Ocean(name: &quot;Southern&quot;), Ocean(name: &quot;Arctic&quot;) ] 然后给List添加一个refreshable 修饰器： 1234.refreshable &#123; // 每次刷新向 oceans 数组中添加一个新的元素 oceans.append(.init(name: &quot;Other&quot;)) &#125; 此时，当程序运行后，每次下拉刷新List 中都将添加一个新的名为Other 的元素。","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"List","slug":"List","permalink":"https://swift.qingmaoedu.com/tags0/List/"},{"name":"NavigationStack","slug":"NavigationStack","permalink":"https://swift.qingmaoedu.com/tags0/NavigationStack/"},{"name":"EditButton","slug":"EditButton","permalink":"https://swift.qingmaoedu.com/tags0/EditButton/"},{"name":"Identifier","slug":"Identifier","permalink":"https://swift.qingmaoedu.com/tags0/Identifier/"}]},{"title":"SwiftUI控件之 TextField","slug":"SwiftUI控件之-TextField","date":"2023-09-13T06:13:47.000Z","updated":"2023-09-17T03:36:11.029Z","comments":true,"path":"posts/edbc1019.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/edbc1019.html","excerpt":"在 SwiftUI 中，TextField 用来展示和接收用户编辑的文本内容。 使用在创建一个TextField之前，需要先定义一个响应式类型的状态变量： 1@State private var userName:String = &quot;&quot; 在创建TextField 时，使用$userName 的形式绑定这个状态变量： 1TextField(&quot;User Name&quot;,text: $userName) 当userName 这个变量和TextField 绑定后，当我们在输入框中输入或者删除内容时，userName 对应的值也会跟着发生变化。","text":"在 SwiftUI 中，TextField 用来展示和接收用户编辑的文本内容。 使用在创建一个TextField之前，需要先定义一个响应式类型的状态变量： 1@State private var userName:String = &quot;&quot; 在创建TextField 时，使用$userName 的形式绑定这个状态变量： 1TextField(&quot;User Name&quot;,text: $userName) 当userName 这个变量和TextField 绑定后，当我们在输入框中输入或者删除内容时，userName 对应的值也会跟着发生变化。 TextField 的不同风格使用textFieldStyle 修饰器来定义TextField的不同风格： roundedBorder： 圆角边框样式； plain ： 默认的无边框样式； 1234567VStack(spacing: 20) &#123; TextField(&quot;User Name&quot;,text: $userName) .textFieldStyle(.roundedBorder) TextField(&quot;User Name&quot;,text: $userName) .textFieldStyle(.plain)&#125; 效果如下： SecureField除了常见的TextField ，还可以使用SecureField 来获取一些隐私数据的输入，例如密码。 1SecureField(&quot;Password&quot;,text: $password) 使用安全输入框时，当用户输入类似于密码之类的隐私数据时，会以**····** 形式呈现，从而起到保护隐私数据的作用。 官方文档TextField | Apple Developer Documentation SecureField | Apple Developer Documentation","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"TextField","slug":"TextField","permalink":"https://swift.qingmaoedu.com/tags0/TextField/"},{"name":"SecureField","slug":"SecureField","permalink":"https://swift.qingmaoedu.com/tags0/SecureField/"}]},{"title":"SwiftUI控件之 Label","slug":"SwiftUI控件之-Label","date":"2023-09-13T05:41:11.000Z","updated":"2023-09-13T06:05:40.847Z","comments":true,"path":"posts/8bd109ea.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/8bd109ea.html","excerpt":"在 SwiftUI 中，Label 用来展示一个文本和图标（icon）。 使用使用Assets 中的图片作为Label 的图标： 1Label(&quot;avatar&quot;, image: &quot;avatar&quot;) 使用SF Symbols 中的图标作为Label 的图标： 1Label(&quot;apple&quot;, systemImage: &quot;apple.logo&quot;) 设置不同的Label样式可以使用labelStyle 修饰器来定义 Label 的样式： iconOnly : 只显示图标； titleAndIcon: 显示文字和图标，默认样式； titleOnly ： 只显示文字； automatic：自动。 12Label(&quot;apple&quot;, systemImage: &quot;apple.logo&quot;) .labelStyle(.automatic)","text":"在 SwiftUI 中，Label 用来展示一个文本和图标（icon）。 使用使用Assets 中的图片作为Label 的图标： 1Label(&quot;avatar&quot;, image: &quot;avatar&quot;) 使用SF Symbols 中的图标作为Label 的图标： 1Label(&quot;apple&quot;, systemImage: &quot;apple.logo&quot;) 设置不同的Label样式可以使用labelStyle 修饰器来定义 Label 的样式： iconOnly : 只显示图标； titleAndIcon: 显示文字和图标，默认样式； titleOnly ： 只显示文字； automatic：自动。 12Label(&quot;apple&quot;, systemImage: &quot;apple.logo&quot;) .labelStyle(.automatic) 使用一个 View作为 Label 的图标1234567891011121314Label &#123; Text(&quot;Felix&quot;) .font(.body) .foregroundStyle(.primary) Text(&quot;Zhao&quot;) .font(.subheadline) .foregroundStyle(.secondary) &#125; icon: &#123; Circle() .fill(.red) .frame(width: 44, height: 44) .overlay(Text(&quot;F&quot;))&#125; 在上面的Label 中，我们使用两个不同样式的Text 作为Label 要显示的文字内容；使用一个Circle 作为Label的自定义图标视图。 效果如下：","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"Label","slug":"Label","permalink":"https://swift.qingmaoedu.com/tags0/Label/"}]},{"title":"SwiftUI控件之 List（一）","slug":"SwiftUI控件之-List(一)","date":"2023-09-12T01:17:29.000Z","updated":"2023-09-16T00:37:00.147Z","comments":true,"path":"posts/57a1224a.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/57a1224a.html","excerpt":"在很多 app 中，我们经常能看到上下滚动的列表，在 SwiftUI 中，我们可以使用List 实现这样的功能。 创建一个列表要实现一个列表，我们需要先创建一个数组类型的数据源： 1var books: [String] = [&quot;西游记&quot;, &quot;红楼梦&quot;, &quot;三国演义&quot;, &quot;水浒传&quot;] 使用 ForEach 遍历数组，将元素显示到 List中： 12345List &#123; ForEach(books, id: \\.self) &#123; book in Text(&quot;《\\(book)》&quot;) &#125;&#125; 除了上面的这种方式，我们还可以直接将数据元给到List，然它进行循环创建列表： 123List(books, id: \\.self) &#123; book in Text(&quot;《\\(book)》&quot;)&#125; 这里我们注意到，不管是我们使用哪种方式，我们都需要设置一个id的参数，这是因为List 要求每一行的元素都要有一个唯一的id，以便我们后续对List 进行编辑操作。这里我们是直接将循环出来的元素对象本身作为id 给它。 注意，这在数据源中元素不会出现重复的情况下是可行，但是如果存在重复相同的元素，就会出现编辑异常的情况。","text":"在很多 app 中，我们经常能看到上下滚动的列表，在 SwiftUI 中，我们可以使用List 实现这样的功能。 创建一个列表要实现一个列表，我们需要先创建一个数组类型的数据源： 1var books: [String] = [&quot;西游记&quot;, &quot;红楼梦&quot;, &quot;三国演义&quot;, &quot;水浒传&quot;] 使用 ForEach 遍历数组，将元素显示到 List中： 12345List &#123; ForEach(books, id: \\.self) &#123; book in Text(&quot;《\\(book)》&quot;) &#125;&#125; 除了上面的这种方式，我们还可以直接将数据元给到List，然它进行循环创建列表： 123List(books, id: \\.self) &#123; book in Text(&quot;《\\(book)》&quot;)&#125; 这里我们注意到，不管是我们使用哪种方式，我们都需要设置一个id的参数，这是因为List 要求每一行的元素都要有一个唯一的id，以便我们后续对List 进行编辑操作。这里我们是直接将循环出来的元素对象本身作为id 给它。 注意，这在数据源中元素不会出现重复的情况下是可行，但是如果存在重复相同的元素，就会出现编辑异常的情况。 不同的 listStyle我们可以通过 listStyle 修饰器来定义List 不同的风格样式，insetGrouped、inset、grouped、plain、sidebar、automatic。 注意，在不同的系统中样式显示也不一致。例如sidebar 样式在 iPadOS 中显示为侧边栏样式，在 iOS 中则为默认的样式。 1.listStyle(.automatic) List 分组和设置 footer 、 header如果我们想要实现 List 分组的效果，可以使用 Section ，然后Section 的构造方法分别给每个分组设置header 和footer。 12345678910111213141516171819202122List &#123; Section &#123; ForEach(books, id: \\.self) &#123; book in Text(&quot;《\\(book)》&quot;) &#125; &#125; header: &#123; Text(&quot;四大名著&quot;) .bold() &#125; footer: &#123; Text(&quot;推荐阅读书籍&quot;) &#125; Section &#123; ForEach(books, id: \\.self) &#123; book in Text(&quot;《\\(book)》&quot;) &#125; &#125; header: &#123; Text(&quot;四大名著&quot;) .bold() &#125; footer: &#123; Text(&quot;推荐阅读书籍&quot;) &#125;&#125; 效果如下：","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"List","slug":"List","permalink":"https://swift.qingmaoedu.com/tags0/List/"},{"name":"Identifier","slug":"Identifier","permalink":"https://swift.qingmaoedu.com/tags0/Identifier/"},{"name":"ForEach","slug":"ForEach","permalink":"https://swift.qingmaoedu.com/tags0/ForEach/"}]},{"title":"SwiftUI之 VStack、 HStack、 ZStack","slug":"SwiftUI之-VStack、-HStack、-ZStack","date":"2023-09-09T01:02:53.000Z","updated":"2023-09-09T03:03:27.543Z","comments":true,"path":"posts/e7687e8f.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/e7687e8f.html","excerpt":"在 SwiftUI 中，我们会经常使用到 VStack、HStack、ZStack 来帮助我们进行布局。 VStack在VStack中的子视图都将按照垂直方向进行排列。 例如： 12345VStack &#123; Image(systemName: &quot;globe&quot;) Text(&quot;Hello, World!&quot;) .font(.body)&#125; 此时的布局效果如下：","text":"在 SwiftUI 中，我们会经常使用到 VStack、HStack、ZStack 来帮助我们进行布局。 VStack在VStack中的子视图都将按照垂直方向进行排列。 例如： 12345VStack &#123; Image(systemName: &quot;globe&quot;) Text(&quot;Hello, World!&quot;) .font(.body)&#125; 此时的布局效果如下： HStack和VStack 类似，不过 HStack是将子视图按照水平方向 进行排列。 类似地，将上面示例代码中的VStack 改为HStack : 12345HStack &#123; Image(systemName: &quot;globe&quot;) Text(&quot;Hello, World!&quot;) .font(.body)&#125; 效果如下： 对于 VStack 和 HStack 而言，都可以设置它们子视图之前的间距spacing 和对齐方式alignment 。 区别在于，VStack 的对齐方式有： center：居中对齐； leading ：左对齐； trailing ： 右对齐。 HStack 的对齐方式有： center ：居中对齐； top ：顶部对齐； bottom：底部对齐。 12345VStack(alignment: .leading, spacing: 10) &#123; Image(systemName: &quot;globe&quot;) Text(&quot;Hello, World!&quot;) .font(.body)&#125; 12345HStack(alignment: .top, spacing: 10) &#123; Image(systemName: &quot;globe&quot;) Text(&quot;Hello, World!&quot;) .font(.body) &#125; ZStackZStack 是让子视图按照Z轴方向 堆叠排列。 12345678ZStack &#123; Image(&quot;avatar&quot;) .resizable() .frame(width: 200, height: 200) Text(&quot;Hello, World!&quot;) .font(.body) .foregroundStyle(.white)&#125; 效果如下： ZStack 只能设置对齐方式alignment，它的对齐方式包括： top：顶部对齐； bottom：底部对齐； center：居中对齐； leading：左对齐； trailing: 右对齐； topLeading：左上角对齐； topTrailing：右上角对齐； bottomLeading：左下角对齐； bottomTrailing: 右下角对齐。 布局示例VStack1234567891011struct VStackContentView: View &#123; var body: some View &#123; // 左对齐，上下间距为10 VStack(alignment: .leading, spacing: 10) &#123; ForEach(0...10, id: \\.self) &#123; Text(&quot;选项\\($0)&quot;) Divider() &#125; &#125;.padding(10) &#125;&#125; HStack1234567891011struct HStackContentView: View &#123; var title: String = &quot;朋友圈&quot; var body: some View &#123; HStack(alignment: .center, spacing: 10) &#123; Text(title) Spacer() Image(systemName: &quot;chevron.right&quot;) &#125; .padding(10) &#125;&#125; ZStack123456789101112131415struct ZStackContentView: View &#123; // ZStack 实现头像置于背景之上的效果 var body: some View &#123; ZStack &#123; Image(&quot;bg&quot;) .resizable() .scaledToFit() .frame(height: 300) Image(&quot;avatar&quot;) .resizable() .frame(width: 100, height: 100) .clipShape(Circle()) // 圆形头像设置 &#125; &#125;&#125; VStack、 HStack和 ZStack 一起使用1234567891011121314struct LayoutDemo: View &#123; var options = [&quot;朋友圈&quot;, &quot;发现&quot;, &quot;游戏&quot;, &quot;更多&quot;] var body: some View &#123; VStack &#123; ZStackContentView() VStack &#123; ForEach(options, id: \\.self) &#123; title in HStackContentView(title: title) Divider() &#125; &#125; &#125; &#125;&#125; ContentView1234567891011121314151617181920212223242526272829303132struct ContentView: View &#123; @State var selectedSeg:Int = 3 private let segmentArr = [&quot;VStack&quot;, &quot;HStack&quot;, &quot;ZStack&quot;, &quot;Layout&quot;] var body: some View &#123; VStack(spacing: 20) &#123; Picker(selection: $selectedSeg) &#123; ForEach(0 ..&lt; segmentArr.count) &#123; Text(segmentArr[$0]).tag($0) &#125; &#125; label: &#123; &#125; .pickerStyle(.segmented) //设置选择器的样式 // 根据选择器绑定值的变化不同，显示不同的布局视图 switch selectedSeg &#123; case 0: VStackContentView() case 1: HStackContentView() Divider() case 2: ZStackContentView() case 3: LayoutDemo() default: Spacer() &#125; Spacer() &#125; &#125;&#125; 效果如下：","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"VStack","slug":"VStack","permalink":"https://swift.qingmaoedu.com/tags0/VStack/"},{"name":"HStack","slug":"HStack","permalink":"https://swift.qingmaoedu.com/tags0/HStack/"},{"name":"ZStack","slug":"ZStack","permalink":"https://swift.qingmaoedu.com/tags0/ZStack/"}]},{"title":"SwiftUI 控件之 Image","slug":"SwiftUI-控件之-Image","date":"2023-09-08T01:52:11.000Z","updated":"2023-10-01T02:25:45.231Z","comments":true,"path":"posts/6b844059.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/6b844059.html","excerpt":"在 SwiftUI 中，我们可以使用Image控件来展示一张图片。 基础使用在 SwiftUI中，如果我们需要使用Image显示一张图片，首先我们需要先将图片资源拖到蓝色的Assets文件夹中，然后使用图片的文件名加载显示。 1Image(&quot;avatar&quot;) 在最新的 Xcode 15.0中，增加了使用下面的方式加载资源文件夹中的图片的特性： 1Image(.avatar) 上面两种方式的效果是一样的。","text":"在 SwiftUI 中，我们可以使用Image控件来展示一张图片。 基础使用在 SwiftUI中，如果我们需要使用Image显示一张图片，首先我们需要先将图片资源拖到蓝色的Assets文件夹中，然后使用图片的文件名加载显示。 1Image(&quot;avatar&quot;) 在最新的 Xcode 15.0中，增加了使用下面的方式加载资源文件夹中的图片的特性： 1Image(.avatar) 上面两种方式的效果是一样的。 常用的修饰器宽高设置图片显示的frame： 12Image(.avatar) .frame(width: 100, height: 200) 当我们设置Image的frame后，我们发现它并没有按照我们所给的宽高进行显示，这是因为我们需要先添加 resizzble 修饰器。 123Image(.avatar) .resizable() .frame(width: 100, height: 200) 填充但是此时我们可能会发现，我们的图片显示变形 了，这主要是因为我们的图片宽高比例和所给的frame 的宽高比例并不一致。我们可以通过设置scaledToFill或者scaledToFit 修饰器来修饰图片的填充样式。 123456789101112131415161718192021222324struct ContentView: View &#123; var body: some View &#123; VStack(spacing: 20) &#123; VStack &#123; Image(.avatar) .resizable() .scaledToFit() .frame(width: 100, height: 200) .border(.red) Text(&quot;scaledToFit&quot;) &#125; Divider() VStack &#123; Image(.avatar) .resizable() .aspectRatio(contentMode: .fill) .scaledToFill() .frame(width: 100, height: 200) .border(.red) Text(&quot;scaledToFill&quot;) &#125; &#125; &#125;&#125; 效果如下： 在预览图中，红色 的边框表示我们实际设置的frame 范围。在同一张图片和同样的frame设置下，我们可以很清楚的看到scaledToFit和scaledToFill的区别： scaledToFit 会优先按照给定的frame 宽度（width）进行填充； scaledToFill 会优先按照给定的frame 高度（height）进行填充。 对齐方式我们可以在通过frame设置宽高的时候来设置图片的对齐方式： 1.frame(width: 100, height: 200,alignment: .center) 默认情况下为居中（center）对齐方式. 图片裁切当图片超出定义的frame范围时，可以使用clipped 修饰器让图片显示的范围和我们定义的frame 一致： 123456Image(.avatar) .resizable() .scaledToFill() .frame(width: 100, height: 200,alignment: .top) .border(.red) .clipped() 效果如下： 将图片按照形状进行裁切： 1.clipShape(Circle()) 给图片添加一个 Overlay如果我们想要给Image添加一个遮罩层可以使用overlay修饰器，它的参数是一个View类型，这意味这我们可以将任意一个View类型的视图作为遮罩层。 123456.overlay &#123; Image(systemName: &quot;heart.fill&quot;) .foregroundStyle(.white) .font(.system(size: 40)) .opacity(0.8) &#125; 效果如下： overlay也可以通过设置alignment参数来设置遮罩层的对齐方式，例如： 12345678910.overlay(alignment: .center, content: &#123; Text(&quot;这是用AI生成的一个头像&quot;) .foregroundStyle(.black) .font(.title) .fontWeight(.bold) .padding() .background(.white) .clipShape(RoundedRectangle(cornerRadius: 8)) // 添加圆角 .opacity(0.8) // 透明度 &#125;) Image 加载显示 SF SymbolsSF Symbols 是 Apple 提供的一套系统内置的常用图标集。在最新的SF Symbols 5 中已经提供了总共5296个各种各样的图标。 在使用这些系统图标时，只需要使用Image(systemName:String)这个方法即可，systemName就是图标的名称。 1Image(systemName: &quot;heart.circle&quot;) 需要注意的一点是，SF Symbols 本质上还是属于字体的一部分，所以很多适用于字体设置的修饰器同样也适用于它。例如， 1234Image(systemName: &quot;heart.circle&quot;) .font(.title) .fontWeight(.bold) .foregroundStyle(.red) SF Symbols支持多种颜色和多种渲染模式。 通过代码可以这么进行设置： 12345Image(systemName: &quot;pencil.circle.fill&quot;) .font(.largeTitle) .fontWeight(.bold) .symbolRenderingMode(.palette) // 渲染模式 .foregroundStyle(.yellow, .tint, .red) // 颜色设置 对于一些特殊的Symbols，它可以设置一个可变的值，根据这个实现不同的样式。例如： 123Image(systemName: &quot;slowmo&quot;, variableValue: 0.2) .font(.system(size: 50)) .foregroundStyle(.indigo) 不同值的效果如下： 在最新的 SwiftUI 和 SF Symbols中还支持添加动画效果，我们将在后续动画部分进行介绍。","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://swift.qingmaoedu.com/tags0/Xcode/"},{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"Image","slug":"Image","permalink":"https://swift.qingmaoedu.com/tags0/Image/"},{"name":"SF Symbols","slug":"SF-Symbols","permalink":"https://swift.qingmaoedu.com/tags0/SF-Symbols/"},{"name":"Overlay","slug":"Overlay","permalink":"https://swift.qingmaoedu.com/tags0/Overlay/"}]},{"title":"SwiftUI控件之 Button(一)","slug":"SwiftUI控件之-Button(一)","date":"2023-09-07T01:25:02.000Z","updated":"2023-10-06T01:18:00.138Z","comments":true,"path":"posts/d48dbb48.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/d48dbb48.html","excerpt":"在 SwiftUI 中，Button 是一个视图，它可以响应触摸点击事件。Button 视图有一个基本的结构，包括标题（label）和动作（action）。动作是一个在按钮被点击时触发的函数。 按钮的定义下面是一个简单的 Button 示例： 123Button(&quot;按钮&quot;) &#123; print(&quot;按钮被点击了&quot;)&#125; 在上面的代码中，我们定义了按钮的文字按钮和点击的响应事件print(&quot;按钮被点击了&quot;)。除了这种方式，我们还可以使用另外一种常用的方式定义一个按钮： 12345Button &#123; print(&quot;按钮被点击了&quot;)&#125; label: &#123; Text(&quot;按钮&quot;)&#125;","text":"在 SwiftUI 中，Button 是一个视图，它可以响应触摸点击事件。Button 视图有一个基本的结构，包括标题（label）和动作（action）。动作是一个在按钮被点击时触发的函数。 按钮的定义下面是一个简单的 Button 示例： 123Button(&quot;按钮&quot;) &#123; print(&quot;按钮被点击了&quot;)&#125; 在上面的代码中，我们定义了按钮的文字按钮和点击的响应事件print(&quot;按钮被点击了&quot;)。除了这种方式，我们还可以使用另外一种常用的方式定义一个按钮： 12345Button &#123; print(&quot;按钮被点击了&quot;)&#125; label: &#123; Text(&quot;按钮&quot;)&#125; 在后面的这种方式中，我们是使用一个Text(&quot;按钮&quot;) 作为按钮的label，这样做的好处是可以更多的自定义按钮标题的样式。 1234567Button &#123; print(&quot;按钮被点击了&quot;)&#125; label: &#123; Text(&quot;按钮&quot;) .foregroundStyle(.black) .background(.gray)&#125; 除了使用Text 作为label 的要显示的内容，也可以使用其他的控件，例如Image。 1Image(systemName: &quot;apple.logo&quot;) 按钮的样式Button的风格可以通过 .buttonStyle 修饰器来进行修改，我们可以定义以下的几种风格： automatic、bordered、borderedProminent、borderless和plain。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct ContentView: View &#123; var body: some View &#123; VStack(spacing: 20) &#123; VStack(spacing: 10) &#123; Button(&quot;风格1&quot;) &#123; &#125;.buttonStyle(.automatic) Text(&quot;automatic&quot;) .font(.system(size: 12)) .foregroundStyle(.red) .fontWeight(.bold) &#125; Divider() VStack(spacing:10) &#123; Button(&quot;风格2&quot;) &#123; &#125;.buttonStyle(.bordered) Text(&quot;.bordered&quot;) .font(.system(size: 12)) .foregroundStyle(.red) .fontWeight(.bold) &#125; Divider() VStack(spacing:10) &#123; Button(&quot;风格3&quot;) &#123; &#125;.buttonStyle(.borderedProminent) Text(&quot;.borderedProminent&quot;) .font(.system(size: 12)) .foregroundStyle(.red) .fontWeight(.bold) &#125; Divider() VStack(spacing:10) &#123; Button(&quot;风格4&quot;) &#123; &#125;.buttonStyle(.borderless) Text(&quot;.borderless&quot;) .font(.system(size: 12)) .foregroundStyle(.red) .fontWeight(.bold) &#125; Divider() VStack(spacing:10) &#123; Button(&quot;风格5&quot;) &#123; &#125;.buttonStyle(.plain) Text(&quot;.plain&quot;) .font(.system(size: 12)) .foregroundStyle(.red) .fontWeight(.bold) &#125; &#125; &#125;&#125; 效果如下： 几种特殊的 ButtonEditButton1EditButton() EditButton 经常配合List 一起使用，实现List 的编辑功能。 SignInWithAppleButton使用SignInWithAppleButton 按钮，我们可以快速实现使用 Apple ID 的快速登录和登出。 首先，如果需要使用SignInWithAppleButton 控件，需要导入AuthenticationServices 模块： 1import AuthenticationServices 使用： 12345678910111213141516171819202122struct ContentView: View &#123; var body: some View &#123; VStack &#123; SignInWithAppleButton(.signIn, onRequest: &#123; request in // 发起登录、登出请求 request.requestedScopes = [.fullName, .email] &#125;, onCompletion: &#123; result in // 请求完成后的回调 switch result &#123; case .success(let authResults): print(&quot;Authorization successful.&quot;) case .failure(let error): print(&quot;Authorization failed: &quot; + error.localizedDescription) &#125; &#125;) .frame(width: 200, height: 50) .signInWithAppleButtonStyle(.whiteOutline) // 按钮的风格 &#125; &#125;&#125; 注意，SignInWithAppleButton 和普通的Button 不同，它可以根据我们的需要设置为signIn和signUp两种不同的状态，除此之外还需要实现两个回调。 效果如下： SignInWithAppleButton 也可以使用 signInWithAppleButtonStyle 修饰器进行样式的定义，可以定义以下三种样式： whiteOutline、black、white。 官方文档Button | Apple Developer Documentation EditButton | Apple Developer Documentation SignInWithAppleButton | Apple Developer Documentation","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"Button","slug":"Button","permalink":"https://swift.qingmaoedu.com/tags0/Button/"},{"name":"EditButton","slug":"EditButton","permalink":"https://swift.qingmaoedu.com/tags0/EditButton/"},{"name":"SignInWithAppleButton","slug":"SignInWithAppleButton","permalink":"https://swift.qingmaoedu.com/tags0/SignInWithAppleButton/"}]},{"title":"工欲善其事，必先利其器（Xcode 常见设置）","slug":"Xcode-常用配置","date":"2023-09-06T09:46:07.000Z","updated":"2023-09-06T09:54:17.994Z","comments":true,"path":"posts/b2a2499d.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/b2a2499d.html","excerpt":"Xcode 基础设置设置代码编辑器的字体和整体样式创建好项目之后，使用快捷 Command + , 或者顶部菜单栏的 Xcode→Settings 打开Xcode的偏好设置，在 Themes 主题选项部分可以选择或者设置代码编辑器的代码风格和字体大小：","text":"Xcode 基础设置设置代码编辑器的字体和整体样式创建好项目之后，使用快捷 Command + , 或者顶部菜单栏的 Xcode→Settings 打开Xcode的偏好设置，在 Themes 主题选项部分可以选择或者设置代码编辑器的代码风格和字体大小： 另外一个常用的设置是 显示&#x2F;隐藏 文件的扩展名，也可以根据需要指定需要隐藏&#x2F;显示 的文件类型： 显示文件扩展名： 隐藏文件扩展名： Xcode 整体布局设置显示&#x2F;隐藏 SwiftUI项目的预览区： 在Xcode的右上角部分，点击从右往左数的第二个图标，选中&#x2F;取消选中 Canvas 选项即可显示或关闭预览区： 另一个比较常用的设置是代码区域的预览小地图，按照上面的方式勾选 Minimap 即可在代码编辑区域的右上角显示代码预览，当一个代码文件的代码行数很多时，我们可以通过快速点击预览到达指定的代码位置。 上面的设置是我们比较常用，同时也是能极大提升我们开发效率的设置，随着对Xcode越来越熟悉也可以逐渐了解Xcode中更多的使用技巧。 除了上面的一些基础设置，接着我们来介绍几个Xcode中常用的快捷键： Command + B ： 快速进行项目的编译，可以在不运行的情况下检查我们的代码编写是否存在错误； Command + R ： 在指定模拟下运行项目； Command + N ： 在项目中创建一个文件； Command + Option + P ：重新加载SwiftUI的预览界面。在默认情况下，我们在代码区域编写完成SwiftUI的代码后，右边的预览区域会自动进行加载，但是当我们的SwiftUI代码很多或者自动加载失败时就可以使用这个快捷方式重新快速加载预览而无须通过鼠标点击的方式进行。","categories":[{"name":"Xcode 使用技巧","slug":"Xcode-使用技巧","permalink":"https://swift.qingmaoedu.com/categories/Xcode-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://swift.qingmaoedu.com/tags0/Xcode/"}]},{"title":"SwiftUI实践之创建一个待办清单（二）","slug":"SwiftUI实践之创建一个待办清单-二","date":"2023-09-05T06:19:53.756Z","updated":"2023-09-09T03:04:43.562Z","comments":true,"path":"posts/6b5357a8.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/6b5357a8.html","excerpt":"首页界面开发与点击交互项目创建和基础配置介绍完成后，接着我们来完成待办清单的首页开发。 创建文件和文件夹在Xcode左侧项目导航栏中，选择二级目录下的项目名，鼠标右键点击 New Group 创建一个名为 View 的文件夹： 创建后的项目结构如下： 这个文件夹将来存储我们之后创建的所有视图代码文件。","text":"首页界面开发与点击交互项目创建和基础配置介绍完成后，接着我们来完成待办清单的首页开发。 创建文件和文件夹在Xcode左侧项目导航栏中，选择二级目录下的项目名，鼠标右键点击 New Group 创建一个名为 View 的文件夹： 创建后的项目结构如下： 这个文件夹将来存储我们之后创建的所有视图代码文件。 在我们新建的 View 文件夹下新建一个名为 HomeView 的 SwiftUI文件： 此时的项目结构如下： 创建导航栏对初始文件 ContentView.swift 进行修改，修改后的代码如下： 123456789101112131415import SwiftUIstruct ContentView: View &#123; var body: some View &#123; NavigationView &#123; HomeView() &#125; &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ContentView() &#125;&#125; NavigationView 是一个导航视图控件，用来配置导航栏文字和按钮。 在 HomeView.swift 文件中开始编写如下代码： 1234567891011121314151617181920struct HomeView: View &#123; var body: some View &#123; // 添加一个ZStack布局 ZStack &#123; // TODO: 待创建内容 &#125; .navigationTitle(&quot;待办清单&quot;) // 导航栏标题 .navigationBarItems( // 导航栏左侧按钮 leading: EditButton(), // 导航栏右侧按钮 trailing: VStack &#123; Image(systemName: &quot;plus&quot;) .foregroundColor(.blue) // 图标颜色 Text(&quot;添加&quot;) .font(.subheadline) // 字体大小 .foregroundColor(.blue) // 字体颜色 &#125;) &#125;&#125; ZStack : Z轴层叠布局； VStack : 垂直布局； HStack : 水平布局； Image : 显示图片控件，经常和 Apple 提供的 SF Symbols 配合使用； EditButton : 编辑按钮； 此时，预览效果如下： SF Symbols 介绍和下载地址：SF Symbols - Apple Developer 创建待办列表在 ZStack 的内容部分 // TODO: 待创建内容 注释后面使用 List 创建一个待办列表： 12345678910111213141516171819202122232425262728293031List &#123; HStack &#123; Image(systemName: &quot;checkmark.circle&quot;) Text(&quot;Swift学习&quot;) Spacer() &#125; .font(.title2) .padding(12) // 内边距 HStack &#123; Image(systemName: &quot;checkmark.circle&quot;) Text(&quot;健身&quot;) Spacer() &#125; .font(.title2) .padding(12) // 内边距 HStack &#123; Image(systemName: &quot;checkmark.circle&quot;) Text(&quot;阅读&quot;) Spacer() &#125; .font(.title2) .padding(12) // 内边距 HStack &#123; Image(systemName: &quot;checkmark.circle&quot;) Text(&quot;聚餐&quot;) Spacer() &#125; .font(.title2) .padding(12) // 内边距 &#125; 此时，预览效果如下： 在上面的代码中，我们使用复制粘贴的方式使用了大量冗余的代码，接着我们通过自定义视图的方式实现视图的复用，从而减少冗余代码的使用。 在 View 文件夹下新建一个名为 TodoItemView.swift 的文件，在文件中添加编写下面的代码： 12345678910111213struct TodoItemView: View &#123; var todo:String = &quot;Swift学习&quot; // 待办事项 var isChecked: Bool = false // 是否已完成 var body: some View &#123; HStack &#123; Image(systemName: isChecked ? &quot;checkmark.circle&quot; : &quot;circle&quot;) // 根据是否完成显示不同的图标 Text(todo) Spacer() &#125; .font(.title2) .padding(12) // 内边距 &#125;&#125; 此时，TodoItemView的预览效果如下： 回到 HomeView.swift 视图页面，重新编辑 List 的内容： 1234567List &#123; TodoItemView() // 使用默认值 TodoItemView(todo: &quot;健身&quot;, isChecked: true) // 通过传值的方式自定义显示内容和状态 TodoItemView(todo: &quot;健身&quot;, isChecked: true) // 通过传值的方式自定义显示内容和状态 TodoItemView(todo: &quot;阅读&quot;, isChecked: true) // 通过传值的方式自定义显示内容和状态 TodoItemView(todo: &quot;聚餐&quot;, isChecked: true) // 通过传值的方式自定义显示内容和状态&#125; 此时，预览效果如下： 可以发现和之前效果是一样的，但是我们的代码变得更加简洁了。实际上，我们还可以使用数组和 ForEach 来进一步让我们的代码更加简洁。 在 body 上面定义一个字符串类型的数组： 1var todos: [String] = [&quot;SwiftUI 学习&quot;, &quot;健身&quot;, &quot;阅读&quot;, &quot;聚餐&quot;] 使用 ForEach 循环数据创建列表： 12345List &#123; ForEach(todos, id: \\.self) &#123; todo in TodoItemView(todo: todo) &#125;&#125; 到这里为止，我们只是简单的创建了一个字符串类型的数组，但是我们会发现所有的代码都是同一个状态，所以接下来我们需要创建一个数据模型来定义待办事项。 新建一个名为 Model 的文件夹，在这个文件夹先新一个名为 Todo.swift 的 Swift 文件，注意这里不是SwiftUI文件。 此时的文件结构如下： 在 Todo.swift 文件中定义一个结构体类型数据模型： 1234567891011121314import Foundationstruct Todo: Identifiable &#123; let id: String // 唯一ID，ForEach 的时候需要用到 let title: String // 待办事项 let isChecked: Bool // 待办状态 // 初始化方法 init(id: String = UUID().uuidString, title: String, isChecked: Bool) &#123; self.id = id self.title = title self.isChecked = isChecked &#125; &#125; 然后，将我们之前字符串数组进行修改： 123456var todos: [Todo] = [ Todo(title: &quot;SwiftUI学习&quot;, isChecked: false), Todo(title: &quot;健身&quot;, isChecked: false), Todo(title: &quot;阅读&quot;, isChecked: true), Todo(title: &quot;聚餐&quot;, isChecked: false), ] 修改 List 部分的代码： 12345List &#123; ForEach(todos) &#123; todo in TodoItemView(todo: todo.title, isChecked: todo.isChecked) &#125;&#125; 这里我们发现，我们在使用 ForEach 循环的时候，不再需要传递 id 参数，这是因为我们在定义模型的时候让 Todo 继承了 Identifiable 协议，并且声明了一个 id 成员，同时初始化的时候使用方法 UUID().uuidString 让每个元素都自动生成了一个独一无二的ID。 数据响应与交互接下来，我们要实现点击选中和编辑功能。 在SwiftUI中，响应式的数据交互是它的另外一个主要特点。接下来我们使用通过继承 ObservableObject 协议来创建一个响应式的数据模型。 在 Model 文件夹下新建一个名为 ListViewModel.swift 的文件，在这个文件中编辑下面的代码： 123456789import SwiftUI // 由于我们定义的是一个响应式的数据，所以这里需要引入SwiftUI框架class ListViewModel: ObservableObject &#123; @Published var todos:[Todo] = [ Todo(title: &quot;SwiftUI学习&quot;, isChecked: false), Todo(title: &quot;健身&quot;, isChecked: false), Todo(title: &quot;阅读&quot;, isChecked: true), Todo(title: &quot;聚餐&quot;, isChecked: false), ]&#125; 在定义一个响应式数据对象时，我们定义的是一个类即关键字使用的是 class ， 然后自定义的这个类需要继承自 ObservableObject 协议。对于类中的成员变量，如果需要进行响应式交互，我们需要使用关键字 @Published 进行修饰。 接着做以下的几处修改： 1、TodoItemView.swift 文件中： 12345678910111213struct TodoItemView: View &#123; var todo: Todo // 修改1 var body: some View &#123; HStack &#123; // 修改2 Image(systemName: todo.isChecked ? &quot;checkmark.circle&quot; : &quot;circle&quot;) // 根据是否完成显示不同的图标 Text(todo.title) Spacer() &#125; .font(.title2) .padding(12) // 内边距 &#125;&#125; 对预览文件进行修改，如果不需要预览也可以直接删除： 12345struct TodoItemView_Previews: PreviewProvider &#123; static var previews: some View &#123; TodoItemView(todo: .init(title: &quot;健身&quot;, isChecked: false)) &#125;&#125; 2、 HomeView.swift 文件中： 1234567891011121314151617181920212223242526struct HomeView: View &#123; var listModel: ListViewModel = ListViewModel() // 修改1 var body: some View &#123; // 添加一个ZStack布局 ZStack &#123; List &#123; // 修改2 ForEach(listModel.todos) &#123; todo in TodoItemView(todo: todo) &#125; &#125; &#125; .navigationTitle(&quot;待办清单&quot;) // 导航栏标题 .navigationBarItems( // 导航栏左侧按钮 leading: EditButton(), // 导航栏右侧按钮 trailing: VStack &#123; Image(systemName: &quot;plus&quot;) .foregroundColor(.blue) // 图标颜色 Text(&quot;添加&quot;) .font(.subheadline) // 字体大小 .foregroundColor(.blue) // 字体颜色 &#125;) &#125;&#125; 此时的预览或者运行效果和之前的一样。 接下来，我们需要给空间添加交互，例如点击或者滑动。 在 ListViewMode.swift 文件中添加一个状态更新函数： 123456789// 更新完成状态 func updateTodoStatus(todo: Todo) &#123; // 查询ID相同的第一个元素索引，可能为空，所以使用 if-let 进行解析 if let index = todos.firstIndex(where: &#123;$0.id == todo.id&#125;) &#123; todos[index].isChecked = !todos[index].isChecked // 完成状态取反 print(todo) print(todos) &#125; &#125; 给 TodoItemView 添加一个 onTapGesture 点击手势交互修饰器，在里面实现点击后状态更新的逻辑： 12345ForEach(listModel.todos) &#123; todo in TodoItemView(todo: todo).onTapGesture &#123; listModel.updateTodoStatus(todo: todo) &#125; &#125; 将项目运行在模拟器上或者在预览视图中直接运行，我们会发现点击后控价并没有发生任何的变化。 这是因为我们在声明一个继承自 ObservableObject 协议的类对象时，需要使用@ObservedObject 关键字进行修饰，即修改下面的代码： 1@ObservedObject var listModel: ListViewModel = ListViewModel() 此时，再运行我们的项目，点击任意一个待办事项，效果如下：","categories":[{"name":"使用SwiftUI创建一个待办清单","slug":"使用SwiftUI创建一个待办清单","permalink":"https://swift.qingmaoedu.com/categories/%E4%BD%BF%E7%94%A8SwiftUI%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"待办清单","slug":"待办清单","permalink":"https://swift.qingmaoedu.com/tags0/%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95/"}]},{"title":"SwiftUI实践之创建一个待办清单（一）","slug":"SwiftUI实践之创建一个待办清单（一）","date":"2023-09-05T05:47:17.000Z","updated":"2023-09-05T06:20:20.580Z","comments":true,"path":"posts/5b45bb70.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/5b45bb70.html","excerpt":"项目创建和基础配置说明创建项目1、打开Xcode Xcode的初始界面存在三种不同的项目创建方式： Create a new Xcode project: 创建一个全新的工程项目，最常用的项目创建方式； Cone an existing project: 克隆一个项目，适用于已经存在并且使用Git或SVN版本管理工具管理的项目； Open a project or file： 打开一个本机已经存在的项目或文件。","text":"项目创建和基础配置说明创建项目1、打开Xcode Xcode的初始界面存在三种不同的项目创建方式： Create a new Xcode project: 创建一个全新的工程项目，最常用的项目创建方式； Cone an existing project: 克隆一个项目，适用于已经存在并且使用Git或SVN版本管理工具管理的项目； Open a project or file： 打开一个本机已经存在的项目或文件。 2、选择第一个，创建一个全新的Xcode项目： 首先需要注意是，我们可以创建不同平台的应用项目，例如 iOS、macOS、watchOS、tvOS 或者是同时运行多个平台的项目。 这里我们选择 iOS，因为我们的应用只需要运行在iPhone或者iPad上。 针对我们常见的APP开发，我们有两个选项，分别是 App 和 App Playground。 二者的区别在于： App 选项创建的项目是一个工程文件，包含多个文件； App Playground 选项创建的项目是一个扩展名为 .swiftpm 的文件； App 选项创建的项目只能通过Mac电脑上的Xcode编译运行和二次开发；App Playground 选项创建的项目可以使用Xcode、iPad或者Mac上的 Swift Playgrounds 应用程序运行和二次开发。 App 选项创建的项目项目更加灵活，适用于大型项目或者多人协同开发；App Playground 选项创建的项目适用于个人或者小型软件开发； 细心的同学可能已经注意都一点，App Playground 选项创建的项目和在iPad上使用Swift Playgrounds创建的项目是一样的。 其他的一些项目创建选项主要用于一些特殊的应用开发，例如开发游戏、开发一个AR的应用以及开发软件包等。赶兴趣的同学可以自行了解。 选择 App 选项，点击 Next： 项目的配置信息： Product Name: 项目名称或者工程名称； Team: 开发团队名称，即开发者的Apple ID； Organization Identifier: 组织ID，一般为公司域名倒过来。例如正式域名为 www.qingmaoedu.com 倒过来就是 com.qingmaoedu.www ； Bundle Identifier: Xcode 使用组织名+项目名自动为应用生成的一个标识ID，这个ID在进行应用上架时会非常关键，也可以后续在Xcode中自行修改。需要注意的一点是，这个ID在App Store 中相当于应用的身份证号，且是唯一存在的； Interface: 应用开发要使用的技术框架，存在两个选项 SwiftUI 和 Storyboard，前者使用SwiftUI 作为主要的技术框架，后者使用UIKit作为主要的技术框架。当然这二者在后续的项目中可以混合使用。UIKit 是SwiftUI推出之前，开发iOS应用的唯一开发框架，用来实现界面的构建； Language : 开发语言，有 Swift 和 Objective-C 两种开发语言； Use Core Data : 项目是否使用 Core Data 框架；Core Data 是Apple提供的数据存储框架，可以实现本地存储和云存储； Include Tests : 是否包含测试到项目中，项目开发完成后进行功能和UI测试的时候会用到来编写测试用例。 最终项目配置如下： 点击 Next 选择一个项目文件的存储位置， 注意，这里有一个是否使用 Git 来对项目做一个版本管理的选项，如果我们熟悉Git和GitHub的使用或者这个项目需要多个人共同开发可以进行勾选。 项目结构介绍和基础配置1、项目结构 项目创建后，默认下的两个 Swift文件和我们之前使用 Swift Playgrounds 创建的一致。我们需要注意的是一个蓝色资源文件夹 Assets ，这个文件用存放我们项目中所有的素材 资源，例如图片、音视频、颜色数值等。 2、基础配置 选中项目的根目录，在 TARGETS→General 中可以找到项目的一些通用的基础配置： 在这个基础配置页面，我们比较常用的配置包括： Supported Destinations : 项目支持的硬件平台。我们可以在这里使用应用支持运行的平台，例如iPhone、iPad、Mac 或者Apple TV。 Minimum Deployments : 项目最低支持的运行系统版本。例如这里显示的iOS 16.4 意味着如果我们不进行修改，那么我们开发完成的项目将无法在低于 iOS 16.4 的系统上运行。 Identify ： 应用的标识。 App Category : 使用SwiftUI创建的项目可以在这里设置一个应用的默认图标； Display Name : 应用展示在桌面的名称，例如我们手机上常见的“淘宝”、“抖音”、“支付宝”等等，如果不进行设置默认为我们创建时设置的项目包名； Bundle Identifier : 应用的标识ID，默认自动生成，我们也可以进行修改，需要注意的是应用上架审核时这个ID必须是唯一存在的； Version : 应用版本号； Build: 应用编译版本号。 版本号和编译版本后在应用上架审核时用的比较多，平时基本不需要进行修改。 Deployment Info: 配置应用在设备上运行时可以支持的设备方向和状态栏默认的样式。 关于设备的方向： Portrait : 设备与地面垂直，Home 键位于底部或者面容识别位于顶部； Upside Down ：设备与地面垂直，Home 键位于顶部或者面容识别位于底部； Landscape Left ：设备的面容识别位于右侧或者Home 键位于左侧； Landscape Right ：设备的面容识别位于左侧或者Home 键位于右侧； API开发文档：UIDeviceOrientation | Apple Developer Documentation 打开 ContentView.swift 文件，同时打开预览界面，点击预览界面从左往右数的第三个选项按钮，然后打开 Orientation 的选项开即可调整预览界面中设备的不同方向。 在刚刚的Deployment Info 配置中，除了可以设置应用运行后的方向，也可以设置应用中顶部状态栏的样式: Default ：默认样式，根据页面的样式进行选择； Dark Content : 状态栏背景为白色，文字和图标为黑色，即白底黑字； Light Content : 状态栏背景为黑色，文字和图标为白色，即黑底白字； 配置项目和演示在 Xcode的顶部选择一个我们指定运行的模拟器： 如果没有想要的模拟器，可以点击底部的 Manage Run Destinations 选项去添加不同系统版本和型号的模拟器： 在后面的课程中，我们也将使用WiFi或者数据线的方式将应用运行在我们的手机上，即真机测试。 选中模拟器后，点击底部类似于播放▶️的按钮运行我们的项目，习惯使用快捷键的同学也可以使用 Commond + R 快捷键运行项目。 不修改任何配置的情况下，运行的效果如下： 点击模拟器顶部的 Home 键回到桌面，我们可以看到应用使用了一个默认的白色线框图标以及应用的名称为我们的项目名称。 需要注意的一点是，当我们通过上面介绍的这些设置去配置项目时，会发现存在以下的一些问题： 设置 App Category 和 Status Bar Style 都没有出现我们预期的效果。但是我们可以使用其他的方式去设置这个选项，例如在资源文件中添加我们自己的应用图标到 AppIcon 里面可以设置应用的图标，后续我们可以使用代码的方式去设置状态栏的样式。 当我们只给应用设置一个方向时，无论后续如何旋转我们的设备，界面布局都不会发生变化。即我们可以通过指定应用只能竖屏或者横屏的模式下运行，这样一来我们在开发的使用就不需要考虑不同屏幕方向下的界面布局了。","categories":[{"name":"使用SwiftUI创建一个待办清单","slug":"使用SwiftUI创建一个待办清单","permalink":"https://swift.qingmaoedu.com/categories/%E4%BD%BF%E7%94%A8SwiftUI%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"待办清单","slug":"待办清单","permalink":"https://swift.qingmaoedu.com/tags0/%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95/"}]},{"title":"Swift 控件之 Text","slug":"Swift-控件之-Text","date":"2023-09-04T06:01:33.000Z","updated":"2023-09-30T03:23:06.826Z","comments":true,"path":"posts/c90f7d11.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/c90f7d11.html","excerpt":"介绍在 SwiftUI 中，如果我们想要显示文本内容，可以使用 Text 控件。 使用方式1Text(&quot;Hello, world!&quot;) 常用的属性设置设置文字的颜色通过foregroundColor 设置文字的颜色： 12Text(&quot;Hello, world!&quot;) .foregroundColor(.black) **注意**，在 Xcode 15.0中，Apple 更推荐我们使用下面的方式设置文字的颜色，而且上面的修饰器将会在不久后被移除： 12Text(&quot;Hello, world!&quot;) .foregroundStyle(.black)","text":"介绍在 SwiftUI 中，如果我们想要显示文本内容，可以使用 Text 控件。 使用方式1Text(&quot;Hello, world!&quot;) 常用的属性设置设置文字的颜色通过foregroundColor 设置文字的颜色： 12Text(&quot;Hello, world!&quot;) .foregroundColor(.black) **注意**，在 Xcode 15.0中，Apple 更推荐我们使用下面的方式设置文字的颜色，而且上面的修饰器将会在不久后被移除： 12Text(&quot;Hello, world!&quot;) .foregroundStyle(.black) 设置字体的大小通过 font 设置字体的大小： 123Text(&quot;Hello, world!&quot;) .foregroundStyle(.black) .font(.title) 在上面代码中，我们直接使用了Apple 已经设计好的 Dynamic Type sizes 字体大小，详细介绍可以在 《Human Interface Guidelines》中找到 iOS, iPadOS Dynamic Type sizes。 除了使用 Apple 设计的动态尺寸大小的字体，我们也可以使用下面的方式定义字体的大小： 1.font(.system(size: 12)) 设置字重设置字重可以使用 fontWeight : 1.fontWeight(.bold) 如果只是对字体进行加粗操作，可以直接使用下面的修饰器 ： 1.bold() 注意 ，上面的两种设置字重的方式均只能在 iOS 16.0 之后的系统中可用。 设置字体的对齐方式1.multilineTextAlignment(.leading) // 多行文本左对齐 .center： 居中对齐； .leading ： 左对齐； .trailing： 右对齐。 限制文本显示的行数默认的情况下， Text 会完整的显示我们提供的字符串内容，在一些情况下我们需要限定最多所能显示的行数，可以使用lineLimit。 1.lineLimit(2) // 最多只能显示两行 限制文本显示的行数后，多余的文本将会被隐藏，然后以 … 的方式结尾。 设置内边距和行间距当Text 中的文本内容超过多行的时候，我们可以使用padding和lineSpacing修饰器来设置文本的行间距和内边距。 1234Text(&quot;Swift is a powerful and intuitive programming language for all Apple platforms. It’s easy to get started using Swift, with a concise-yet-expressive syntax and modern features you’ll love. Swift code is safe by design and produces software that runs lightning-fast.&quot;) .padding() .lineSpacing(10) .fontWeight(.bold) 旋转字体 SwiftUI 给我们提供了一个rotateEffec 修饰器来帮助我们简单的实现文本的旋转。 1.rotationEffect(.degrees(45)) // 顺时针旋转 45° 默认情况下，将按照文本的中心作为锚点进行旋转，我们也可以指定旋转的锚点，例如： 1.rotationEffect(.degrees(45),anchor: .topLeading) //以左上角的点作为锚点顺时针旋转 45° rotationEffect 实现的是 2D 的旋转效果，SwiftUI 还提供了 rotation3DEffect修饰器来实现一个 3D 的旋转效果。 1.rotation3DEffect(.degrees(60),axis: (x:1.0, y:0, z:0)) // 绕着 X 轴旋转 60° 给文字添加阴影如果想要给文字添加阴影，可以使用shadow修饰器。 1.shadow(color:.gray, radius: 2,x: 0, y: 15) shadow可以设置颜色、圆角、x轴和 y 轴多个参数。 效果如下： 使用自定义的字体在一下 app 中，我们可能想要使用自定义的字体而不是系统的字体。例如，我们想要使用https://fonts.google.com/specimen/Nunito 字体作为我们 app 的字体。那么我们就需要自定义 app 使用的字体。 首先，我们需要下载我们要使用的字体。一般情况下，字体都会提供多种样式，例如常规（regular）、加粗（bold）或者黑体（black）。 我们可以根据自己的需要将指定样式的字体加入的到我们的app 项目中。例如，我们这里只需要使用常规（regular）字体，那么我将 Nunito-Regular.ttf这个文件拖入到项目中即可。拖入时，注意勾选下面的选项： 然后在项目的Info配置选项的Custom iOS Target Properties中添加字体的配置项，如下： 接着就是使用我们添加的字体： 1.font(.custom(&quot;Nunito&quot;, size: 20)) 此时我们的字体效果就出现了。但是需要注意的一点就是，因为我们只添加了常规样式的字体到我们的 app 中，所以即使我们给文本添加了.fontWeight(.bold) 加粗的修饰器，文本依然只显示常规样式，除非我们把加粗的字体也添加到app 中。 展示 Markdown 格式的文本内容Markdown 是一种轻量级的标记语言，被开发者们广泛使用。在 SwiftUI 中，Text 也支持将这个标记语言编辑的文本格式化为我们常见的文本内容。例如， 1Text(&quot;**这是一段使用markdown编辑的加粗文本内容**。\\n 下面这是一个链接，如果使用模拟器运行点击后可以直接使用Safari浏览器打开。[Swift 博文](https://zhaofelix.github.io/swift-blogs)&quot;) 效果如下： 官方文档Text | Apple Developer Documentation","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"Text","slug":"Text","permalink":"https://swift.qingmaoedu.com/tags0/Text/"}]},{"title":"Swift 中的枚举","slug":"Swift-中的枚举","date":"2023-09-02T04:40:13.000Z","updated":"2023-09-02T04:45:26.869Z","comments":true,"path":"posts/251de72f.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/251de72f.html","excerpt":"Swift 中的枚举在计算机编程中，枚举是一种数据类型，用于定义一定范围内的有名称的值。Swift语言中的枚举是强大且灵活的工具，我们可以在多种场景中使用它们，包括但不限于处理特定类型的数据、创建自定义的错误类型以及实现特定的设计模式。 定义和基本用法在Swift中，我们使用enum关键字来定义枚举。下面是一个简单的例子，展示了如何定义和使用一个名为Weekday的枚举，表示一周中的每一天： 123456789enum Weekday &#123; case Monday case Tuesday case Wednesday case Thursday case Friday case Saturday case Sunday &#125;","text":"Swift 中的枚举在计算机编程中，枚举是一种数据类型，用于定义一定范围内的有名称的值。Swift语言中的枚举是强大且灵活的工具，我们可以在多种场景中使用它们，包括但不限于处理特定类型的数据、创建自定义的错误类型以及实现特定的设计模式。 定义和基本用法在Swift中，我们使用enum关键字来定义枚举。下面是一个简单的例子，展示了如何定义和使用一个名为Weekday的枚举，表示一周中的每一天： 123456789enum Weekday &#123; case Monday case Tuesday case Wednesday case Thursday case Friday case Saturday case Sunday &#125; 我们可以使用这个枚举来处理与一周中的某天相关的数据。例如，我们可以创建一个函数，根据给定的Weekday枚举值返回一周中的相应天数： 123456789101112131415161718func dayOfWeek(_ weekday: Weekday) -&gt; String &#123; switch weekday &#123; case .Monday: return &quot;Monday&quot; case .Tuesday: return &quot;Tuesday&quot; case .Wednesday: return &quot;Wednesday&quot; case .Thursday: return &quot;Thursday&quot; case .Friday: return &quot;Friday&quot; case .Saturday: return &quot;Saturday&quot; case .Sunday: return &quot;Sunday&quot; &#125; &#125; 然后我们可以像下面这样使用这个函数： 12let monday = Weekday.Monday print(dayOfWeek(monday)) // 输出：Monday 关联值Swift的枚举还可以定义关联值，这使得枚举能够更丰富地表达信息。例如，我们创建一个枚举表示用户的登录状态，并为其关联一个错误消息： 1234enum UserLoginStatus &#123; case success(String) case failure(String) &#125; 在这个例子中，UserLoginStatus枚举有两个cases：success和failure。这两个cases都关联了一个String类型的值，表示成功或失败的状态信息。我们可以像下面这样使用这个枚举： 1234let successfulLogin = UserLoginStatus.success(&quot;登录成功&quot;) let failedLogin = UserLoginStatus.failure(&quot;登录失败，请检查用户名和密码&quot;) print(successfulLogin) // 输出：登录成功 print(failedLogin) // 输出：登录失败，请检查用户名和密码 在switch语句中使用枚举由于Swift的枚举是全特性的，所以在switch语句中可以使用枚举的所有case值。这对于处理多种可能的枚举值非常有用： 1234567891011121314151617let someWeekday: Weekday = .Wednesday switch someWeekday &#123; case .Monday: print(&quot;今天是星期一&quot;) case .Tuesday: print(&quot;今天是星期二&quot;) case .Wednesday: print(&quot;今天是星期三&quot;) case .Thursday: print(&quot;今天是星期四&quot;) case .Friday: print(&quot;今天是星期五&quot;) case .Saturday: print(&quot;今天是星期六&quot;) case .Sunday: print(&quot;今天是星期日&quot;) &#125; 使用原始值和匿名枚举有时候，我们可能不需要为枚举的每个case关联一个特定的值，或者我们希望将所有值都关联到一个单一的原始值。在这种情况下，我们可以使用原始值和匿名枚举。例如： 123enum乏味的颜色: Int &#123; case red = 1, green = 2, blue = 3, yellow = 4, orange = 5, // 可以根据需要添加更多颜色&#125;","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://swift.qingmaoedu.com/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://swift.qingmaoedu.com/tags0/Swift/"},{"name":"枚举","slug":"枚举","permalink":"https://swift.qingmaoedu.com/tags0/%E6%9E%9A%E4%B8%BE/"}]},{"title":"Swift 中的结构体","slug":"Swift-中的结构体","date":"2023-08-30T01:18:01.000Z","updated":"2023-08-30T01:36:14.506Z","comments":true,"path":"posts/8745e5a7.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/8745e5a7.html","excerpt":"结构体的定义在Swift中，结构体是一种值类型，用于组合不同类型的值。它们可以被视为小型的数据模型，用于存储一组相关的数据。 结构体的主要特点 数据组合：结构体可以将不同类型的值组合在一起，形成一个有意义的数据结构。这使得结构体非常适合用于描述现实世界中的对象或数据模型。 封装：结构体可以将数据封装在一起，形成一个单一的、可操作的数据单元。这有助于隐藏内部实现细节，提高代码的可读性和可维护性。 代码复用：结构体可以通过定义公共的属性和方法，实现代码的复用。这可以在不同的代码片段中重复使用相同的结构体定义，提高代码的效率和可读性。 数据类型安全：结构体是类型安全的，这意味着在编译时可以检测到类型错误。这有助于减少运行时错误，提高代码的稳定性和安全性。","text":"结构体的定义在Swift中，结构体是一种值类型，用于组合不同类型的值。它们可以被视为小型的数据模型，用于存储一组相关的数据。 结构体的主要特点 数据组合：结构体可以将不同类型的值组合在一起，形成一个有意义的数据结构。这使得结构体非常适合用于描述现实世界中的对象或数据模型。 封装：结构体可以将数据封装在一起，形成一个单一的、可操作的数据单元。这有助于隐藏内部实现细节，提高代码的可读性和可维护性。 代码复用：结构体可以通过定义公共的属性和方法，实现代码的复用。这可以在不同的代码片段中重复使用相同的结构体定义，提高代码的效率和可读性。 数据类型安全：结构体是类型安全的，这意味着在编译时可以检测到类型错误。这有助于减少运行时错误，提高代码的稳定性和安全性。 此外，结构体还具有以下特点： 值类型：结构体是值类型，这意味着当我们将一个结构体赋值给一个变量或者作为函数的参数时，它会进行一次深复制。这意味着修改一个结构体的副本不会影响原始结构体。 语法简单：在Swift中定义结构体的语法非常简单。我们只需要使用struct关键字，后面跟着结构体的名称和定义它的变量和方法。 内存管理简单：由于结构体通常存储的是基本数据类型和其他结构体，因此它们的内存管理相对简单。这使得使用结构体比使用类更加高效，尤其是在处理大量数据时。 适用于小型对象：由于结构体的内存占用较小，因此它们更适合用于描述小型对象或数据模型。对于大型对象或需要复杂行为的数据类型，类可能是更好的选择。 定义一个结构体让我们通过一个示例来深入理解结构体的使用： 123456789struct Student &#123; var name: String var age: Int var grade: String mutating func updateAge(newAge: Int) &#123; age = newAge &#125;&#125; 在上面的示例中，我们定义了一个名为Student的结构体，它包含三个属性：name、age和grade，分别表示学生的姓名、年龄和年级。我们还定义了一个名为updateAge的方法，用于更新学生的年龄。 我们可以像下面这样创建一个Student实例并设置它的属性值： 1234567let student1 = Student(name: &quot;张三&quot;, age: 20, grade: &quot;大一&quot;)print(student1.name) // 输出 &quot;张三&quot;print(student1.age) // 输出 &quot;20&quot;print(student1.grade) // 输出 &quot;大一&quot;student1.updateAge(newAge: 21) // 更新学生年龄为21print(student1.age) // 输出 &quot;21&quot; 在上面的代码中，我们通过创建Student实例并设置它的属性值来描述一个学生对象。然后，我们使用updateAge方法来更新学生的年龄。请注意，由于updateAge方法修改了结构体的属性值，因此它被标记为mutating。这是因为在Swift中，非变异方法不能修改结构体的属性值。","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://swift.qingmaoedu.com/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://swift.qingmaoedu.com/tags0/Swift/"},{"name":"结构体","slug":"结构体","permalink":"https://swift.qingmaoedu.com/tags0/%E7%BB%93%E6%9E%84%E4%BD%93/"}]},{"title":"在SwiftUI 中创建一个内容切换效果","slug":"在SwiftUI-中创建一个内容切换效果","date":"2023-08-29T02:09:15.000Z","updated":"2023-09-08T02:16:43.825Z","comments":true,"path":"posts/d4605c9a.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/d4605c9a.html","excerpt":"文字内容切换效果界面布局： 12345678910111213141516171819struct ContentView: View &#123; @State private var text: Int = 0 var body: some View &#123; VStack(spacing: 20) &#123; Text(&quot;$\\(text)&quot;) .font(.largeTitle.bold()) .contentTransition(.numericText(value: Double(text))) Button &#123; withAnimation(.bouncy) &#123; text = .random(in: 100...10000) &#125; &#125; label: &#123; Text(&quot;Update&quot;) &#125; &#125; .padding() &#125;&#125; 效果如下：","text":"文字内容切换效果界面布局： 12345678910111213141516171819struct ContentView: View &#123; @State private var text: Int = 0 var body: some View &#123; VStack(spacing: 20) &#123; Text(&quot;$\\(text)&quot;) .font(.largeTitle.bold()) .contentTransition(.numericText(value: Double(text))) Button &#123; withAnimation(.bouncy) &#123; text = .random(in: 100...10000) &#125; &#125; label: &#123; Text(&quot;Update&quot;) &#125; &#125; .padding() &#125;&#125; 效果如下： 注意：contentTransition 修饰器的系统要求为： @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)。 SF Symbol 切换效果界面布局： 12345678910111213141516171819202122struct ContentView: View &#123; @State private var sfImage: String = &quot;house.fill&quot; @State private var sfCount: Int = 1 var body: some View &#123; VStack(spacing: 20) &#123; Image(systemName: sfImage) .font(.largeTitle.bold()) .contentTransition(.symbolEffect(.automatic)) Button &#123; let images:[String] = [&quot;suit.heart.fill&quot;, &quot;house.fill&quot;, &quot;gearshape&quot;, &quot;person.circle.fill&quot;, &quot;iphone&quot;, &quot;macbook&quot;] withAnimation(.bouncy) &#123; sfCount += 1 sfImage = images[sfCount % images.count] &#125; &#125; label: &#123; Text(&quot;Update&quot;) &#125; &#125; .padding() &#125;&#125; 效果如下： 注意： contentTransition 修饰器的系统要求为： @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *); symbolEffect 修饰器的系统要求为：@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)。","categories":[{"name":"SwiftUI 进阶","slug":"SwiftUI-进阶","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"动画","slug":"动画","permalink":"https://swift.qingmaoedu.com/tags0/%E5%8A%A8%E7%94%BB/"},{"name":"SF Symbol","slug":"SF-Symbol","permalink":"https://swift.qingmaoedu.com/tags0/SF-Symbol/"}]},{"title":"Swift 中的类","slug":"Swift-中的类","date":"2023-08-29T01:05:07.000Z","updated":"2023-08-29T01:41:58.559Z","comments":true,"path":"posts/338306b2.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/338306b2.html","excerpt":"在Swift中，类是一种引用类型，用于封装数据和方法。类是面向对象编程的基础，它们允许我们创建具有特定属性和方法的自定义数据类型。在这篇文章中，我们将详细介绍Swift中的类及其使用方法。 类的定义在Swift中，类使用class关键字定义。类的定义包括一个可选的名称、一对大括号&#123;&#125;，以及一个或多个属性和方法的定义。类的属性可以是值类型（例如Int、String等），也可以是引用类型（例如数组、字典等）。方法则包含在一个或多个大括号内，并遵循特定的语法规则。","text":"在Swift中，类是一种引用类型，用于封装数据和方法。类是面向对象编程的基础，它们允许我们创建具有特定属性和方法的自定义数据类型。在这篇文章中，我们将详细介绍Swift中的类及其使用方法。 类的定义在Swift中，类使用class关键字定义。类的定义包括一个可选的名称、一对大括号&#123;&#125;，以及一个或多个属性和方法的定义。类的属性可以是值类型（例如Int、String等），也可以是引用类型（例如数组、字典等）。方法则包含在一个或多个大括号内，并遵循特定的语法规则。 下面是一个简单的类定义示例： 12345678910111213class Person &#123; var name: String var age: Int init(name: String, age: Int) &#123; self.name = name self.age = age &#125; func sayHello() &#123; print(&quot;Hello, my name is \\(name) and I am \\(age) years old.&quot;) &#125;&#125; 在这个示例中，我们定义了一个名为Person的类，它有两个属性（name和age）和一个方法（sayHello）。init方法是一个特殊的方法，用于初始化类的实例。当创建一个新的Person实例时，我们需要提供一个名字和一个年龄，然后init方法会将这些值分别赋给name和age属性。 定义好一个类之后，我们可以实例化一个类的对象，然后通过点语法去访问类的属性和方法： 123var person = Person(name: &quot;Felix&quot;, age: 25)person.sayHello()person.age = 26 类的构造器和属性访问修饰符在Swift中，我们可以使用构造器来初始化类的实例。构造器是一个特殊的函数，它在创建类的实例时被调用。构造器的名称与类名相同，并且没有返回类型。我们可以在构造器中设置实例的属性值。 在上面的Person类中，我们使用了init方法作为构造器。当我们创建一个新的Person实例时，需要提供名字和年龄参数，如下所示： 1let person = Person(name: &quot;Alice&quot;, age: 30) 此外，我们还可以使用访问修饰符来控制属性和方法的访问权限。Swift提供了四种访问修饰符：public、protected、internal和默认（即不使用任何修饰符）。默认情况下，所有属性和方法都是公开的（可以在任何地方访问）。通过使用不同的访问修饰符，我们可以限制属性和方法的可见性，从而提高代码的安全性和可维护性。 例如，我们可以将上面的Person类修改为以下形式，将所有属性和方法设置为私有： 12345678910111213class Person &#123; private var name: String private var age: Int init(name: String, age: Int) &#123; self.name = name self.age = age &#125; internal func sayHello() &#123; print(&quot;Hello, my name is \\(name) and I am (age) years old.&quot;) &#125;&#125; 当我们再想通过实例化的对象访问 name 和 age 属性时，Xcode 会报以下的错误： &#39;age&#39; is inaccessible due to &#39;private&#39; protection level 类的继承和多态性在Swift中，类可以继承自其他类，从而实现代码的重用和扩展。子类可以继承父类的属性和方法，并可以根据需要添加新的属性和方法。此外，Swift还支持多态性，这意味着我们可以使用父类的引用来操作子类的对象。 下面是一个关于类继承的例子： 123456789101112131415class Student: Person &#123; // 子类独有的属性 var school: String init(name: String, age: Int, school: String) &#123; self.school = school super.init(name: name, age: age) &#125; // 子类独有的方法 func toSchool() &#123; print(&quot;Go to school&quot;) &#125;&#125; 在上面的这个例子中，我们定义了一个Student 子类，这个子类继承了Person 父类。这里的继承意味着Student 子类有父类的age 和name属性以及sayHello方法。 123var student = Student(name: &quot;Felix&quot;, age: 26, school: &quot;SBS&quot;)student.toSchool() // 调用字类方法student.sayHello() // 调用父类方法 在子类中，我们还可以重写父类的方法，使用 override 关键字： 1234 // 重写父类的方法override func sayHello() &#123; print(&quot;Hello, my name is\\(name) and I am \\(age) years old. my school is \\(school)&quot;)&#125;","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://swift.qingmaoedu.com/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://swift.qingmaoedu.com/tags0/Swift/"},{"name":"类","slug":"类","permalink":"https://swift.qingmaoedu.com/tags0/%E7%B1%BB/"}]},{"title":"Swift中的函数","slug":"Swift中的函数","date":"2023-08-28T02:30:24.000Z","updated":"2023-08-28T02:36:01.282Z","comments":true,"path":"posts/66bf2022.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/66bf2022.html","excerpt":"认识函数函数是一段独立的代码块，用来执行一些特定的操作。我们可以通过给函数一个名字来定义它的功能，当我们需要执行这段代码块的时候通过函数的名字来进行调用。 定义和调用函数定义函数使用关键字func,每个函数都需要有一个函数名，它描述函数执行的任务。下面我们定义一个函数名为sayHi的函数： 123func sayHi()&#123; print(&quot;你好&quot;)&#125; 调用函数： 1sayHi() 输出结果： 1你好","text":"认识函数函数是一段独立的代码块，用来执行一些特定的操作。我们可以通过给函数一个名字来定义它的功能，当我们需要执行这段代码块的时候通过函数的名字来进行调用。 定义和调用函数定义函数使用关键字func,每个函数都需要有一个函数名，它描述函数执行的任务。下面我们定义一个函数名为sayHi的函数： 123func sayHi()&#123; print(&quot;你好&quot;)&#125; 调用函数： 1sayHi() 输出结果： 1你好 带参数和返回值的函数在一些特定的情况下，我们需要给函数传入一些数据，传入的数据我们称之为参数。另外，我们也可能需要函数给我们返回一些代码块执行的结果，这就是返回值。 带参数的函数123func sayHi(name:String)&#123; print(&quot;你好，\\(name)&quot;)&#125; 在定义带参数的函数时，需要声明参数的数据类型，声明的方式类似于变量的声明，但是不需要加var关键字。 调用带参函数： 1sayHi(&quot;Felix&quot;) 注意，在调用函数的时候，传入的参数类型要和函数定义时的数据类型一致。上面的实例中参数的数据类型是String类型，所以函数调用是我们只能传入一个字符串。 带返回值的函数123func sayHi() -&gt; String &#123; return &quot;你好&quot;&#125; 定义带返回值的函数我们需要使用返回箭头-&gt;箭头后面跟的是返回值的数据类型。另外，在代码块执行结束后我们需要使用return关键字返回数据。 函数调用： 1let result = sayHi() 在调用带返回值的函数时，我们一般会把返回的结果赋给一个常量，以便之后使用。当然我们也可以直接使用print直接将结果打印。print(sayHi()) 同时带参数和返回值的函数123func sum(a:Int,b:Int) -&gt; Int&#123; return a + b&#125; 上面的实例中我们定义来一个求和函数来计算任何两个整数的值，并将求和后的结果返回。另外，这个函数定义了两个参数，所以函数调用的时候需要传入两个参数。 函数调用： 1print(sum(a: 100, b: 24)) 多返回值函数12345func calculate(a:Int,b:Int) -&gt; (sum:Int,sub:Int)&#123; let sum = a + b let sub = a - b return (sum,sub)&#125; 这是一个计算函数，我们分别计算传入的两个参数的和与差，然后将和与差返回。 函数调用： 123let result = calculate(a: 102, b: 23)print(&quot;两数之和为：\\(result.sum)&quot;)print(&quot;两数之差为：\\(result.sub)&quot;) 输出结果： 12两数之和为：125两数之差为：79 函数的实际参数标签和形式参数名每个函数的形式参数都包含实际参数标签和形式参数名。实际参数标签在函数调用的时候使用，形式参数名在函数的内部使用。默认情况下，Swift使用形式参数名作为实际参数标签，在上面所有的函数定义中，我们都没有特别声明实际参数标签。 12345func calculate(first a:Int, second b:Int) -&gt; (sum:Int,sub:Int)&#123; let sum = a + b let sub = a - b return (sum,sub)&#125; 在上面的实例中second和first就是实际参数标签，a和b就是形式参数名。 1let result = calculate(first: 102, second: 23) 我们注意到，我们在进行函数调用的时候使用的实际参数标签。使用实际参数标签可以帮助我们提高代码的可读性。 省略实际参数标签在某些情况下，我们可能想要在调用函数的时候省略实际参数标签，那么我们可以借助_通配符实现。 12345func calculate(_ a:Int, _ b:Int) -&gt; (sum:Int,sub:Int)&#123; let sum = a + b let sub = a - b return (sum,sub)&#125; 函数调用： 1let result = calculate(102, 23) 可以看到，在函数调用的时候我们已经可以不用写实际参数标签了。","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://swift.qingmaoedu.com/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://swift.qingmaoedu.com/tags0/Swift/"},{"name":"函数","slug":"函数","permalink":"https://swift.qingmaoedu.com/tags0/%E5%87%BD%E6%95%B0/"}]},{"title":"Swift 中的循环","slug":"Swift-中的循环","date":"2023-08-27T02:19:37.000Z","updated":"2023-08-28T02:36:26.435Z","comments":true,"path":"posts/73894dfa.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/73894dfa.html","excerpt":"Swift提供了多样化的控制流语句。包括while循环；for-in循环；if，guard和switch语句用来基于特定的条件执行不同的代码分支。","text":"Swift提供了多样化的控制流语句。包括while循环；for-in循环；if，guard和switch语句用来基于特定的条件执行不同的代码分支。 for-in 循环使用for-in循环来遍历数组，指定范围内的数字或者字符串中的字符。 1234let names = [&quot;Felix&quot;,&quot;Rudolf&quot;,&quot;Zora&quot;]for name in names &#123; print(&quot;你好，\\(name)！&quot;)&#125; 输出结果： 123你好，Felix！你好，Rudolf！你好，Zora！ 我们也可以使用for-in循环来遍历字典，遍历字典时我们可以同时遍历出字典中的键和值。 1234let persons = [&quot;Felix&quot;:23,&quot;Rudolf&quot;:34,&quot;Zora&quot;:33]for (name,age) in persons &#123; print(&quot;\\(name) 今年\\(age)岁！&quot;)&#125; 输出结果： 123Rudolf 今年34岁！Felix 今年23岁！Zora 今年33岁！ 循环打印出指定范围内的数字： 1234//循环打印出1到5的整数for i in 1...5&#123; print(i)&#125; 在上面的数字循环中我们通过区间运算符来辅助实现数字的循环。 另外，我们在循环时for后面跟着的是一个被隐式声明的常量，我们不再需要使用let关键字再次进行声明。 在某些情况下，当我们只需要指定循环的次数，并不需要用到隐式声明的常量时，我们可以使用通配符“_”来省略声明的常量。 123456//i自加5次var i = 0for _ in 0...5&#123; i += 1&#125;print(i) while循环while循环通过判断条件执行分支代码。当条件为true时，执行循环内的代码，否则不行。 12345let a = 1let b = 2while a &lt; b &#123; print(&quot;a小于b&quot;)&#125; 输出结果： 1a小于b repeat-whilerepeat-while是while循环的另一种形式，它相当与其他编程语言中的do-while循环，在判断循环条件之前它会先去执行一次循环代码块，然后重复循环直到判断条件为false。 123456let a = 1let b = 2repeat &#123; print(&quot;a小于b&quot;)&#125;while a &lt; b","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://swift.qingmaoedu.com/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://swift.qingmaoedu.com/tags0/Swift/"},{"name":"循环","slug":"循环","permalink":"https://swift.qingmaoedu.com/tags0/%E5%BE%AA%E7%8E%AF/"}]},{"title":"Swift中的条件语句","slug":"Swift中的条件语句","date":"2023-08-27T02:15:16.000Z","updated":"2023-08-28T02:36:42.584Z","comments":true,"path":"posts/964c101d.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/964c101d.html","excerpt":"Swift提供了if和switch两种条件语句，if语句用来判断简单的条件，switch语句适合复杂的条件。","text":"Swift提供了if和switch两种条件语句，if语句用来判断简单的条件，switch语句适合复杂的条件。 if语句当只有一个单一的条件时： 1234let a = 8if(a&lt;10)&#123; print(&quot;a小于10&quot;)&#125; if语句也提供else分句，当条件为false时使用： 1234567let a = 8if(a&lt;10)&#123; print(&quot;a小于10&quot;)&#125;else &#123; print(&quot;a大于或等于10&quot;)&#125; 当需要判断多个条件时，可以使用else-if配合if语句使用： 12345678910let a = 8if(a&lt;10)&#123; print(&quot;a小于10&quot;)&#125;else if(a&gt;10)&#123; print(&quot;a大于10&quot;)&#125;else &#123; print(&quot;等于10&quot;)&#125; switch语句每一个 switch 语句都由多个可能的情况组成，每一个情况都以 case 关键字开始。 123456789let A = &quot;a&quot;switch A &#123;case &quot;q&quot;: print(&quot;常量A等于字符串q&quot;)case &quot;a&quot;: print(&quot;常量A等于字符串a&quot;)default: print(&quot;其他字符&quot;)&#125; 输出结果： 1常量A等于字符串a switch语句要求仅可能的提供所有可能的值，但是当我们无法对所有可能的情况进行判断时，我们可以时关键字default进行标记，这表示其他没有提供的情况执行这部分的代码块。 多条件的匹配：123456789let A = &quot;b&quot;switch A &#123;case &quot;q&quot;: print(&quot;常量A等于字符串q&quot;)case &quot;a&quot;,&quot;b&quot;: print(&quot;常量A等于字符串a或b&quot;)default: print(&quot;其他字符&quot;)&#125; 在上面的代码中，我们在case后面添加了一个新的条件，条件之间使用逗号隔开。当常量A等于”a”或”b”时执行的结果都是： 1常量A等于字符串a或b 区间匹配：switch语句也可以配个区间运算符一起使用。 1234567891011let a = 23switch a &#123;case ..&lt;0: print(&quot;a小于0&quot;)case 0..&lt;10: print(&quot;a大于等于0小于10&quot;)case 10..&lt;100: print(&quot;a大于等于10小于100&quot;)default: print(&quot;a大于或等于100&quot;)&#125; 输出结果： 1a大于等于10小于100","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://swift.qingmaoedu.com/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://swift.qingmaoedu.com/tags0/Swift/"},{"name":"条件语句","slug":"条件语句","permalink":"https://swift.qingmaoedu.com/tags0/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/"}]},{"title":"SwiftUI之绘制自定义形状","slug":"SwiftUI之绘制自定义形状","date":"2023-08-27T01:55:29.000Z","updated":"2023-08-27T03:04:19.841Z","comments":true,"path":"posts/8c78197a.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/8c78197a.html","excerpt":"在之前一片文章中，我们介绍了 SwiftUI 中内置的一些图形形状。在一些特殊的工能需求下，我们需要自定义去绘制一些形状，例如五角星⭐️，多边形。 自定义路径在 SwiftUI 中可以使用 Shape协议自定义路径。 12345678// 自定义一个结构体，实现 Shape 协议struct DrawRectangleShape: Shape &#123; func path(in rect: CGRect) -&gt; Path &#123; var path = Path() path.addRect(rect) return path &#125;&#125; 在上面的代码中，我们自定义了一个实现 Shape 协议的结构体类型，在这个自定义的结构体中我们需要实现一个 path(in:)的协议方法，这个方法要求我们返回一个 Path对象，即我们要绘制的形状路径。","text":"在之前一片文章中，我们介绍了 SwiftUI 中内置的一些图形形状。在一些特殊的工能需求下，我们需要自定义去绘制一些形状，例如五角星⭐️，多边形。 自定义路径在 SwiftUI 中可以使用 Shape协议自定义路径。 12345678// 自定义一个结构体，实现 Shape 协议struct DrawRectangleShape: Shape &#123; func path(in rect: CGRect) -&gt; Path &#123; var path = Path() path.addRect(rect) return path &#125;&#125; 在上面的代码中，我们自定义了一个实现 Shape 协议的结构体类型，在这个自定义的结构体中我们需要实现一个 path(in:)的协议方法，这个方法要求我们返回一个 Path对象，即我们要绘制的形状路径。 在上面的这个例子中，我们直接将传进来的 rect 添加到绘制的路径中。具体表现为下面的代码绘制的是一个红色矩形： 123DrawRectangleShape() .fill(.red) .frame(width: 200, height: 200) 以及下面的代码绘制结果看起来像是一根红色的线，因为绘制的图像的形状高度为 1。 123DrawRectangleShape() .fill(.red) .frame(width: 200, height: 1)","categories":[{"name":"SwiftUI 进阶","slug":"SwiftUI-进阶","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"自定义形状","slug":"自定义形状","permalink":"https://swift.qingmaoedu.com/tags0/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BD%A2%E7%8A%B6/"}]},{"title":"SwiftUI之形状绘制","slug":"SwiftUI之形状绘制","date":"2023-08-25T04:45:27.000Z","updated":"2023-08-26T02:27:43.674Z","comments":true,"path":"posts/69def74.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/69def74.html","excerpt":"在 SwiftUI 中，可以使用内置的形状或者根据路径自定义形状。 SwiftUI 中内置的形状SwiftUI 中给我们提供了五种常用内置形状：矩形，圆角矩形，圆形，椭圆形和胶囊形状。","text":"在 SwiftUI 中，可以使用内置的形状或者根据路径自定义形状。 SwiftUI 中内置的形状SwiftUI 中给我们提供了五种常用内置形状：矩形，圆角矩形，圆形，椭圆形和胶囊形状。 矩形在 SwiftUI 中使用 Rectangle 类创建一个矩形。 123Rectangle() .fill(.gray) // 矩形填充的颜色 .frame(width: 100, height: 100) 圆角矩形在 SwiftUI 中使用 RoundedRectangle 类创建一个圆角矩形，不过它的初始化方法给我们提供了两个属性， cornerSize 和 cornerRadius 。通过配置这两个属性我们都可以创建一个圆角矩形。 12345678// 通过圆角尺寸创建圆角矩形RoundedRectangle(cornerSize: CGSize(width: 8, height: 8)) .fill(.red) .frame(width: 100, height: 100)// 通过圆角半径创建圆角矩形RoundedRectangle(cornerRadius: 8) .frame(width: 100, height: 100) 以上两中方式创建出来的圆角矩形形状是一样的。 胶囊形创建一个胶囊形状使用 Capsule 类。 123Capsule() .fill(.orange) .frame(width: 100, height: 60) 这里需要注意的一点是，当我们不添加 frame 修饰器时，默认情况下为一个圆形。胶囊的最终形状根据给frame 修饰器的width和height 两个属性决定。 椭圆形创建一个椭圆形状使用 Ellipse 类。 12Ellipse() .frame(width: 100, height: 60) 同样地，当 frame 修饰器中的width 和 height 两个属性值一样时，椭圆形状会变成一个圆形。 圆形创建一个圆形状使用 Circle 类。 12Circle() .frame(width: 100, height: 100) 官方文档Shapes | Apple Developer Documentation","categories":[{"name":"SwiftUI 进阶","slug":"SwiftUI-进阶","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"形状","slug":"形状","permalink":"https://swift.qingmaoedu.com/tags0/%E5%BD%A2%E7%8A%B6/"}]},{"title":"Swift 中的集合类型","slug":"Swift-中的集合类型","date":"2023-08-25T01:17:28.000Z","updated":"2023-08-26T02:33:04.965Z","comments":true,"path":"posts/5f278529.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/5f278529.html","excerpt":"Swift 语言提供 Arrays、Sets 和 Dictionaries 三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。 Swift 语言中的 Arrays、Sets 和 Dictionaries 中存储的数据值类型必须明确。这意味着我们不能把错误的数据类型插入其中。","text":"Swift 语言提供 Arrays、Sets 和 Dictionaries 三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。 Swift 语言中的 Arrays、Sets 和 Dictionaries 中存储的数据值类型必须明确。这意味着我们不能把错误的数据类型插入其中。 数组数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中，这意味着数组中的元素是可以重复的。 创建一个空数组12var someInts = [Int]()var someStr:[String] = [] 创建一个带有默认值的数组12var threeDouble = Array(repeating: 0.3, count: 3)print(threeDouble) 这里我们使用Array默认构造方法创建了一个长度大小为3，初始元素值为0.3的双精度类型的数组。参数说明： repeating:初始时元素的值 count：元素的个数或者数组的长度 此时，打印数组的显示如下： 1[0.3, 0.3, 0.3] 访问数组我们可以根据数组的索引来访问数组中的元素，不过需要注意的一点是数组的索引是从0开始的。 1234var nameArr = [&quot;Felix&quot;,&quot;Zhao&quot;,&quot;Rudolf&quot;]print(&quot;第一个元素\\(nameArr[0])&quot;)print(&quot;第二个元素\\(nameArr[1])&quot;)print(&quot;第三个元素\\(nameArr[1])&quot;) 修改数组添加数组元素我们可以使用append方法或者赋值运算符+=将一个元素添加到数组的末尾。 12nameArr.append(&quot;Wells&quot;)nameArr += [&quot;Wells&quot;] 此时的数组为： 1[&quot;Felix&quot;, &quot;Zhao&quot;, &quot;Rudolf&quot;, &quot;Wells&quot;, &quot;Wells&quot;] 循环遍历数组我们可以使用for-in循环来遍历数组中的每一个元素。 123for name in nameArr &#123; print(name)&#125; 如果我们同时需要每个元素的值和对应的索引，我们可以使用enumerate()方法来遍历数组。 123for (index,name) in nameArr.enumerated() &#123; print(&quot;当前索引:\\(index),当前值：\\(name)&quot;)&#125; 输出结果如下： 1234当前索引:0,当前值：Felix当前索引:1,当前值：Zhao当前索引:2,当前值：Rudolf当前索引:3,当前值：Wells 数组合并当我们有两个数据类型相同数组需要合并时，可以使用+运算符来合并数组。 123var nameArr = [&quot;Felix&quot;,&quot;Zhao&quot;,&quot;Rudolf&quot;]var newNameArr = [&quot;Lily&quot;]var newArr = newNameArr + nameArr 此时，newArr的元素为： 1[&quot;Lily&quot;, &quot;Felix&quot;, &quot;Zhao&quot;, &quot;Rudolf&quot;] 数组相关属性12print(nameArr.count) print(nameArr.isEmpty) .count用来获取数组元素的个数；.isEmpty判断数组是否为空，返回值为布尔值。 字典Swift中的字典是一个用来存储无序的相同类型数据的集合。字典中每个值(value)对应一个唯一的键(key)，键被作为值在这个字典里的标识符。字典里的数据是没有具体顺序的，我们只能通过值对应的键来访问到这个数据。另外，字典中的键可以是整型或者字符串类型，但是一个字典里键的类型必须是唯一的。 创建字典Swift中的字典使用Dictionary&lt;Key,Value&gt;的形式定义，其中Key是字典中键的数据类型，Value是字典中值的数据类型。我们使用这样形式来定义一个空的字典： 1var emptyDcit = Dictionary&lt;String,String&gt;() Swift中也给我们提供了一种简化的语法来定义字典： 1var emptyDcit = [String:String]() 两种方式都是定义了一个键和值都为字符串类型的空字典，在实际使用过程中，我们更多的是使用后面简化的定义方法。 在项目开发中，如果我们只需要定义一个字典，但是不需要对它进行初始化操作的话，我们可以使用下面的这中方法： 1var dic:[String:String]! 字典的访问与修改我们可以根据键来修改字典中对应的值，我们也可以使用一些内置的方法来添加、删除元素。 123var countryDic:[String:String] = [&quot;JP&quot;:&quot;日本&quot;,&quot;CN&quot;:&quot;中国&quot;,&quot;UK&quot;:&quot;英国&quot;,&quot;FR&quot;:&quot;法国&quot;]print(countryDic[&quot;CN&quot;])print(countryDic[&quot;JP&quot;]) 在上面的实例代码中，我们定义了一个键为国家英文缩写，值为国家的中文简写。我们分别使用键CN和JP访问字典。 当我们需要字典中添加一个新的元素时候，可以使用以下方法： 1countryDic[&quot;IN&quot;] = &quot;印度&quot; 我们需要修改字典中的某个元素的值，使用以下方法： 1countryDic[&quot;CN&quot;] = &quot;中华人民共和国&quot; 我们发现，我们添加新的元素和修改原有元素的值的方法是一样的。这是因为当我们通过键去修改字典的时候，会根据键名先去查询字典中是否包含对应的键名，如果包含的话就修改对应的值，如果不包含就添加新的元素。 经过上面的添加和修改之后，此时的字典元素如下： 1[&quot;UK&quot;: &quot;英国&quot;, &quot;JP&quot;: &quot;日本&quot;, &quot;FR&quot;: &quot;法国&quot;, &quot;CN&quot;: &quot;中华人民共和国&quot;, &quot;IN&quot;: &quot;印度&quot;] 我们经常会遇到根据键名去删除字典中对应的元素，这时，我们可以使用以下方法： 1countryDic.removeValue(forKey: &quot;CN&quot;) 我们经常会使用到的方法还有： 123let index = countryDic.index(countryDic.startIndex, offsetBy: 1)countryDic.remove(at: index) //根据指定的索引删除元素countryDic.removeAll() //清空字典 字典的遍历在之前的学习中，我们使用了for-in循环来遍历数组，同样的我们也可以使用for-in来遍历字典，不同的是遍历字典返回的是每个元素对应的键和值。 123for (key,value) in countryDic &#123; print(&quot;键：\\(key),值：\\(value)&quot;)&#125; 当然，我们也可以值循环遍历出字典的键或者值。 123456for key in countryDic.keys &#123; print(key)&#125;for value in countryDic.values &#123; print(value)&#125; 另外，在学习数组的时候，我们使用isEmpty属性来判断一个数组是否为空，我们同样可以使用这个方法来判断字典是否为空。 集合Swift 中的集合（Set）是一种无序的、不重复的数据结构，它允许你存储不同类型的元素。集合的主要用途是检查元素是否存在于集合中，因为集合中的元素是唯一的，所以当你尝试添加一个已经存在的元素时，集合不会发生变化。 创建一个集合创建集合的常见方法是使用字面量语法或者初始化器（initializer）。下面是一些关于如何创建和使用集合的示例： 使用字面量语法创建集合： 12let numbers = Set&lt;Int&gt;() // 创建一个空的整数集合let fruits = Set&lt;String&gt;(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;) // 创建一个包含三个字符串元素的集合 使用初始化器创建集合： 123var emptySet: Set&lt;Int&gt; = [] // 创建一个空的整数集合var fruitsSet = Set([&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]) // 创建一个包含三个字符串元素的集合var mixedSet: Set&lt;Any&gt; = [1, &quot;apple&quot;, 3.14] // 创建一个包含整数和浮点数的混合类型集合 集合中元素的访问、修改和删除向集合中添加新的元素使用insert 方法： 12numbers.insert(1) // 添加一个元素到集合中fruits.insert(&quot;grape&quot;) // 向集合中添加一个元素，如果元素已经存在，则不会改变集合 使用remove 方法移除集合中的元素： 12numbers.remove(1) // 从集合中移除一个元素，如果元素不存在，则不会改变集合fruits.remove(&quot;banana&quot;) // 从集合中移除一个元素，如果元素不存在，则不会改变集合 集合的遍历集合的遍历和数组的遍历类似，使用 for-in循环语句。 1234567for number in numbers &#123; print(number) // 输出集合中的每个元素&#125;for fruit in fruits &#123; print(fruit) // 输出集合中的每个元素&#125; 检查元素是否存在于集合中判断一个元素是否存在于集合中可以使用contains 方法。 12345if fruits.contains(&quot;apple&quot;) &#123; print(&quot;苹果存在于集合中&quot;) // 如果集合包含指定的元素，则输出相应的信息&#125; else &#123; print(&quot;苹果不存在于集合中&quot;) // 如果集合不包含指定的元素，则输出相应的信息&#125; 获取集合的大小获取集合的大小或元素的数量使用count 属性。 1let size = fruits.count // 获取集合中的元素个数 判断两个集合是否相等（即它们包含相同的元素）判断两个集合是否相等可以使用== 运算符。 123let setA = Set([&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;])let setB = Set([&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;])let isEqual = setA == setB // 判断两个集合是否相等，如果相等则返回 true，否则返回 false","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://swift.qingmaoedu.com/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Foundation","slug":"Foundation","permalink":"https://swift.qingmaoedu.com/tags0/Foundation/"},{"name":"Swift","slug":"Swift","permalink":"https://swift.qingmaoedu.com/tags0/Swift/"},{"name":"集合类型","slug":"集合类型","permalink":"https://swift.qingmaoedu.com/tags0/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/"},{"name":"数组","slug":"数组","permalink":"https://swift.qingmaoedu.com/tags0/%E6%95%B0%E7%BB%84/"},{"name":"集合","slug":"集合","permalink":"https://swift.qingmaoedu.com/tags0/%E9%9B%86%E5%90%88/"},{"name":"字典","slug":"字典","permalink":"https://swift.qingmaoedu.com/tags0/%E5%AD%97%E5%85%B8/"}]},{"title":"Swift 中的运算符","slug":"Swift-中的运算符","date":"2023-08-24T10:04:41.000Z","updated":"2023-08-26T02:33:04.962Z","comments":true,"path":"posts/c2a3f429.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/c2a3f429.html","excerpt":"Swift 中的运算符运算符是一个符号，用于告诉编译器执行一个数学或逻辑运算。 专门用语运算符包括一元、二元、三元： 一元运算符对一个目标进行操作，例如-a。 二元运算符对两个目标进行操作，例如a+b。 三元运算符操作三个目标，Swift语言有仅只有一个三元运算符（a ? b : c）。 Swift提供来以下几种运算符： 算术运算符 比较运算符 逻辑运算符 位运算符 赋值运算符 区间运算符 其他运算符","text":"Swift 中的运算符运算符是一个符号，用于告诉编译器执行一个数学或逻辑运算。 专门用语运算符包括一元、二元、三元： 一元运算符对一个目标进行操作，例如-a。 二元运算符对两个目标进行操作，例如a+b。 三元运算符操作三个目标，Swift语言有仅只有一个三元运算符（a ? b : c）。 Swift提供来以下几种运算符： 算术运算符 比较运算符 逻辑运算符 位运算符 赋值运算符 区间运算符 其他运算符 算术运算符Swift提供来四种标准的算术运算符： 加（+） 减（-） 乘（*） 除（&#x2F;） 12341 + 2 //equals 35 - 3 //equals 22 * 3 //equals 610 / 2 //equals 5 加法运算符同时支持String的拼接： 1&quot;Hello ,&quot; + &quot;World&quot; //equals &quot;Hello, World&quot; 比较运算符Swift支持所有C的所有标准比较运算符： 相等 （a &#x3D;&#x3D; b） 不像等（a !&#x3D; b） 大于（a &gt; b） 小于（a &lt; b） 大于等于（a &gt;&#x3D; b） 小于等于（a &lt;&#x3D; b） 每个比较运算符都会返回一个Bool来表示比较的结果是否为真： 1234561 == 2 //false2 != 3 //true2 &gt; 1 //true2 &lt; 1 //false 1 &gt;= 1 //true2 &lt;= 3 //true 注意：Swift同时也提供两个等价运算符（&#x3D;&#x3D;&#x3D; 和 !&#x3D;&#x3D; ）,你可以使用它们来判断两个对象的引用是否相同。 逻辑运算符逻辑运算符可以修改或者合并布尔逻辑值true和false。Swift提供 以下三种标准的逻辑运算符： 逻辑非 （ !a ）：对a的布尔值取反； 逻辑与 （ a&amp;&amp;b ）：若a和b均为true,则结果为true；若a和b中有一个或两个都为false，则结果为false。 逻辑或 （ a||b ）：若a和b其中一个为true，则结果为true。 12345var a:Bool = true var b:Bool = false!a //falsea&amp;&amp;b falsea||b true 位运算符位运算符用来对二位进制位进行操作，Swift提供以下几种位运算符： 取反（～） 按位与（&amp;） 按位或（|） 按位异或（^） p q p&amp;q p q p^q 0 1 0 1 1 1 0 0 0 0 0 0 赋值运算符赋值运算符（a &#x3D; b）可是初始化或者更新a的值为b: 123let b = 10var a = 5a = b //此时，a的值为10 除了简单的赋值运算符，Swift还提供了组合赋值运算符。 123456789let a = 10 let b = 10var c = 0c += a // c = c+ac -= a // c = c - ac *= a // c = c * ac /= a // c = c / ac %= a // c = c % a 区间运算符Swift包含了两个区间运算符，他们表示一个范围的值的便捷方式。 闭区间运算符（a…b）定义了从a到b的一组范围，并且包含了a和b。a的值不能大于b。123for i in 1...5&#123; print(i) //循环打印出1～5的整数，包括1和5&#125; 关于循环控制流的内容将在后续内容中出现。 半开区间运算符半开区间运算符（a..&lt;b）定义了从a到b但不包括b的区间。 123for i in 1...5&#123; print(i) //循环打印出1～4的整数,包括4，不包括5&#125; 单侧区间单侧区间主要用在数组的遍历。当我们需要遍历数组中的指定索引前或者后的元素时可以使用单侧区间。 12345678910111213//遍历数组items索引2后的所有元素for item in items[2...]&#123; print(item) &#125;//遍历数组items索引2前的所有元素for item in items[...2]&#123; print(item) &#125;//遍历数组items索引2前的所有元素,不包括索引2的元素for item in items[..&lt;2]&#123; print(item) &#125; 三元运算符三元条件运算符是一种有三部分的特殊运算符，它类似于 question ? answer1 : answer2。如果question为真，则会判断answer1并且返回它的值；否则它判断为answer2并且返回它的值。 123456if question &#123; answer1&#125;else &#123; answer2&#125;","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://swift.qingmaoedu.com/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://swift.qingmaoedu.com/tags0/Swift/"},{"name":"运算符","slug":"运算符","permalink":"https://swift.qingmaoedu.com/tags0/%E8%BF%90%E7%AE%97%E7%AC%A6/"}]},{"title":"Swift 中的数据类型","slug":"Swift-中的数据类型","date":"2023-08-24T01:11:27.000Z","updated":"2023-08-26T02:33:04.959Z","comments":true,"path":"posts/6876d7b8.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/6876d7b8.html","excerpt":"整数整数是没有小数部分的数字。整数可以是有符号的或者无符号。Swift提供来8，16，32和64位编码的有符号和无符号整数，例如UInt8表示8位无符号的整数，Int32表示32有符号整数。","text":"整数整数是没有小数部分的数字。整数可以是有符号的或者无符号。Swift提供来8，16，32和64位编码的有符号和无符号整数，例如UInt8表示8位无符号的整数，Int32表示32有符号整数。 IntSwift 提供了一个特殊的整数类型Int，长度与当前平台的原生字长相同： 在32位平台上，Int和Int32长度相同。 在64位平台上，Int和Int64长度相同。 1var age:Int = 27 除非你需要特定长度的整数，一般来说使用Int就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，Int可以存储的整数范围也可以达到-2,147,483,648~2,147,483,647，大多数时候这已经足够大了。 UIntSwift 也提供了一个特殊的无符号类型UInt，长度与当前平台的原生字长相同： 在32位平台上，UInt和UInt32长度相同。 在64位平台上，UInt和UInt64长度相同。 1var age:UInt = 29 如果此时重新赋一个负值， Xcode 将会报错。 1age = -27 错误信息如下：“Negative integer ‘-27’ overflows when stored into unsigned type ‘UInt’“。 注意只在的确需要存储一个和当前平台原生字长度相同的无符号整数的时候才使用 UInt 。其他情况下，推荐使用 Int ，即使已经知道存储的值都是非负的。如同类型安全和类型推断中描述的那样，统一使用 Int 会提高代码的兼容性，同时可以避免不同数字类型之间的转换问题，也符合整数的类型推断。 浮点数浮点数是有小数的数字，例如3.1425926。浮点类型相比整数类型来说能表示更大的范围的值，可以存储比Int更大或者更小的数字。Swift提供来两种有符号的浮点数类型： Double代表63位的浮点数 Float代表32位的浮点数 注意Double有至少15位数字的精度，而Float的精度只有6位。 12var floatPI: Float = 3.1415926535897932384626433832795028841971693993751058209var doublePI: Double = 3.1415926535897932384626433832795028841971693993751058209 显示结果如下： 123.1415933.141592653589793 布尔值Swift有一个基础布尔量类型，就是Bool，布尔量被作为逻辑值来引用，因为它的值只能是真或者假。Swift布尔量提供量两个常量值，true和false。 12var isLocked: Bool = true isLocked = false 字符串字符串是一系列字符，例如”Hello world”。字符串类型用String表示。 1var name:String = &quot;Felix&quot; 多行字符串： 1234var multiLineString = &quot;&quot;&quot;Hello,My name is Felix.&quot;&quot;&quot; 字符字符指的是单个字母。 1var c:Character = &quot;a&quot; 可选类型可选类型用来处理值可能确实的情况，可选类型表示有值或没有值。 数据范围 类型 大小（字节） 区间值 Int8 1字节 -128到127 UInt8 1字节 0到255 Int32 4字节 -2147483648 到 2147483647 UInt32 4字节 0 到 4294967295 Int64 8字节 -9223372036854775808 到 9223372036854775807 UInt64 8字节 0 到 18446744073709551615 Float 4字节 1.2E-38 到 3.4E+38 (~6 digits) Double 8字节 2.3E-308 到 1.7E+308 (~15 digits) 整数类型可以使用Int.max和Int.min获取Int的最大值和最小值。","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://swift.qingmaoedu.com/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Foundation","slug":"Foundation","permalink":"https://swift.qingmaoedu.com/tags0/Foundation/"},{"name":"Swift","slug":"Swift","permalink":"https://swift.qingmaoedu.com/tags0/Swift/"},{"name":"Xcode","slug":"Xcode","permalink":"https://swift.qingmaoedu.com/tags0/Xcode/"}]},{"title":"Swift 中的常量和变量","slug":"Swift-中的常量和变量","date":"2023-08-22T04:30:14.000Z","updated":"2023-08-26T02:33:04.953Z","comments":true,"path":"posts/c6460431.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/c6460431.html","excerpt":"常量 &amp; 变量常量一旦被设置就不能被更改，使用关键字let 。变量被设置之后是可以被修改的，使用关键字var。 声明常量和变量常量和变量之后在被声明后才能使用，声明方式如下： 12var num:Int = 8let x:Int = 10 这段代码的意思是： “声明一个名为num，数据类型为Int，值为8的变量。然后声明一个名为x，数据类型为Int，值为10的常量。” 你可以在一行中声明多个常量或变量，使用逗号隔开： 1var x:Int = 10,y:Int = 12,z:Int = 20","text":"常量 &amp; 变量常量一旦被设置就不能被更改，使用关键字let 。变量被设置之后是可以被修改的，使用关键字var。 声明常量和变量常量和变量之后在被声明后才能使用，声明方式如下： 12var num:Int = 8let x:Int = 10 这段代码的意思是： “声明一个名为num，数据类型为Int，值为8的变量。然后声明一个名为x，数据类型为Int，值为10的常量。” 你可以在一行中声明多个常量或变量，使用逗号隔开： 1var x:Int = 10,y:Int = 12,z:Int = 20 类型标注在上面常量与变量的声明中，我们标识的常量和变量数据类型均为Int类型。这意味着变量num和常量x在进行赋值时只能赋Int类型的数值。 上面的错误显示的是把一个字符串类型的10赋值给了一个指定类型为Int的常量，这在Swift中是不被允许的。 你可以在一行中定义多个相同类型的常量或者变量，只需要在结尾加上数据类型即可： 1var x,y,z:Int 类型安全与类型推断Swift是一门类型安全的语言。类型安全的语言可以让你清楚地知道代码可以处理的值的类型。如果你的一部分代码期望获得String类型的值，你就不能错误的传给它一个Int类型的值。 因为Swift是类型安全的语言，所以Swift在编译的过程中会进行类型检查，任何不匹配的类型都会被标记为错误。 类型检查可以帮助我们在对一个已经声明好的常量或者变量进行赋值时，能够准备无误的赋一个指定类型的数据。但是，类型检查并不意味着我们每次声明时都需要明确指定数据类型，我们可以通过Swift中的类型判断来完成数据类型的指定。 12var x = 10var y = 10.0 上面的代码中，我们并没有给变量指定数据类型。Swift在编译的过程中通过类型判断推断x为Int类型，y为Double类型。 常量与变量的命名常量和变量的命名几乎可以使用任何的字符，包括Unicode字符： 123var 你好 = &quot;你好&quot;var 😃 = &quot;😃&quot;var `let` = &quot;let&quot; 需要注意的是，在使用Swift中关键字进行命名是需要添加反引号（&#96;）。 虽然Swift在命名上可以使用很多字符，但是为了开发的方便与后期维护建议开发者在命名时尽量遵循一些标准化的命名规范，例如驼峰式命名法。","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://swift.qingmaoedu.com/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Foundation","slug":"Foundation","permalink":"https://swift.qingmaoedu.com/tags0/Foundation/"}]},{"title":"SwiftUI 介绍","slug":"SwiftUI-介绍","date":"2023-08-22T02:36:50.000Z","updated":"2023-08-26T02:33:04.968Z","comments":true,"path":"posts/96cb395e.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/96cb395e.html","excerpt":"SwiftUI 简介SwiftUI 是 Apple 在 2019 年 WWDC 推出的一种现代化的 UI 开发框架，它是 iOS 13 和 macOS Catalina 的一部分。SwiftUI 可以让用户更容易地创建美观且响应式的用户界面，并且与 Core Data、Realm 等数据存储解决方案集成得非常好。此外，SwiftUI 还在不断更新和完善，以满足开发者的需求。 SwiftUI 的特点声明式编程SwiftUI 采用了声明式编程的方式，与传统的命令式编程相比，这种方式让代码更加简洁易读。你只需要描述应用程序的界面应该如何显示，而不需要详细指定每一个视图的属性和方法。","text":"SwiftUI 简介SwiftUI 是 Apple 在 2019 年 WWDC 推出的一种现代化的 UI 开发框架，它是 iOS 13 和 macOS Catalina 的一部分。SwiftUI 可以让用户更容易地创建美观且响应式的用户界面，并且与 Core Data、Realm 等数据存储解决方案集成得非常好。此外，SwiftUI 还在不断更新和完善，以满足开发者的需求。 SwiftUI 的特点声明式编程SwiftUI 采用了声明式编程的方式，与传统的命令式编程相比，这种方式让代码更加简洁易读。你只需要描述应用程序的界面应该如何显示，而不需要详细指定每一个视图的属性和方法。 响应式布局SwiftUI 提供了强大的响应式布局能力，可以轻松地创建出适应不同设备和屏幕尺寸的应用程序。它支持线性布局、网格布局和灵活的布局组合，让你可以轻松地构建出复杂的界面。 内置动画和过渡SwiftUI 提供了丰富的内置动画和过渡效果，可以让你轻松地为应用程序添加生动的交互效果。这些动画和过渡效果与硬件加速相结合，可以让你的应用程序看起来更加流畅和自然。 与 Core Data 和 Realm 集成SwiftUI 可以很容易地与 Core Data 和 Realm 等数据存储解决方案集成。你可以在应用程序中方便地访问和操作数据，而无需手动处理繁琐的数据库操作。 开始使用 SwiftUI要开始使用 SwiftUI，你需要先安装 Xcode（macOS 10.15 及更高版本自带），然后创建一个新的 iOS 或 macOS 项目。在项目中，你可以直接使用默认的 ContentView 模板来开始编写 SwiftUI 代码。 下面是一个简单的 SwiftUI 示例： 123456789101112131415161718192021import SwiftUIstruct ContentView: View &#123; var body: some View &#123; VStack &#123; Text(&quot;Hello, SwiftUI!&quot;) .font(.largeTitle) .padding() Button(action: &#123; print(&quot;Button tapped!&quot;) &#125;) &#123; Text(&quot;Tap me!&quot;) .font(.title) .foregroundColor(.white) .padding() .background(Color.blue) .cornerRadius(10) &#125; &#125; &#125;&#125; 这个示例展示了一个简单的页面，包含一个标题和一个按钮。当用户点击按钮时，控制台会输出 “Button tapped!”。你可以根据自己的需求修改这个示例，或者尝试创建更复杂的界面。 总之，SwiftUI 是一种功能强大、易于使用的 UI 开发框架，它可以帮助你更高效地构建出美观且响应式的应用程序。如果你已经熟悉 Swift 语言，那么学习 SwiftUI 将会是一件非常愉快的事情。","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://swift.qingmaoedu.com/tags0/Swift/"},{"name":"Apple","slug":"Apple","permalink":"https://swift.qingmaoedu.com/tags0/Apple/"},{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"WWDC","slug":"WWDC","permalink":"https://swift.qingmaoedu.com/tags0/WWDC/"}]},{"title":"Swift 介绍","slug":"Swift-介绍","date":"2023-08-22T01:25:58.000Z","updated":"2023-08-26T02:33:04.967Z","comments":true,"path":"posts/ea0a67e1.html","link":"","permalink":"https://swift.qingmaoedu.com/posts/ea0a67e1.html","excerpt":"Swift 编程语言介绍Swift 是一种强大且直观的编程语言，由 Apple Inc. 开发，用于 iOS, macOS, watchOS 和 tvOS 的应用开发。Swift 结合了 C 和 Objective-C 的优点，并且支持函数式编程，面向对象编程和泛型编程。它的目标是提供一种安全、高效、灵活和现代化的编程语言，可以让开发者创造出更快、更稳定、更易用的应用程序。","text":"Swift 编程语言介绍Swift 是一种强大且直观的编程语言，由 Apple Inc. 开发，用于 iOS, macOS, watchOS 和 tvOS 的应用开发。Swift 结合了 C 和 Objective-C 的优点，并且支持函数式编程，面向对象编程和泛型编程。它的目标是提供一种安全、高效、灵活和现代化的编程语言，可以让开发者创造出更快、更稳定、更易用的应用程序。 特性安全性Swift 强调类型安全和内存管理。它不允许隐式转换到不安全的类型，这可以防止许多常见的编程错误。此外，Swift 使用自动引用计数（ARC）来管理内存，减少了内存泄露的可能性。 性能Swift 旨在提供高性能的应用程序。它的编译器进行了优化，以提高运行速度和减少能源消耗。Swift 的语法糖也有助于编写简洁且高效的代码。 易用性Swift 的语法清晰简洁，易于学习和使用。它的设计哲学是“简单就是美”，使得 Swift 代码既美观又易读。 开源Swift 是开源的，这意味着开发者可以查看和修改其源代码。这使得 Swift 成为一个活跃的社区项目，不断有新的功能和改进加入其中。 语言特性类型系统Swift 是一种静态类型语言，这意味着你在编写代码时必须为每个变量明确指定类型。这可以避免许多类型错误，并使得代码更加易于理解和维护。 面向对象编程Swift 完全支持面向对象编程，包括类、结构体、协议、继承和多态等概念。它也支持协议扩展，这使得你可以向现有类添加新的方法或者属性，而无需改变原有的代码。 函数式编程Swift 同时支持函数式编程和面向对象编程。你可以在函数中使用闭包，这为处理异步事件或者创建高阶函数提供了强大的工具。 PlaygroundsXcode 集成了一个强大的交互式编程环境——Playgrounds。你可以在 Playgrounds 中尝试 Swift 的各种特性，而无需创建完整的项目。 结论Swift 是一种强大、直观且安全的编程语言，它专注于提供最好的用户体验和性能。无论你是初学者还是有经验的开发者，Swift 都能帮助你更有效地编写代码。","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://swift.qingmaoedu.com/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://swift.qingmaoedu.com/tags0/Swift/"},{"name":"Apple","slug":"Apple","permalink":"https://swift.qingmaoedu.com/tags0/Apple/"}]}],"categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"},{"name":"SwiftUI 进阶","slug":"SwiftUI-进阶","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E8%BF%9B%E9%98%B6/"},{"name":"Xcode 使用技巧","slug":"Xcode-使用技巧","permalink":"https://swift.qingmaoedu.com/categories/Xcode-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"SwiftUI 技巧","slug":"SwiftUI-技巧","permalink":"https://swift.qingmaoedu.com/categories/SwiftUI-%E6%8A%80%E5%B7%A7/"},{"name":"使用SwiftUI创建一个待办清单","slug":"使用SwiftUI创建一个待办清单","permalink":"https://swift.qingmaoedu.com/categories/%E4%BD%BF%E7%94%A8SwiftUI%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95/"},{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://swift.qingmaoedu.com/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://swift.qingmaoedu.com/tags0/SwiftUI/"},{"name":"NavigationStack","slug":"NavigationStack","permalink":"https://swift.qingmaoedu.com/tags0/NavigationStack/"},{"name":"NavigationView","slug":"NavigationView","permalink":"https://swift.qingmaoedu.com/tags0/NavigationView/"},{"name":"List","slug":"List","permalink":"https://swift.qingmaoedu.com/tags0/List/"},{"name":"withAnimation","slug":"withAnimation","permalink":"https://swift.qingmaoedu.com/tags0/withAnimation/"},{"name":"Animation","slug":"Animation","permalink":"https://swift.qingmaoedu.com/tags0/Animation/"},{"name":"Xcode","slug":"Xcode","permalink":"https://swift.qingmaoedu.com/tags0/Xcode/"},{"name":"快捷键","slug":"快捷键","permalink":"https://swift.qingmaoedu.com/tags0/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"Shape","slug":"Shape","permalink":"https://swift.qingmaoedu.com/tags0/Shape/"},{"name":"Path","slug":"Path","permalink":"https://swift.qingmaoedu.com/tags0/Path/"},{"name":"Stroke","slug":"Stroke","permalink":"https://swift.qingmaoedu.com/tags0/Stroke/"},{"name":"State","slug":"State","permalink":"https://swift.qingmaoedu.com/tags0/State/"},{"name":"Binding","slug":"Binding","permalink":"https://swift.qingmaoedu.com/tags0/Binding/"},{"name":"Button","slug":"Button","permalink":"https://swift.qingmaoedu.com/tags0/Button/"},{"name":"Gradient","slug":"Gradient","permalink":"https://swift.qingmaoedu.com/tags0/Gradient/"},{"name":"Modifier","slug":"Modifier","permalink":"https://swift.qingmaoedu.com/tags0/Modifier/"},{"name":"Text","slug":"Text","permalink":"https://swift.qingmaoedu.com/tags0/Text/"},{"name":"Picker","slug":"Picker","permalink":"https://swift.qingmaoedu.com/tags0/Picker/"},{"name":"PhotosPicker","slug":"PhotosPicker","permalink":"https://swift.qingmaoedu.com/tags0/PhotosPicker/"},{"name":"ColorPicker","slug":"ColorPicker","permalink":"https://swift.qingmaoedu.com/tags0/ColorPicker/"},{"name":"DatePicker","slug":"DatePicker","permalink":"https://swift.qingmaoedu.com/tags0/DatePicker/"},{"name":"MultiDatePicker","slug":"MultiDatePicker","permalink":"https://swift.qingmaoedu.com/tags0/MultiDatePicker/"},{"name":"Range","slug":"Range","permalink":"https://swift.qingmaoedu.com/tags0/Range/"},{"name":"NavigationLink","slug":"NavigationLink","permalink":"https://swift.qingmaoedu.com/tags0/NavigationLink/"},{"name":"ScrollView","slug":"ScrollView","permalink":"https://swift.qingmaoedu.com/tags0/ScrollView/"},{"name":"ScrollViewReader","slug":"ScrollViewReader","permalink":"https://swift.qingmaoedu.com/tags0/ScrollViewReader/"},{"name":"EditButton","slug":"EditButton","permalink":"https://swift.qingmaoedu.com/tags0/EditButton/"},{"name":"Identifier","slug":"Identifier","permalink":"https://swift.qingmaoedu.com/tags0/Identifier/"},{"name":"TextField","slug":"TextField","permalink":"https://swift.qingmaoedu.com/tags0/TextField/"},{"name":"SecureField","slug":"SecureField","permalink":"https://swift.qingmaoedu.com/tags0/SecureField/"},{"name":"Label","slug":"Label","permalink":"https://swift.qingmaoedu.com/tags0/Label/"},{"name":"ForEach","slug":"ForEach","permalink":"https://swift.qingmaoedu.com/tags0/ForEach/"},{"name":"VStack","slug":"VStack","permalink":"https://swift.qingmaoedu.com/tags0/VStack/"},{"name":"HStack","slug":"HStack","permalink":"https://swift.qingmaoedu.com/tags0/HStack/"},{"name":"ZStack","slug":"ZStack","permalink":"https://swift.qingmaoedu.com/tags0/ZStack/"},{"name":"Image","slug":"Image","permalink":"https://swift.qingmaoedu.com/tags0/Image/"},{"name":"SF Symbols","slug":"SF-Symbols","permalink":"https://swift.qingmaoedu.com/tags0/SF-Symbols/"},{"name":"Overlay","slug":"Overlay","permalink":"https://swift.qingmaoedu.com/tags0/Overlay/"},{"name":"SignInWithAppleButton","slug":"SignInWithAppleButton","permalink":"https://swift.qingmaoedu.com/tags0/SignInWithAppleButton/"},{"name":"待办清单","slug":"待办清单","permalink":"https://swift.qingmaoedu.com/tags0/%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95/"},{"name":"Swift","slug":"Swift","permalink":"https://swift.qingmaoedu.com/tags0/Swift/"},{"name":"枚举","slug":"枚举","permalink":"https://swift.qingmaoedu.com/tags0/%E6%9E%9A%E4%B8%BE/"},{"name":"结构体","slug":"结构体","permalink":"https://swift.qingmaoedu.com/tags0/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"动画","slug":"动画","permalink":"https://swift.qingmaoedu.com/tags0/%E5%8A%A8%E7%94%BB/"},{"name":"SF Symbol","slug":"SF-Symbol","permalink":"https://swift.qingmaoedu.com/tags0/SF-Symbol/"},{"name":"类","slug":"类","permalink":"https://swift.qingmaoedu.com/tags0/%E7%B1%BB/"},{"name":"函数","slug":"函数","permalink":"https://swift.qingmaoedu.com/tags0/%E5%87%BD%E6%95%B0/"},{"name":"循环","slug":"循环","permalink":"https://swift.qingmaoedu.com/tags0/%E5%BE%AA%E7%8E%AF/"},{"name":"条件语句","slug":"条件语句","permalink":"https://swift.qingmaoedu.com/tags0/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/"},{"name":"自定义形状","slug":"自定义形状","permalink":"https://swift.qingmaoedu.com/tags0/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BD%A2%E7%8A%B6/"},{"name":"形状","slug":"形状","permalink":"https://swift.qingmaoedu.com/tags0/%E5%BD%A2%E7%8A%B6/"},{"name":"Foundation","slug":"Foundation","permalink":"https://swift.qingmaoedu.com/tags0/Foundation/"},{"name":"集合类型","slug":"集合类型","permalink":"https://swift.qingmaoedu.com/tags0/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/"},{"name":"数组","slug":"数组","permalink":"https://swift.qingmaoedu.com/tags0/%E6%95%B0%E7%BB%84/"},{"name":"集合","slug":"集合","permalink":"https://swift.qingmaoedu.com/tags0/%E9%9B%86%E5%90%88/"},{"name":"字典","slug":"字典","permalink":"https://swift.qingmaoedu.com/tags0/%E5%AD%97%E5%85%B8/"},{"name":"运算符","slug":"运算符","permalink":"https://swift.qingmaoedu.com/tags0/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"Apple","slug":"Apple","permalink":"https://swift.qingmaoedu.com/tags0/Apple/"},{"name":"WWDC","slug":"WWDC","permalink":"https://swift.qingmaoedu.com/tags0/WWDC/"}]}