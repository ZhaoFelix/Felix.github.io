{"meta":{"title":"Swift 博文","subtitle":"","description":"","author":"异思维","url":"https://zhaofelix.github.io/swift-blogs","root":"/swift-blogs/"},"pages":[{"title":"分类","date":"2023-08-20T08:04:52.000Z","updated":"2023-08-22T05:02:29.637Z","comments":true,"path":"categories/index.html","permalink":"https://zhaofelix.github.io/swift-blogs/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-08-20T08:00:37.000Z","updated":"2023-08-22T05:02:36.172Z","comments":true,"path":"tags/index.html","permalink":"https://zhaofelix.github.io/swift-blogs/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-08-20T08:05:12.000Z","updated":"2023-08-27T01:54:43.670Z","comments":true,"path":"about/index.html","permalink":"https://zhaofelix.github.io/swift-blogs/about/index.html","excerpt":"","text":"这是一个聚焦于 Swift 相关学习的博客!后续将逐步加入以下的相关知识模块： 一、Swift 基础语法 Swift 一种强大且易学的编程语言。 Swift 是一种强大直观的编程语言，适用于所有 Apple 平台。Swift 语法简洁但表现力强，更包含了深受喜爱的现代功能，可轻松上手使用。Swift 代码从设计上保证安全，并能开发出运行快如闪电的软件。 二、SwiftUI 基础 借助 SwiftUI，你可以利用 Swift 的强大功能打造适合各个 Apple 平台的精美 App，而无需编写大量代码。你只需使用一套工具和 API，就能在任何 Apple 设备上为所有人带来更加出色的体验。 三、Xcode 高效使用技巧 Xcode 15 让你能够开发、测试和分发适用于所有 Apple 平台的 App。借助增强的代码补齐功能、交互式预览和实时动画，更快地推进 App 的编码和设计。利用 Git 暂存功能直接改进下次要提交的文件，而不必离开代码界面。你还能借助重新设计的测试报告及其视频录制功能，探索并诊断测试结果，并着手从 Xcode Cloud 将你的 App 无缝部署到 TestFlight 和 App Store。打造出色的 App，从未如此简单。 四、ARKit 开发 AR 应用 ARKit 6 引入 4K 视频，助你拍摄出令人惊艳的高清 AR 体验视频 — 让专业视频编辑、影片制作、社交媒体 App 等更上一层楼。支持 HDR 视频和高清背景图像捕捉，扩展了视频和拍摄功能。ARKit 6 还为新的城市添加了位置锚点，如蒙特利尔、悉尼、新加坡和东京，并对动作捕捉进行了改进。 五、RealityKit 和 SwiftUI 开发 versionOS 应用 RealityKit 框架专门为增强现实量身定制，能够提供逼真的图像渲染、相机特效、动画、物理特效等等。借助原生的 Swift API、ARKit 整合、基于物理的超逼真渲染、变换和骨骼动画、空间音频和刚体物理，RealityKit 让你可以比以往更加快速轻松地进行 AR 开发。 可以借助 ARKit、 RealityKit 和 SwiftUI 在 Apple 全新的 versionOS 平台上开发全方位沉浸式的 AR 应用。 六、iOS 开发技巧"},{"title":"sitemap","date":"2023-08-20T08:05:42.000Z","updated":"2023-08-20T08:05:42.443Z","comments":true,"path":"sitemap/index.html","permalink":"https://zhaofelix.github.io/swift-blogs/sitemap/index.html","excerpt":"","text":""}],"posts":[{"title":"Swift 中的枚举","slug":"Swift-中的枚举","date":"2023-09-02T04:40:13.000Z","updated":"2023-09-02T04:45:26.869Z","comments":true,"path":"posts/251de72f.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/251de72f.html","excerpt":"Swift 中的枚举在计算机编程中，枚举是一种数据类型，用于定义一定范围内的有名称的值。Swift语言中的枚举是强大且灵活的工具，我们可以在多种场景中使用它们，包括但不限于处理特定类型的数据、创建自定义的错误类型以及实现特定的设计模式。 定义和基本用法在Swift中，我们使用enum关键字来定义枚举。下面是一个简单的例子，展示了如何定义和使用一个名为Weekday的枚举，表示一周中的每一天： 123456789enum Weekday &#123; case Monday case Tuesday case Wednesday case Thursday case Friday case Saturday case Sunday &#125;","text":"Swift 中的枚举在计算机编程中，枚举是一种数据类型，用于定义一定范围内的有名称的值。Swift语言中的枚举是强大且灵活的工具，我们可以在多种场景中使用它们，包括但不限于处理特定类型的数据、创建自定义的错误类型以及实现特定的设计模式。 定义和基本用法在Swift中，我们使用enum关键字来定义枚举。下面是一个简单的例子，展示了如何定义和使用一个名为Weekday的枚举，表示一周中的每一天： 123456789enum Weekday &#123; case Monday case Tuesday case Wednesday case Thursday case Friday case Saturday case Sunday &#125; 我们可以使用这个枚举来处理与一周中的某天相关的数据。例如，我们可以创建一个函数，根据给定的Weekday枚举值返回一周中的相应天数： 123456789101112131415161718func dayOfWeek(_ weekday: Weekday) -&gt; String &#123; switch weekday &#123; case .Monday: return &quot;Monday&quot; case .Tuesday: return &quot;Tuesday&quot; case .Wednesday: return &quot;Wednesday&quot; case .Thursday: return &quot;Thursday&quot; case .Friday: return &quot;Friday&quot; case .Saturday: return &quot;Saturday&quot; case .Sunday: return &quot;Sunday&quot; &#125; &#125; 然后我们可以像下面这样使用这个函数： 12let monday = Weekday.Monday print(dayOfWeek(monday)) // 输出：Monday 关联值Swift的枚举还可以定义关联值，这使得枚举能够更丰富地表达信息。例如，我们创建一个枚举表示用户的登录状态，并为其关联一个错误消息： 1234enum UserLoginStatus &#123; case success(String) case failure(String) &#125; 在这个例子中，UserLoginStatus枚举有两个cases：success和failure。这两个cases都关联了一个String类型的值，表示成功或失败的状态信息。我们可以像下面这样使用这个枚举： 1234let successfulLogin = UserLoginStatus.success(&quot;登录成功&quot;) let failedLogin = UserLoginStatus.failure(&quot;登录失败，请检查用户名和密码&quot;) print(successfulLogin) // 输出：登录成功 print(failedLogin) // 输出：登录失败，请检查用户名和密码 在switch语句中使用枚举由于Swift的枚举是全特性的，所以在switch语句中可以使用枚举的所有case值。这对于处理多种可能的枚举值非常有用： 1234567891011121314151617let someWeekday: Weekday = .Wednesday switch someWeekday &#123; case .Monday: print(&quot;今天是星期一&quot;) case .Tuesday: print(&quot;今天是星期二&quot;) case .Wednesday: print(&quot;今天是星期三&quot;) case .Thursday: print(&quot;今天是星期四&quot;) case .Friday: print(&quot;今天是星期五&quot;) case .Saturday: print(&quot;今天是星期六&quot;) case .Sunday: print(&quot;今天是星期日&quot;) &#125; 使用原始值和匿名枚举有时候，我们可能不需要为枚举的每个case关联一个特定的值，或者我们希望将所有值都关联到一个单一的原始值。在这种情况下，我们可以使用原始值和匿名枚举。例如： 123enum乏味的颜色: Int &#123; case red = 1, green = 2, blue = 3, yellow = 4, orange = 5, // 可以根据需要添加更多颜色&#125;","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://zhaofelix.github.io/swift-blogs/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Swift/"},{"name":"枚举","slug":"枚举","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E6%9E%9A%E4%B8%BE/"}]},{"title":"Swift 中的结构体","slug":"Swift-中的结构体","date":"2023-08-30T01:18:01.000Z","updated":"2023-08-30T01:36:14.506Z","comments":true,"path":"posts/8745e5a7.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/8745e5a7.html","excerpt":"结构体的定义在Swift中，结构体是一种值类型，用于组合不同类型的值。它们可以被视为小型的数据模型，用于存储一组相关的数据。 结构体的主要特点 数据组合：结构体可以将不同类型的值组合在一起，形成一个有意义的数据结构。这使得结构体非常适合用于描述现实世界中的对象或数据模型。 封装：结构体可以将数据封装在一起，形成一个单一的、可操作的数据单元。这有助于隐藏内部实现细节，提高代码的可读性和可维护性。 代码复用：结构体可以通过定义公共的属性和方法，实现代码的复用。这可以在不同的代码片段中重复使用相同的结构体定义，提高代码的效率和可读性。 数据类型安全：结构体是类型安全的，这意味着在编译时可以检测到类型错误。这有助于减少运行时错误，提高代码的稳定性和安全性。","text":"结构体的定义在Swift中，结构体是一种值类型，用于组合不同类型的值。它们可以被视为小型的数据模型，用于存储一组相关的数据。 结构体的主要特点 数据组合：结构体可以将不同类型的值组合在一起，形成一个有意义的数据结构。这使得结构体非常适合用于描述现实世界中的对象或数据模型。 封装：结构体可以将数据封装在一起，形成一个单一的、可操作的数据单元。这有助于隐藏内部实现细节，提高代码的可读性和可维护性。 代码复用：结构体可以通过定义公共的属性和方法，实现代码的复用。这可以在不同的代码片段中重复使用相同的结构体定义，提高代码的效率和可读性。 数据类型安全：结构体是类型安全的，这意味着在编译时可以检测到类型错误。这有助于减少运行时错误，提高代码的稳定性和安全性。 此外，结构体还具有以下特点： 值类型：结构体是值类型，这意味着当我们将一个结构体赋值给一个变量或者作为函数的参数时，它会进行一次深复制。这意味着修改一个结构体的副本不会影响原始结构体。 语法简单：在Swift中定义结构体的语法非常简单。我们只需要使用struct关键字，后面跟着结构体的名称和定义它的变量和方法。 内存管理简单：由于结构体通常存储的是基本数据类型和其他结构体，因此它们的内存管理相对简单。这使得使用结构体比使用类更加高效，尤其是在处理大量数据时。 适用于小型对象：由于结构体的内存占用较小，因此它们更适合用于描述小型对象或数据模型。对于大型对象或需要复杂行为的数据类型，类可能是更好的选择。 定义一个结构体让我们通过一个示例来深入理解结构体的使用： 123456789struct Student &#123; var name: String var age: Int var grade: String mutating func updateAge(newAge: Int) &#123; age = newAge &#125;&#125; 在上面的示例中，我们定义了一个名为Student的结构体，它包含三个属性：name、age和grade，分别表示学生的姓名、年龄和年级。我们还定义了一个名为updateAge的方法，用于更新学生的年龄。 我们可以像下面这样创建一个Student实例并设置它的属性值： 1234567let student1 = Student(name: &quot;张三&quot;, age: 20, grade: &quot;大一&quot;)print(student1.name) // 输出 &quot;张三&quot;print(student1.age) // 输出 &quot;20&quot;print(student1.grade) // 输出 &quot;大一&quot;student1.updateAge(newAge: 21) // 更新学生年龄为21print(student1.age) // 输出 &quot;21&quot; 在上面的代码中，我们通过创建Student实例并设置它的属性值来描述一个学生对象。然后，我们使用updateAge方法来更新学生的年龄。请注意，由于updateAge方法修改了结构体的属性值，因此它被标记为mutating。这是因为在Swift中，非变异方法不能修改结构体的属性值。","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://zhaofelix.github.io/swift-blogs/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Swift/"},{"name":"结构体","slug":"结构体","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E7%BB%93%E6%9E%84%E4%BD%93/"}]},{"title":"在SwiftUI 中创建一个内容切换效果","slug":"在SwiftUI-中创建一个内容切换效果","date":"2023-08-29T02:09:15.000Z","updated":"2023-08-29T02:44:50.608Z","comments":true,"path":"posts/d4605c9a.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/d4605c9a.html","excerpt":"文字内容切换效果界面布局： 12345678910111213141516171819struct ContentView: View &#123; @State private var text: Int = 0 var body: some View &#123; VStack(spacing: 20) &#123; Text(&quot;$\\(text)&quot;) .font(.largeTitle.bold()) .contentTransition(.numericText(value: Double(text))) Button &#123; withAnimation(.bouncy) &#123; text = .random(in: 100...10000) &#125; &#125; label: &#123; Text(&quot;Update&quot;) &#125; &#125; .padding() &#125;&#125; 效果如下：","text":"文字内容切换效果界面布局： 12345678910111213141516171819struct ContentView: View &#123; @State private var text: Int = 0 var body: some View &#123; VStack(spacing: 20) &#123; Text(&quot;$\\(text)&quot;) .font(.largeTitle.bold()) .contentTransition(.numericText(value: Double(text))) Button &#123; withAnimation(.bouncy) &#123; text = .random(in: 100...10000) &#125; &#125; label: &#123; Text(&quot;Update&quot;) &#125; &#125; .padding() &#125;&#125; 效果如下： 注意：contentTransition 修饰器的系统要求为： @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)。 SFSymbol 切换效果界面布局： 12345678910111213141516171819202122struct ContentView: View &#123; @State private var sfImage: String = &quot;house.fill&quot; @State private var sfCount: Int = 1 var body: some View &#123; VStack(spacing: 20) &#123; Image(systemName: sfImage) .font(.largeTitle.bold()) .contentTransition(.symbolEffect(.automatic)) Button &#123; let images:[String] = [&quot;suit.heart.fill&quot;, &quot;house.fill&quot;, &quot;gearshape&quot;, &quot;person.circle.fill&quot;, &quot;iphone&quot;, &quot;macbook&quot;] withAnimation(.bouncy) &#123; sfCount += 1 sfImage = images[sfCount % images.count] &#125; &#125; label: &#123; Text(&quot;Update&quot;) &#125; &#125; .padding() &#125;&#125; 效果如下： 注意： contentTransition 修饰器的系统要求为： @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *); symbolEffect 修饰器的系统要求为：@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)。","categories":[{"name":"SwiftUI 进阶","slug":"SwiftUI-进阶","permalink":"https://zhaofelix.github.io/swift-blogs/categories/SwiftUI-%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/SwiftUI/"},{"name":"动画","slug":"动画","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E5%8A%A8%E7%94%BB/"},{"name":"SFSymbol","slug":"SFSymbol","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/SFSymbol/"}]},{"title":"Swift 中的类","slug":"Swift-中的类","date":"2023-08-29T01:05:07.000Z","updated":"2023-08-29T01:41:58.559Z","comments":true,"path":"posts/338306b2.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/338306b2.html","excerpt":"在Swift中，类是一种引用类型，用于封装数据和方法。类是面向对象编程的基础，它们允许我们创建具有特定属性和方法的自定义数据类型。在这篇文章中，我们将详细介绍Swift中的类及其使用方法。 类的定义在Swift中，类使用class关键字定义。类的定义包括一个可选的名称、一对大括号&#123;&#125;，以及一个或多个属性和方法的定义。类的属性可以是值类型（例如Int、String等），也可以是引用类型（例如数组、字典等）。方法则包含在一个或多个大括号内，并遵循特定的语法规则。","text":"在Swift中，类是一种引用类型，用于封装数据和方法。类是面向对象编程的基础，它们允许我们创建具有特定属性和方法的自定义数据类型。在这篇文章中，我们将详细介绍Swift中的类及其使用方法。 类的定义在Swift中，类使用class关键字定义。类的定义包括一个可选的名称、一对大括号&#123;&#125;，以及一个或多个属性和方法的定义。类的属性可以是值类型（例如Int、String等），也可以是引用类型（例如数组、字典等）。方法则包含在一个或多个大括号内，并遵循特定的语法规则。 下面是一个简单的类定义示例： 12345678910111213class Person &#123; var name: String var age: Int init(name: String, age: Int) &#123; self.name = name self.age = age &#125; func sayHello() &#123; print(&quot;Hello, my name is \\(name) and I am \\(age) years old.&quot;) &#125;&#125; 在这个示例中，我们定义了一个名为Person的类，它有两个属性（name和age）和一个方法（sayHello）。init方法是一个特殊的方法，用于初始化类的实例。当创建一个新的Person实例时，我们需要提供一个名字和一个年龄，然后init方法会将这些值分别赋给name和age属性。 定义好一个类之后，我们可以实例化一个类的对象，然后通过点语法去访问类的属性和方法： 123var person = Person(name: &quot;Felix&quot;, age: 25)person.sayHello()person.age = 26 类的构造器和属性访问修饰符在Swift中，我们可以使用构造器来初始化类的实例。构造器是一个特殊的函数，它在创建类的实例时被调用。构造器的名称与类名相同，并且没有返回类型。我们可以在构造器中设置实例的属性值。 在上面的Person类中，我们使用了init方法作为构造器。当我们创建一个新的Person实例时，需要提供名字和年龄参数，如下所示： 1let person = Person(name: &quot;Alice&quot;, age: 30) 此外，我们还可以使用访问修饰符来控制属性和方法的访问权限。Swift提供了四种访问修饰符：public、protected、internal和默认（即不使用任何修饰符）。默认情况下，所有属性和方法都是公开的（可以在任何地方访问）。通过使用不同的访问修饰符，我们可以限制属性和方法的可见性，从而提高代码的安全性和可维护性。 例如，我们可以将上面的Person类修改为以下形式，将所有属性和方法设置为私有： 12345678910111213class Person &#123; private var name: String private var age: Int init(name: String, age: Int) &#123; self.name = name self.age = age &#125; internal func sayHello() &#123; print(&quot;Hello, my name is \\(name) and I am (age) years old.&quot;) &#125;&#125; 当我们再想通过实例化的对象访问 name 和 age 属性时，Xcode 会报以下的错误： &#39;age&#39; is inaccessible due to &#39;private&#39; protection level 类的继承和多态性在Swift中，类可以继承自其他类，从而实现代码的重用和扩展。子类可以继承父类的属性和方法，并可以根据需要添加新的属性和方法。此外，Swift还支持多态性，这意味着我们可以使用父类的引用来操作子类的对象。 下面是一个关于类继承的例子： 123456789101112131415class Student: Person &#123; // 子类独有的属性 var school: String init(name: String, age: Int, school: String) &#123; self.school = school super.init(name: name, age: age) &#125; // 子类独有的方法 func toSchool() &#123; print(&quot;Go to school&quot;) &#125;&#125; 在上面的这个例子中，我们定义了一个Student 子类，这个子类继承了Person 父类。这里的继承意味着Student 子类有父类的age 和name属性以及sayHello方法。 123var student = Student(name: &quot;Felix&quot;, age: 26, school: &quot;SBS&quot;)student.toSchool() // 调用字类方法student.sayHello() // 调用父类方法 在子类中，我们还可以重写父类的方法，使用 override 关键字： 1234 // 重写父类的方法override func sayHello() &#123; print(&quot;Hello, my name is\\(name) and I am \\(age) years old. my school is \\(school)&quot;)&#125;","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://zhaofelix.github.io/swift-blogs/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Swift/"},{"name":"类","slug":"类","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E7%B1%BB/"}]},{"title":"Swift中的函数","slug":"Swift中的函数","date":"2023-08-28T02:30:24.000Z","updated":"2023-08-28T02:36:01.282Z","comments":true,"path":"posts/66bf2022.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/66bf2022.html","excerpt":"认识函数函数是一段独立的代码块，用来执行一些特定的操作。我们可以通过给函数一个名字来定义它的功能，当我们需要执行这段代码块的时候通过函数的名字来进行调用。 定义和调用函数定义函数使用关键字func,每个函数都需要有一个函数名，它描述函数执行的任务。下面我们定义一个函数名为sayHi的函数： 123func sayHi()&#123; print(&quot;你好&quot;)&#125; 调用函数： 1sayHi() 输出结果： 1你好","text":"认识函数函数是一段独立的代码块，用来执行一些特定的操作。我们可以通过给函数一个名字来定义它的功能，当我们需要执行这段代码块的时候通过函数的名字来进行调用。 定义和调用函数定义函数使用关键字func,每个函数都需要有一个函数名，它描述函数执行的任务。下面我们定义一个函数名为sayHi的函数： 123func sayHi()&#123; print(&quot;你好&quot;)&#125; 调用函数： 1sayHi() 输出结果： 1你好 带参数和返回值的函数在一些特定的情况下，我们需要给函数传入一些数据，传入的数据我们称之为参数。另外，我们也可能需要函数给我们返回一些代码块执行的结果，这就是返回值。 带参数的函数123func sayHi(name:String)&#123; print(&quot;你好，\\(name)&quot;)&#125; 在定义带参数的函数时，需要声明参数的数据类型，声明的方式类似于变量的声明，但是不需要加var关键字。 调用带参函数： 1sayHi(&quot;Felix&quot;) 注意，在调用函数的时候，传入的参数类型要和函数定义时的数据类型一致。上面的实例中参数的数据类型是String类型，所以函数调用是我们只能传入一个字符串。 带返回值的函数123func sayHi() -&gt; String &#123; return &quot;你好&quot;&#125; 定义带返回值的函数我们需要使用返回箭头-&gt;箭头后面跟的是返回值的数据类型。另外，在代码块执行结束后我们需要使用return关键字返回数据。 函数调用： 1let result = sayHi() 在调用带返回值的函数时，我们一般会把返回的结果赋给一个常量，以便之后使用。当然我们也可以直接使用print直接将结果打印。print(sayHi()) 同时带参数和返回值的函数123func sum(a:Int,b:Int) -&gt; Int&#123; return a + b&#125; 上面的实例中我们定义来一个求和函数来计算任何两个整数的值，并将求和后的结果返回。另外，这个函数定义了两个参数，所以函数调用的时候需要传入两个参数。 函数调用： 1print(sum(a: 100, b: 24)) 多返回值函数12345func calculate(a:Int,b:Int) -&gt; (sum:Int,sub:Int)&#123; let sum = a + b let sub = a - b return (sum,sub)&#125; 这是一个计算函数，我们分别计算传入的两个参数的和与差，然后将和与差返回。 函数调用： 123let result = calculate(a: 102, b: 23)print(&quot;两数之和为：\\(result.sum)&quot;)print(&quot;两数之差为：\\(result.sub)&quot;) 输出结果： 12两数之和为：125两数之差为：79 函数的实际参数标签和形式参数名每个函数的形式参数都包含实际参数标签和形式参数名。实际参数标签在函数调用的时候使用，形式参数名在函数的内部使用。默认情况下，Swift使用形式参数名作为实际参数标签，在上面所有的函数定义中，我们都没有特别声明实际参数标签。 12345func calculate(first a:Int, second b:Int) -&gt; (sum:Int,sub:Int)&#123; let sum = a + b let sub = a - b return (sum,sub)&#125; 在上面的实例中second和first就是实际参数标签，a和b就是形式参数名。 1let result = calculate(first: 102, second: 23) 我们注意到，我们在进行函数调用的时候使用的实际参数标签。使用实际参数标签可以帮助我们提高代码的可读性。 省略实际参数标签在某些情况下，我们可能想要在调用函数的时候省略实际参数标签，那么我们可以借助_通配符实现。 12345func calculate(_ a:Int, _ b:Int) -&gt; (sum:Int,sub:Int)&#123; let sum = a + b let sub = a - b return (sum,sub)&#125; 函数调用： 1let result = calculate(102, 23) 可以看到，在函数调用的时候我们已经可以不用写实际参数标签了。","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://zhaofelix.github.io/swift-blogs/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Swift/"},{"name":"函数","slug":"函数","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E5%87%BD%E6%95%B0/"}]},{"title":"Swift 中的循环","slug":"Swift-中的循环","date":"2023-08-27T02:19:37.000Z","updated":"2023-08-28T02:36:26.435Z","comments":true,"path":"posts/73894dfa.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/73894dfa.html","excerpt":"Swift提供了多样化的控制流语句。包括while循环；for-in循环；if，guard和switch语句用来基于特定的条件执行不同的代码分支。","text":"Swift提供了多样化的控制流语句。包括while循环；for-in循环；if，guard和switch语句用来基于特定的条件执行不同的代码分支。 for-in 循环使用for-in循环来遍历数组，指定范围内的数字或者字符串中的字符。 1234let names = [&quot;Felix&quot;,&quot;Rudolf&quot;,&quot;Zora&quot;]for name in names &#123; print(&quot;你好，\\(name)！&quot;)&#125; 输出结果： 123你好，Felix！你好，Rudolf！你好，Zora！ 我们也可以使用for-in循环来遍历字典，遍历字典时我们可以同时遍历出字典中的键和值。 1234let persons = [&quot;Felix&quot;:23,&quot;Rudolf&quot;:34,&quot;Zora&quot;:33]for (name,age) in persons &#123; print(&quot;\\(name) 今年\\(age)岁！&quot;)&#125; 输出结果： 123Rudolf 今年34岁！Felix 今年23岁！Zora 今年33岁！ 循环打印出指定范围内的数字： 1234//循环打印出1到5的整数for i in 1...5&#123; print(i)&#125; 在上面的数字循环中我们通过区间运算符来辅助实现数字的循环。 另外，我们在循环时for后面跟着的是一个被隐式声明的常量，我们不再需要使用let关键字再次进行声明。 在某些情况下，当我们只需要指定循环的次数，并不需要用到隐式声明的常量时，我们可以使用通配符“_”来省略声明的常量。 123456//i自加5次var i = 0for _ in 0...5&#123; i += 1&#125;print(i) while循环while循环通过判断条件执行分支代码。当条件为true时，执行循环内的代码，否则不行。 12345let a = 1let b = 2while a &lt; b &#123; print(&quot;a小于b&quot;)&#125; 输出结果： 1a小于b repeat-whilerepeat-while是while循环的另一种形式，它相当与其他编程语言中的do-while循环，在判断循环条件之前它会先去执行一次循环代码块，然后重复循环直到判断条件为false。 123456let a = 1let b = 2repeat &#123; print(&quot;a小于b&quot;)&#125;while a &lt; b","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://zhaofelix.github.io/swift-blogs/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Swift/"},{"name":"循环","slug":"循环","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E5%BE%AA%E7%8E%AF/"}]},{"title":"Swift中的条件语句","slug":"Swift中的条件语句","date":"2023-08-27T02:15:16.000Z","updated":"2023-08-28T02:36:42.584Z","comments":true,"path":"posts/964c101d.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/964c101d.html","excerpt":"Swift提供了if和switch两种条件语句，if语句用来判断简单的条件，switch语句适合复杂的条件。","text":"Swift提供了if和switch两种条件语句，if语句用来判断简单的条件，switch语句适合复杂的条件。 if语句当只有一个单一的条件时： 1234let a = 8if(a&lt;10)&#123; print(&quot;a小于10&quot;)&#125; if语句也提供else分句，当条件为false时使用： 1234567let a = 8if(a&lt;10)&#123; print(&quot;a小于10&quot;)&#125;else &#123; print(&quot;a大于或等于10&quot;)&#125; 当需要判断多个条件时，可以使用else-if配合if语句使用： 12345678910let a = 8if(a&lt;10)&#123; print(&quot;a小于10&quot;)&#125;else if(a&gt;10)&#123; print(&quot;a大于10&quot;)&#125;else &#123; print(&quot;等于10&quot;)&#125; switch语句每一个 switch 语句都由多个可能的情况组成，每一个情况都以 case 关键字开始。 123456789let A = &quot;a&quot;switch A &#123;case &quot;q&quot;: print(&quot;常量A等于字符串q&quot;)case &quot;a&quot;: print(&quot;常量A等于字符串a&quot;)default: print(&quot;其他字符&quot;)&#125; 输出结果： 1常量A等于字符串a switch语句要求仅可能的提供所有可能的值，但是当我们无法对所有可能的情况进行判断时，我们可以时关键字default进行标记，这表示其他没有提供的情况执行这部分的代码块。 多条件的匹配：123456789let A = &quot;b&quot;switch A &#123;case &quot;q&quot;: print(&quot;常量A等于字符串q&quot;)case &quot;a&quot;,&quot;b&quot;: print(&quot;常量A等于字符串a或b&quot;)default: print(&quot;其他字符&quot;)&#125; 在上面的代码中，我们在case后面添加了一个新的条件，条件之间使用逗号隔开。当常量A等于”a”或”b”时执行的结果都是： 1常量A等于字符串a或b 区间匹配：switch语句也可以配个区间运算符一起使用。 1234567891011let a = 23switch a &#123;case ..&lt;0: print(&quot;a小于0&quot;)case 0..&lt;10: print(&quot;a大于等于0小于10&quot;)case 10..&lt;100: print(&quot;a大于等于10小于100&quot;)default: print(&quot;a大于或等于100&quot;)&#125; 输出结果： 1a大于等于10小于100","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://zhaofelix.github.io/swift-blogs/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Swift/"},{"name":"条件语句","slug":"条件语句","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/"}]},{"title":"SwiftUI之绘制自定义形状","slug":"SwiftUI之绘制自定义形状","date":"2023-08-27T01:55:29.000Z","updated":"2023-08-27T03:04:19.841Z","comments":true,"path":"posts/8c78197a.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/8c78197a.html","excerpt":"在之前一片文章中，我们介绍了 SwiftUI 中内置的一些图形形状。在一些特殊的工能需求下，我们需要自定义去绘制一些形状，例如五角星⭐️，多边形。 自定义路径在 SwiftUI 中可以使用 Shape协议自定义路径。 12345678// 自定义一个结构体，实现 Shape 协议struct DrawRectangleShape: Shape &#123; func path(in rect: CGRect) -&gt; Path &#123; var path = Path() path.addRect(rect) return path &#125;&#125; 在上面的代码中，我们自定义了一个实现 Shape 协议的结构体类型，在这个自定义的结构体中我们需要实现一个 path(in:)的协议方法，这个方法要求我们返回一个 Path对象，即我们要绘制的形状路径。","text":"在之前一片文章中，我们介绍了 SwiftUI 中内置的一些图形形状。在一些特殊的工能需求下，我们需要自定义去绘制一些形状，例如五角星⭐️，多边形。 自定义路径在 SwiftUI 中可以使用 Shape协议自定义路径。 12345678// 自定义一个结构体，实现 Shape 协议struct DrawRectangleShape: Shape &#123; func path(in rect: CGRect) -&gt; Path &#123; var path = Path() path.addRect(rect) return path &#125;&#125; 在上面的代码中，我们自定义了一个实现 Shape 协议的结构体类型，在这个自定义的结构体中我们需要实现一个 path(in:)的协议方法，这个方法要求我们返回一个 Path对象，即我们要绘制的形状路径。 在上面的这个例子中，我们直接将传进来的 rect 添加到绘制的路径中。具体表现为下面的代码绘制的是一个红色矩形： 123DrawRectangleShape() .fill(.red) .frame(width: 200, height: 200) 以及下面的代码绘制结果看起来像是一根红色的线，因为绘制的图像的形状高度为 1。 123DrawRectangleShape() .fill(.red) .frame(width: 200, height: 1)","categories":[{"name":"SwiftUI 进阶","slug":"SwiftUI-进阶","permalink":"https://zhaofelix.github.io/swift-blogs/categories/SwiftUI-%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/SwiftUI/"},{"name":"自定义形状","slug":"自定义形状","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BD%A2%E7%8A%B6/"}]},{"title":"SwiftUI之形状绘制","slug":"SwiftUI之形状绘制","date":"2023-08-25T04:45:27.000Z","updated":"2023-08-26T02:27:43.674Z","comments":true,"path":"posts/69def74.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/69def74.html","excerpt":"在 SwiftUI 中，可以使用内置的形状或者根据路径自定义形状。 SwiftUI 中内置的形状SwiftUI 中给我们提供了五种常用内置形状：矩形，圆角矩形，圆形，椭圆形和胶囊形状。","text":"在 SwiftUI 中，可以使用内置的形状或者根据路径自定义形状。 SwiftUI 中内置的形状SwiftUI 中给我们提供了五种常用内置形状：矩形，圆角矩形，圆形，椭圆形和胶囊形状。 矩形在 SwiftUI 中使用 Rectangle 类创建一个矩形。 123Rectangle() .fill(.gray) // 矩形填充的颜色 .frame(width: 100, height: 100) 圆角矩形在 SwiftUI 中使用 RoundedRectangle 类创建一个圆角矩形，不过它的初始化方法给我们提供了两个属性， cornerSize 和 cornerRadius 。通过配置这两个属性我们都可以创建一个圆角矩形。 12345678// 通过圆角尺寸创建圆角矩形RoundedRectangle(cornerSize: CGSize(width: 8, height: 8)) .fill(.red) .frame(width: 100, height: 100)// 通过圆角半径创建圆角矩形RoundedRectangle(cornerRadius: 8) .frame(width: 100, height: 100) 以上两中方式创建出来的圆角矩形形状是一样的。 胶囊形创建一个胶囊形状使用 Capsule 类。 123Capsule() .fill(.orange) .frame(width: 100, height: 60) 这里需要注意的一点是，当我们不添加 frame 修饰器时，默认情况下为一个圆形。胶囊的最终形状根据给frame 修饰器的width和height 两个属性决定。 椭圆形创建一个椭圆形状使用 Ellipse 类。 12Ellipse() .frame(width: 100, height: 60) 同样地，当 frame 修饰器中的width 和 height 两个属性值一样时，椭圆形状会变成一个圆形。 圆形创建一个圆形状使用 Circle 类。 12Circle() .frame(width: 100, height: 100) 官方文档Shapes | Apple Developer Documentation","categories":[{"name":"SwiftUI 进阶","slug":"SwiftUI-进阶","permalink":"https://zhaofelix.github.io/swift-blogs/categories/SwiftUI-%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/SwiftUI/"},{"name":"形状","slug":"形状","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E5%BD%A2%E7%8A%B6/"}]},{"title":"Swift 中的集合类型","slug":"Swift-中的集合类型","date":"2023-08-25T01:17:28.000Z","updated":"2023-08-26T02:33:04.965Z","comments":true,"path":"posts/5f278529.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/5f278529.html","excerpt":"Swift 语言提供 Arrays、Sets 和 Dictionaries 三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。 Swift 语言中的 Arrays、Sets 和 Dictionaries 中存储的数据值类型必须明确。这意味着我们不能把错误的数据类型插入其中。","text":"Swift 语言提供 Arrays、Sets 和 Dictionaries 三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。 Swift 语言中的 Arrays、Sets 和 Dictionaries 中存储的数据值类型必须明确。这意味着我们不能把错误的数据类型插入其中。 数组数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中，这意味着数组中的元素是可以重复的。 创建一个空数组12var someInts = [Int]()var someStr:[String] = [] 创建一个带有默认值的数组12var threeDouble = Array(repeating: 0.3, count: 3)print(threeDouble) 这里我们使用Array默认构造方法创建了一个长度大小为3，初始元素值为0.3的双精度类型的数组。参数说明： repeating:初始时元素的值 count：元素的个数或者数组的长度 此时，打印数组的显示如下： 1[0.3, 0.3, 0.3] 访问数组我们可以根据数组的索引来访问数组中的元素，不过需要注意的一点是数组的索引是从0开始的。 1234var nameArr = [&quot;Felix&quot;,&quot;Zhao&quot;,&quot;Rudolf&quot;]print(&quot;第一个元素\\(nameArr[0])&quot;)print(&quot;第二个元素\\(nameArr[1])&quot;)print(&quot;第三个元素\\(nameArr[1])&quot;) 修改数组添加数组元素我们可以使用append方法或者赋值运算符+=将一个元素添加到数组的末尾。 12nameArr.append(&quot;Wells&quot;)nameArr += [&quot;Wells&quot;] 此时的数组为： 1[&quot;Felix&quot;, &quot;Zhao&quot;, &quot;Rudolf&quot;, &quot;Wells&quot;, &quot;Wells&quot;] 循环遍历数组我们可以使用for-in循环来遍历数组中的每一个元素。 123for name in nameArr &#123; print(name)&#125; 如果我们同时需要每个元素的值和对应的索引，我们可以使用enumerate()方法来遍历数组。 123for (index,name) in nameArr.enumerated() &#123; print(&quot;当前索引:\\(index),当前值：\\(name)&quot;)&#125; 输出结果如下： 1234当前索引:0,当前值：Felix当前索引:1,当前值：Zhao当前索引:2,当前值：Rudolf当前索引:3,当前值：Wells 数组合并当我们有两个数据类型相同数组需要合并时，可以使用+运算符来合并数组。 123var nameArr = [&quot;Felix&quot;,&quot;Zhao&quot;,&quot;Rudolf&quot;]var newNameArr = [&quot;Lily&quot;]var newArr = newNameArr + nameArr 此时，newArr的元素为： 1[&quot;Lily&quot;, &quot;Felix&quot;, &quot;Zhao&quot;, &quot;Rudolf&quot;] 数组相关属性12print(nameArr.count) print(nameArr.isEmpty) .count用来获取数组元素的个数；.isEmpty判断数组是否为空，返回值为布尔值。 字典Swift中的字典是一个用来存储无序的相同类型数据的集合。字典中每个值(value)对应一个唯一的键(key)，键被作为值在这个字典里的标识符。字典里的数据是没有具体顺序的，我们只能通过值对应的键来访问到这个数据。另外，字典中的键可以是整型或者字符串类型，但是一个字典里键的类型必须是唯一的。 创建字典Swift中的字典使用Dictionary&lt;Key,Value&gt;的形式定义，其中Key是字典中键的数据类型，Value是字典中值的数据类型。我们使用这样形式来定义一个空的字典： 1var emptyDcit = Dictionary&lt;String,String&gt;() Swift中也给我们提供了一种简化的语法来定义字典： 1var emptyDcit = [String:String]() 两种方式都是定义了一个键和值都为字符串类型的空字典，在实际使用过程中，我们更多的是使用后面简化的定义方法。 在项目开发中，如果我们只需要定义一个字典，但是不需要对它进行初始化操作的话，我们可以使用下面的这中方法： 1var dic:[String:String]! 字典的访问与修改我们可以根据键来修改字典中对应的值，我们也可以使用一些内置的方法来添加、删除元素。 123var countryDic:[String:String] = [&quot;JP&quot;:&quot;日本&quot;,&quot;CN&quot;:&quot;中国&quot;,&quot;UK&quot;:&quot;英国&quot;,&quot;FR&quot;:&quot;法国&quot;]print(countryDic[&quot;CN&quot;])print(countryDic[&quot;JP&quot;]) 在上面的实例代码中，我们定义了一个键为国家英文缩写，值为国家的中文简写。我们分别使用键CN和JP访问字典。 当我们需要字典中添加一个新的元素时候，可以使用以下方法： 1countryDic[&quot;IN&quot;] = &quot;印度&quot; 我们需要修改字典中的某个元素的值，使用以下方法： 1countryDic[&quot;CN&quot;] = &quot;中华人民共和国&quot; 我们发现，我们添加新的元素和修改原有元素的值的方法是一样的。这是因为当我们通过键去修改字典的时候，会根据键名先去查询字典中是否包含对应的键名，如果包含的话就修改对应的值，如果不包含就添加新的元素。 经过上面的添加和修改之后，此时的字典元素如下： 1[&quot;UK&quot;: &quot;英国&quot;, &quot;JP&quot;: &quot;日本&quot;, &quot;FR&quot;: &quot;法国&quot;, &quot;CN&quot;: &quot;中华人民共和国&quot;, &quot;IN&quot;: &quot;印度&quot;] 我们经常会遇到根据键名去删除字典中对应的元素，这时，我们可以使用以下方法： 1countryDic.removeValue(forKey: &quot;CN&quot;) 我们经常会使用到的方法还有： 123let index = countryDic.index(countryDic.startIndex, offsetBy: 1)countryDic.remove(at: index) //根据指定的索引删除元素countryDic.removeAll() //清空字典 字典的遍历在之前的学习中，我们使用了for-in循环来遍历数组，同样的我们也可以使用for-in来遍历字典，不同的是遍历字典返回的是每个元素对应的键和值。 123for (key,value) in countryDic &#123; print(&quot;键：\\(key),值：\\(value)&quot;)&#125; 当然，我们也可以值循环遍历出字典的键或者值。 123456for key in countryDic.keys &#123; print(key)&#125;for value in countryDic.values &#123; print(value)&#125; 另外，在学习数组的时候，我们使用isEmpty属性来判断一个数组是否为空，我们同样可以使用这个方法来判断字典是否为空。 集合Swift 中的集合（Set）是一种无序的、不重复的数据结构，它允许你存储不同类型的元素。集合的主要用途是检查元素是否存在于集合中，因为集合中的元素是唯一的，所以当你尝试添加一个已经存在的元素时，集合不会发生变化。 创建一个集合创建集合的常见方法是使用字面量语法或者初始化器（initializer）。下面是一些关于如何创建和使用集合的示例： 使用字面量语法创建集合： 12let numbers = Set&lt;Int&gt;() // 创建一个空的整数集合let fruits = Set&lt;String&gt;(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;) // 创建一个包含三个字符串元素的集合 使用初始化器创建集合： 123var emptySet: Set&lt;Int&gt; = [] // 创建一个空的整数集合var fruitsSet = Set([&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]) // 创建一个包含三个字符串元素的集合var mixedSet: Set&lt;Any&gt; = [1, &quot;apple&quot;, 3.14] // 创建一个包含整数和浮点数的混合类型集合 集合中元素的访问、修改和删除向集合中添加新的元素使用insert 方法： 12numbers.insert(1) // 添加一个元素到集合中fruits.insert(&quot;grape&quot;) // 向集合中添加一个元素，如果元素已经存在，则不会改变集合 使用remove 方法移除集合中的元素： 12numbers.remove(1) // 从集合中移除一个元素，如果元素不存在，则不会改变集合fruits.remove(&quot;banana&quot;) // 从集合中移除一个元素，如果元素不存在，则不会改变集合 集合的遍历集合的遍历和数组的遍历类似，使用 for-in循环语句。 1234567for number in numbers &#123; print(number) // 输出集合中的每个元素&#125;for fruit in fruits &#123; print(fruit) // 输出集合中的每个元素&#125; 检查元素是否存在于集合中判断一个元素是否存在于集合中可以使用contains 方法。 12345if fruits.contains(&quot;apple&quot;) &#123; print(&quot;苹果存在于集合中&quot;) // 如果集合包含指定的元素，则输出相应的信息&#125; else &#123; print(&quot;苹果不存在于集合中&quot;) // 如果集合不包含指定的元素，则输出相应的信息&#125; 获取集合的大小获取集合的大小或元素的数量使用count 属性。 1let size = fruits.count // 获取集合中的元素个数 判断两个集合是否相等（即它们包含相同的元素）判断两个集合是否相等可以使用== 运算符。 123let setA = Set([&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;])let setB = Set([&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;])let isEqual = setA == setB // 判断两个集合是否相等，如果相等则返回 true，否则返回 false","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://zhaofelix.github.io/swift-blogs/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Foundation","slug":"Foundation","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Foundation/"},{"name":"Swift","slug":"Swift","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Swift/"},{"name":"集合类型","slug":"集合类型","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/"},{"name":"数组","slug":"数组","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E6%95%B0%E7%BB%84/"},{"name":"集合","slug":"集合","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E9%9B%86%E5%90%88/"},{"name":"字典","slug":"字典","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E5%AD%97%E5%85%B8/"}]},{"title":"Swift 中的运算符","slug":"Swift-中的运算符","date":"2023-08-24T10:04:41.000Z","updated":"2023-08-26T02:33:04.962Z","comments":true,"path":"posts/c2a3f429.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/c2a3f429.html","excerpt":"Swift 中的运算符运算符是一个符号，用于告诉编译器执行一个数学或逻辑运算。 专门用语运算符包括一元、二元、三元： 一元运算符对一个目标进行操作，例如-a。 二元运算符对两个目标进行操作，例如a+b。 三元运算符操作三个目标，Swift语言有仅只有一个三元运算符（a ? b : c）。 Swift提供来以下几种运算符： 算术运算符 比较运算符 逻辑运算符 位运算符 赋值运算符 区间运算符 其他运算符","text":"Swift 中的运算符运算符是一个符号，用于告诉编译器执行一个数学或逻辑运算。 专门用语运算符包括一元、二元、三元： 一元运算符对一个目标进行操作，例如-a。 二元运算符对两个目标进行操作，例如a+b。 三元运算符操作三个目标，Swift语言有仅只有一个三元运算符（a ? b : c）。 Swift提供来以下几种运算符： 算术运算符 比较运算符 逻辑运算符 位运算符 赋值运算符 区间运算符 其他运算符 算术运算符Swift提供来四种标准的算术运算符： 加（+） 减（-） 乘（*） 除（&#x2F;） 12341 + 2 //equals 35 - 3 //equals 22 * 3 //equals 610 / 2 //equals 5 加法运算符同时支持String的拼接： 1&quot;Hello ,&quot; + &quot;World&quot; //equals &quot;Hello, World&quot; 比较运算符Swift支持所有C的所有标准比较运算符： 相等 （a &#x3D;&#x3D; b） 不像等（a !&#x3D; b） 大于（a &gt; b） 小于（a &lt; b） 大于等于（a &gt;&#x3D; b） 小于等于（a &lt;&#x3D; b） 每个比较运算符都会返回一个Bool来表示比较的结果是否为真： 1234561 == 2 //false2 != 3 //true2 &gt; 1 //true2 &lt; 1 //false 1 &gt;= 1 //true2 &lt;= 3 //true 注意：Swift同时也提供两个等价运算符（&#x3D;&#x3D;&#x3D; 和 !&#x3D;&#x3D; ）,你可以使用它们来判断两个对象的引用是否相同。 逻辑运算符逻辑运算符可以修改或者合并布尔逻辑值true和false。Swift提供 以下三种标准的逻辑运算符： 逻辑非 （ !a ）：对a的布尔值取反； 逻辑与 （ a&amp;&amp;b ）：若a和b均为true,则结果为true；若a和b中有一个或两个都为false，则结果为false。 逻辑或 （ a||b ）：若a和b其中一个为true，则结果为true。 12345var a:Bool = true var b:Bool = false!a //falsea&amp;&amp;b falsea||b true 位运算符位运算符用来对二位进制位进行操作，Swift提供以下几种位运算符： 取反（～） 按位与（&amp;） 按位或（|） 按位异或（^） p q p&amp;q p q p^q 0 1 0 1 1 1 0 0 0 0 0 0 赋值运算符赋值运算符（a &#x3D; b）可是初始化或者更新a的值为b: 123let b = 10var a = 5a = b //此时，a的值为10 除了简单的赋值运算符，Swift还提供了组合赋值运算符。 123456789let a = 10 let b = 10var c = 0c += a // c = c+ac -= a // c = c - ac *= a // c = c * ac /= a // c = c / ac %= a // c = c % a 区间运算符Swift包含了两个区间运算符，他们表示一个范围的值的便捷方式。 闭区间运算符（a…b）定义了从a到b的一组范围，并且包含了a和b。a的值不能大于b。123for i in 1...5&#123; print(i) //循环打印出1～5的整数，包括1和5&#125; 关于循环控制流的内容将在后续内容中出现。 半开区间运算符半开区间运算符（a..&lt;b）定义了从a到b但不包括b的区间。 123for i in 1...5&#123; print(i) //循环打印出1～4的整数,包括4，不包括5&#125; 单侧区间单侧区间主要用在数组的遍历。当我们需要遍历数组中的指定索引前或者后的元素时可以使用单侧区间。 12345678910111213//遍历数组items索引2后的所有元素for item in items[2...]&#123; print(item) &#125;//遍历数组items索引2前的所有元素for item in items[...2]&#123; print(item) &#125;//遍历数组items索引2前的所有元素,不包括索引2的元素for item in items[..&lt;2]&#123; print(item) &#125; 三元运算符三元条件运算符是一种有三部分的特殊运算符，它类似于 question ? answer1 : answer2。如果question为真，则会判断answer1并且返回它的值；否则它判断为answer2并且返回它的值。 123456if question &#123; answer1&#125;else &#123; answer2&#125;","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://zhaofelix.github.io/swift-blogs/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Swift/"},{"name":"运算符","slug":"运算符","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E8%BF%90%E7%AE%97%E7%AC%A6/"}]},{"title":"Swift 中的数据类型","slug":"Swift-中的数据类型","date":"2023-08-24T01:11:27.000Z","updated":"2023-08-26T02:33:04.959Z","comments":true,"path":"posts/6876d7b8.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/6876d7b8.html","excerpt":"整数整数是没有小数部分的数字。整数可以是有符号的或者无符号。Swift提供来8，16，32和64位编码的有符号和无符号整数，例如UInt8表示8位无符号的整数，Int32表示32有符号整数。","text":"整数整数是没有小数部分的数字。整数可以是有符号的或者无符号。Swift提供来8，16，32和64位编码的有符号和无符号整数，例如UInt8表示8位无符号的整数，Int32表示32有符号整数。 IntSwift 提供了一个特殊的整数类型Int，长度与当前平台的原生字长相同： 在32位平台上，Int和Int32长度相同。 在64位平台上，Int和Int64长度相同。 1var age:Int = 27 除非你需要特定长度的整数，一般来说使用Int就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，Int可以存储的整数范围也可以达到-2,147,483,648~2,147,483,647，大多数时候这已经足够大了。 UIntSwift 也提供了一个特殊的无符号类型UInt，长度与当前平台的原生字长相同： 在32位平台上，UInt和UInt32长度相同。 在64位平台上，UInt和UInt64长度相同。 1var age:UInt = 29 如果此时重新赋一个负值， Xcode 将会报错。 1age = -27 错误信息如下：“Negative integer ‘-27’ overflows when stored into unsigned type ‘UInt’“。 注意只在的确需要存储一个和当前平台原生字长度相同的无符号整数的时候才使用 UInt 。其他情况下，推荐使用 Int ，即使已经知道存储的值都是非负的。如同类型安全和类型推断中描述的那样，统一使用 Int 会提高代码的兼容性，同时可以避免不同数字类型之间的转换问题，也符合整数的类型推断。 浮点数浮点数是有小数的数字，例如3.1425926。浮点类型相比整数类型来说能表示更大的范围的值，可以存储比Int更大或者更小的数字。Swift提供来两种有符号的浮点数类型： Double代表63位的浮点数 Float代表32位的浮点数 注意Double有至少15位数字的精度，而Float的精度只有6位。 12var floatPI: Float = 3.1415926535897932384626433832795028841971693993751058209var doublePI: Double = 3.1415926535897932384626433832795028841971693993751058209 显示结果如下： 123.1415933.141592653589793 布尔值Swift有一个基础布尔量类型，就是Bool，布尔量被作为逻辑值来引用，因为它的值只能是真或者假。Swift布尔量提供量两个常量值，true和false。 12var isLocked: Bool = true isLocked = false 字符串字符串是一系列字符，例如”Hello world”。字符串类型用String表示。 1var name:String = &quot;Felix&quot; 多行字符串： 1234var multiLineString = &quot;&quot;&quot;Hello,My name is Felix.&quot;&quot;&quot; 字符字符指的是单个字母。 1var c:Character = &quot;a&quot; 可选类型可选类型用来处理值可能确实的情况，可选类型表示有值或没有值。 数据范围 类型 大小（字节） 区间值 Int8 1字节 -128到127 UInt8 1字节 0到255 Int32 4字节 -2147483648 到 2147483647 UInt32 4字节 0 到 4294967295 Int64 8字节 -9223372036854775808 到 9223372036854775807 UInt64 8字节 0 到 18446744073709551615 Float 4字节 1.2E-38 到 3.4E+38 (~6 digits) Double 8字节 2.3E-308 到 1.7E+308 (~15 digits) 整数类型可以使用Int.max和Int.min获取Int的最大值和最小值。","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://zhaofelix.github.io/swift-blogs/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Foundation","slug":"Foundation","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Foundation/"},{"name":"Swift","slug":"Swift","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Swift/"},{"name":"Xcode","slug":"Xcode","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Xcode/"}]},{"title":"Swift 中的常量和变量","slug":"Swift-中的常量和变量","date":"2023-08-22T04:30:14.000Z","updated":"2023-08-26T02:33:04.953Z","comments":true,"path":"posts/c6460431.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/c6460431.html","excerpt":"常量 &amp; 变量常量一旦被设置就不能被更改，使用关键字let 。变量被设置之后是可以被修改的，使用关键字var。 声明常量和变量常量和变量之后在被声明后才能使用，声明方式如下： 12var num:Int = 8let x:Int = 10 这段代码的意思是： “声明一个名为num，数据类型为Int，值为8的变量。然后声明一个名为x，数据类型为Int，值为10的常量。” 你可以在一行中声明多个常量或变量，使用逗号隔开： 1var x:Int = 10,y:Int = 12,z:Int = 20","text":"常量 &amp; 变量常量一旦被设置就不能被更改，使用关键字let 。变量被设置之后是可以被修改的，使用关键字var。 声明常量和变量常量和变量之后在被声明后才能使用，声明方式如下： 12var num:Int = 8let x:Int = 10 这段代码的意思是： “声明一个名为num，数据类型为Int，值为8的变量。然后声明一个名为x，数据类型为Int，值为10的常量。” 你可以在一行中声明多个常量或变量，使用逗号隔开： 1var x:Int = 10,y:Int = 12,z:Int = 20 类型标注在上面常量与变量的声明中，我们标识的常量和变量数据类型均为Int类型。这意味着变量num和常量x在进行赋值时只能赋Int类型的数值。 上面的错误显示的是把一个字符串类型的10赋值给了一个指定类型为Int的常量，这在Swift中是不被允许的。 你可以在一行中定义多个相同类型的常量或者变量，只需要在结尾加上数据类型即可： 1var x,y,z:Int 类型安全与类型推断Swift是一门类型安全的语言。类型安全的语言可以让你清楚地知道代码可以处理的值的类型。如果你的一部分代码期望获得String类型的值，你就不能错误的传给它一个Int类型的值。 因为Swift是类型安全的语言，所以Swift在编译的过程中会进行类型检查，任何不匹配的类型都会被标记为错误。 类型检查可以帮助我们在对一个已经声明好的常量或者变量进行赋值时，能够准备无误的赋一个指定类型的数据。但是，类型检查并不意味着我们每次声明时都需要明确指定数据类型，我们可以通过Swift中的类型判断来完成数据类型的指定。 12var x = 10var y = 10.0 上面的代码中，我们并没有给变量指定数据类型。Swift在编译的过程中通过类型判断推断x为Int类型，y为Double类型。 常量与变量的命名常量和变量的命名几乎可以使用任何的字符，包括Unicode字符： 123var 你好 = &quot;你好&quot;var 😃 = &quot;😃&quot;var `let` = &quot;let&quot; 需要注意的是，在使用Swift中关键字进行命名是需要添加反引号（&#96;）。 虽然Swift在命名上可以使用很多字符，但是为了开发的方便与后期维护建议开发者在命名时尽量遵循一些标准化的命名规范，例如驼峰式命名法。","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://zhaofelix.github.io/swift-blogs/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Foundation","slug":"Foundation","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Foundation/"}]},{"title":"SwiftUI 介绍","slug":"SwiftUI-介绍","date":"2023-08-22T02:36:50.000Z","updated":"2023-08-26T02:33:04.968Z","comments":true,"path":"posts/96cb395e.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/96cb395e.html","excerpt":"SwiftUI 简介SwiftUI 是 Apple 在 2019 年 WWDC 推出的一种现代化的 UI 开发框架，它是 iOS 13 和 macOS Catalina 的一部分。SwiftUI 可以让用户更容易地创建美观且响应式的用户界面，并且与 Core Data、Realm 等数据存储解决方案集成得非常好。此外，SwiftUI 还在不断更新和完善，以满足开发者的需求。 SwiftUI 的特点声明式编程SwiftUI 采用了声明式编程的方式，与传统的命令式编程相比，这种方式让代码更加简洁易读。你只需要描述应用程序的界面应该如何显示，而不需要详细指定每一个视图的属性和方法。","text":"SwiftUI 简介SwiftUI 是 Apple 在 2019 年 WWDC 推出的一种现代化的 UI 开发框架，它是 iOS 13 和 macOS Catalina 的一部分。SwiftUI 可以让用户更容易地创建美观且响应式的用户界面，并且与 Core Data、Realm 等数据存储解决方案集成得非常好。此外，SwiftUI 还在不断更新和完善，以满足开发者的需求。 SwiftUI 的特点声明式编程SwiftUI 采用了声明式编程的方式，与传统的命令式编程相比，这种方式让代码更加简洁易读。你只需要描述应用程序的界面应该如何显示，而不需要详细指定每一个视图的属性和方法。 响应式布局SwiftUI 提供了强大的响应式布局能力，可以轻松地创建出适应不同设备和屏幕尺寸的应用程序。它支持线性布局、网格布局和灵活的布局组合，让你可以轻松地构建出复杂的界面。 内置动画和过渡SwiftUI 提供了丰富的内置动画和过渡效果，可以让你轻松地为应用程序添加生动的交互效果。这些动画和过渡效果与硬件加速相结合，可以让你的应用程序看起来更加流畅和自然。 与 Core Data 和 Realm 集成SwiftUI 可以很容易地与 Core Data 和 Realm 等数据存储解决方案集成。你可以在应用程序中方便地访问和操作数据，而无需手动处理繁琐的数据库操作。 开始使用 SwiftUI要开始使用 SwiftUI，你需要先安装 Xcode（macOS 10.15 及更高版本自带），然后创建一个新的 iOS 或 macOS 项目。在项目中，你可以直接使用默认的 ContentView 模板来开始编写 SwiftUI 代码。 下面是一个简单的 SwiftUI 示例： 123456789101112131415161718192021import SwiftUIstruct ContentView: View &#123; var body: some View &#123; VStack &#123; Text(&quot;Hello, SwiftUI!&quot;) .font(.largeTitle) .padding() Button(action: &#123; print(&quot;Button tapped!&quot;) &#125;) &#123; Text(&quot;Tap me!&quot;) .font(.title) .foregroundColor(.white) .padding() .background(Color.blue) .cornerRadius(10) &#125; &#125; &#125;&#125; 这个示例展示了一个简单的页面，包含一个标题和一个按钮。当用户点击按钮时，控制台会输出 “Button tapped!”。你可以根据自己的需求修改这个示例，或者尝试创建更复杂的界面。 总之，SwiftUI 是一种功能强大、易于使用的 UI 开发框架，它可以帮助你更高效地构建出美观且响应式的应用程序。如果你已经熟悉 Swift 语言，那么学习 SwiftUI 将会是一件非常愉快的事情。","categories":[{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://zhaofelix.github.io/swift-blogs/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Swift/"},{"name":"Apple","slug":"Apple","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Apple/"},{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/SwiftUI/"},{"name":"WWDC","slug":"WWDC","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/WWDC/"}]},{"title":"Swift 介绍","slug":"Swift-介绍","date":"2023-08-22T01:25:58.000Z","updated":"2023-08-26T02:33:04.967Z","comments":true,"path":"posts/ea0a67e1.html","link":"","permalink":"https://zhaofelix.github.io/swift-blogs/posts/ea0a67e1.html","excerpt":"Swift 编程语言介绍Swift 是一种强大且直观的编程语言，由 Apple Inc. 开发，用于 iOS, macOS, watchOS 和 tvOS 的应用开发。Swift 结合了 C 和 Objective-C 的优点，并且支持函数式编程，面向对象编程和泛型编程。它的目标是提供一种安全、高效、灵活和现代化的编程语言，可以让开发者创造出更快、更稳定、更易用的应用程序。","text":"Swift 编程语言介绍Swift 是一种强大且直观的编程语言，由 Apple Inc. 开发，用于 iOS, macOS, watchOS 和 tvOS 的应用开发。Swift 结合了 C 和 Objective-C 的优点，并且支持函数式编程，面向对象编程和泛型编程。它的目标是提供一种安全、高效、灵活和现代化的编程语言，可以让开发者创造出更快、更稳定、更易用的应用程序。 特性安全性Swift 强调类型安全和内存管理。它不允许隐式转换到不安全的类型，这可以防止许多常见的编程错误。此外，Swift 使用自动引用计数（ARC）来管理内存，减少了内存泄露的可能性。 性能Swift 旨在提供高性能的应用程序。它的编译器进行了优化，以提高运行速度和减少能源消耗。Swift 的语法糖也有助于编写简洁且高效的代码。 易用性Swift 的语法清晰简洁，易于学习和使用。它的设计哲学是“简单就是美”，使得 Swift 代码既美观又易读。 开源Swift 是开源的，这意味着开发者可以查看和修改其源代码。这使得 Swift 成为一个活跃的社区项目，不断有新的功能和改进加入其中。 语言特性类型系统Swift 是一种静态类型语言，这意味着你在编写代码时必须为每个变量明确指定类型。这可以避免许多类型错误，并使得代码更加易于理解和维护。 面向对象编程Swift 完全支持面向对象编程，包括类、结构体、协议、继承和多态等概念。它也支持协议扩展，这使得你可以向现有类添加新的方法或者属性，而无需改变原有的代码。 函数式编程Swift 同时支持函数式编程和面向对象编程。你可以在函数中使用闭包，这为处理异步事件或者创建高阶函数提供了强大的工具。 PlaygroundsXcode 集成了一个强大的交互式编程环境——Playgrounds。你可以在 Playgrounds 中尝试 Swift 的各种特性，而无需创建完整的项目。 结论Swift 是一种强大、直观且安全的编程语言，它专注于提供最好的用户体验和性能。无论你是初学者还是有经验的开发者，Swift 都能帮助你更有效地编写代码。","categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://zhaofelix.github.io/swift-blogs/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Swift/"},{"name":"Apple","slug":"Apple","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Apple/"}]}],"categories":[{"name":"Swift 基础语法","slug":"Swift-基础语法","permalink":"https://zhaofelix.github.io/swift-blogs/categories/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"name":"SwiftUI 进阶","slug":"SwiftUI-进阶","permalink":"https://zhaofelix.github.io/swift-blogs/categories/SwiftUI-%E8%BF%9B%E9%98%B6/"},{"name":"SwiftUI 基础","slug":"SwiftUI-基础","permalink":"https://zhaofelix.github.io/swift-blogs/categories/SwiftUI-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Swift/"},{"name":"枚举","slug":"枚举","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E6%9E%9A%E4%B8%BE/"},{"name":"结构体","slug":"结构体","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/SwiftUI/"},{"name":"动画","slug":"动画","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E5%8A%A8%E7%94%BB/"},{"name":"SFSymbol","slug":"SFSymbol","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/SFSymbol/"},{"name":"类","slug":"类","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E7%B1%BB/"},{"name":"函数","slug":"函数","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E5%87%BD%E6%95%B0/"},{"name":"循环","slug":"循环","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E5%BE%AA%E7%8E%AF/"},{"name":"条件语句","slug":"条件语句","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/"},{"name":"自定义形状","slug":"自定义形状","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BD%A2%E7%8A%B6/"},{"name":"形状","slug":"形状","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E5%BD%A2%E7%8A%B6/"},{"name":"Foundation","slug":"Foundation","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Foundation/"},{"name":"集合类型","slug":"集合类型","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/"},{"name":"数组","slug":"数组","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E6%95%B0%E7%BB%84/"},{"name":"集合","slug":"集合","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E9%9B%86%E5%90%88/"},{"name":"字典","slug":"字典","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E5%AD%97%E5%85%B8/"},{"name":"运算符","slug":"运算符","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"Xcode","slug":"Xcode","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Xcode/"},{"name":"Apple","slug":"Apple","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/Apple/"},{"name":"WWDC","slug":"WWDC","permalink":"https://zhaofelix.github.io/swift-blogs/tags0/WWDC/"}]}