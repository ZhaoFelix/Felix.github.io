<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Reality Composer Pro之创建一个场景（一）</title>
    <url>/posts/5b8fb7ec.html</url>
    <content><![CDATA[<h3 id="下载安装Reality-Composer-Pro"><a href="#下载安装Reality-Composer-Pro" class="headerlink" title="下载安装Reality Composer Pro"></a>下载安装Reality Composer Pro</h3><p>在今年的<strong>WWDC23</strong>上，为了帮助开发者更好的开发<strong>Version Pro</strong>的应用，Apple 推出<strong>Reality Composer Pro</strong>。</p>
<blockquote>
<p>Apple 的官方介绍：</p>
<p>Discover the all-new Reality Composer Pro, designed to make it easy to preview and prepare 3D content for your visionOS apps. Available with Xcode, Reality Composer Pro can help you import and organize assets, such as 3D models, materials, and sounds. Best of all, it integrates tightly with the Xcode build process to preview and optimize your visionOS assets.</p>
</blockquote>
<p>截止目前，<strong>Reality Composer Pro</strong>已经可以通过最新的<strong>Xcode 15.1 beta 3</strong>中获取使用。我们只需要下载对应的Xcode 版本。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071415945.png" style="zoom:30%"/>

<p>然后，在Xcode 的顶部菜单栏中点击<strong>Xcode -&gt; Open Developer Tools -&gt; Reality Composer Pro</strong>即可。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071419118.png" style="zoom:30%"/>

<h3 id="使用-Reality-Composer-Pro-创建项目或者场景"><a href="#使用-Reality-Composer-Pro-创建项目或者场景" class="headerlink" title="使用 Reality Composer Pro 创建项目或者场景"></a>使用 Reality Composer Pro 创建项目或者场景</h3><p>打开**Reality Composer Pro **后，有三个操作选项，分别是：</p>
<ul>
<li><strong>Create New Project</strong>： 创建一个项目；</li>
<li><strong>Create New Scene</strong>：创建一个场景；</li>
<li><strong>Open Existion Project or Scene</strong>：打开一个已经存在的项目或者场景。</li>
</ul>
<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>创建一个<strong>项目</strong>后，它的文件结构如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071426406.png" style="zoom:40%"/>

<p><strong>Reality Composer Pro</strong>初始项目如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071430250.png" style="zoom: 20%"/>

<h4 id="创建一个场景"><a href="#创建一个场景" class="headerlink" title="创建一个场景"></a>创建一个场景</h4><p>如果创建的是一个场景，那么它就是一个<code>.usda</code>的场景文件。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071434419.png" style="zoom:50%"/>

<p><strong>Reality Composer Pro</strong>的初始界面如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071436697.png" style="zoom: 20%"/>

<h3 id="开始构建一个场景"><a href="#开始构建一个场景" class="headerlink" title="开始构建一个场景"></a>开始构建一个场景</h3><h4 id="素材导入"><a href="#素材导入" class="headerlink" title="素材导入"></a>素材导入</h4><p>这里我们直接使用**WWDC23 <strong>中</strong><a href="https://developer.apple.com/wwdc23/10083">认识 Reality Composer Pro</a>**这个 Session 的素材来构建一个相同的场景。</p>
<p>直接到[这里](<a href="https://developer.apple.com/documentation/visionOS/diorama">Diorama | Apple Developer Documentation</a>)下载整个项目包，然后根据下面的目录找到对应的素材：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071447119.png" style="zoom:20%"/>

<p>要导入素材，点击<strong>Reality Composer Por</strong>底部的素材导入按钮即可。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071451382.png" style="zoom: 50%"/>

<p>导入后：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071456023.png" style="zoom:20%"/>

<p>如果你想构建一个自己独特的场景，也可以使用<strong>Reality Composer Pro</strong>内置的<strong>资源库</strong>，点击右上角的➕按钮就能看到，</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071459026.png" style="zoom:20%"/>



<h3 id="构建底座"><a href="#构建底座" class="headerlink" title="构建底座"></a>构建底座</h3><p>将刚刚导入的素材<code>Diorana_base.usdz</code>和<code>Yosemite.usdz</code>拖入到中间的场景区域中。注意，如果我们是分开单个拖入场景的话，需要我们分别调整它们二者的位置以达到最佳的组合效果。如果不想单独调整位置，可以按住键盘上的<strong>Shift</strong>键同时选中两个文件一同拖入到场景中，这样他们就会很好的组合在一起。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071522623.png" style="zoom: 20%"/>

<p>接着我们可以给场景中的基座添加一个材质，让它看起来更加的真实。点击右上角的➕按钮，打开<strong>资源库</strong>，在左侧的分类选项卡中选择<strong>Material Library(材质资源库)<strong>，然后将我们需要材质拖入到场景中。例如这里我选择了</strong>Smooth Concrete</strong>材质效果。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071528860.png" style="zoom:20%"/>

<p>接着，在左侧选中需要添加材质的节点，展开<strong>Reality Composer Pro</strong>右侧面板，在<strong>Material Bindings</strong>区域将<strong>Binding</strong>的材质修改为我们刚刚拖入的材质即可。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071531898.png" style="zoom:20%"/>

<p>然后，是使用相同的方法，拖入三个<code>Location_Pin.usdz</code>到场景中，然后分别调整它们的位置到合适的位置。同时将它们分别重命名为<code>EI_Captian</code>、<code>Merced_River</code>和<code>Cathedral_Rocks</code>，选中三者，鼠标右键选择<strong>Group</strong>，将三者成组，组名为<code>Yosemite_Location_Pins</code>。最终，场景和左侧的节点层次结构如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202312071547082.png" style="zoom:30%"/>

<h3 id="WWDC23-介绍视频"><a href="#WWDC23-介绍视频" class="headerlink" title="WWDC23 介绍视频"></a>WWDC23 介绍视频</h3><p><a href="https://developer.apple.com/wwdc23/10083">认识 Reality Composer Pro</a></p>
]]></content>
      <categories>
        <category>Reality Composer Pro</category>
      </categories>
      <tags>
        <tag>Reality Composer Pro</tag>
        <tag>WWDC23</tag>
      </tags>
  </entry>
  <entry>
    <title>RealityKit之创建一个AR应用</title>
    <url>/posts/eed84786.html</url>
    <content><![CDATA[<h3 id="使用模板创建-AR-项目"><a href="#使用模板创建-AR-项目" class="headerlink" title="使用模板创建 AR 项目"></a>使用模板创建 AR 项目</h3><p>使用 Xcode创建一个 AR 项目时，直接选择<strong>Augmented Reality App</strong>模板：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311291114380.png" style="zoom:40%"/>

<p>接着，项目的配置选择<strong>SwiftUI</strong>和<strong>RealityKit</strong>：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311291115728.png" style="zoom:40%"/>

<p>项目创建好后，运行项目。<span style="color:red"><strong>注意</strong></span>：<strong>RealityKit</strong>构建的项目无法直接在预览或者模拟器中查看效果，需要将项目运行在 iPad 或者 iPhone的真实设备上。</p>
<span id="more"></span>

<p> 默认项目运行情况如下：</p>
<p><video width="20%" controls="controls" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311291123894.MP4" ></video></p>
<p>初始默认的项目中，通过实现<code>UIViewRepresentable</code>协议来显示一个<strong>UIKit</strong>中的视图。这个协议必须要是实现两个方法<code>makeUIView</code>和<code>updateUIView</code>，前者用来构建和返回一个 <code>UIView</code>类型的视图；后者根据<strong>SwiftUI</strong>中的状态变量变化时来更新<code>UIView</code>。</p>
<h3 id="RealityKit-层次结构介绍"><a href="#RealityKit-层次结构介绍" class="headerlink" title="RealityKit 层次结构介绍"></a>RealityKit 层次结构介绍</h3><img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311291135843.png" style="zoom:50%"/>

<p>上面的图为官方文档中提供的层次结构图。</p>
<p>在<strong>RealityKit</strong>中，最上层是一个<strong>ARView</strong>，用来向用户展示一个渲染的 3D 图形。一个<strong>ARView</strong>都有一个单一的<strong>Scene</strong>，这是一个<strong>Entity</strong>集合的容器。在<strong>Scene</strong>上，我们可以添加一个或者多个<strong>AnchorEntity</strong>，这个实例可以让 <strong>ARView</strong>知道如何将内容显示在真实的世界中。对于每一个<strong>AnchorEntity</strong>，我们可以在上面添加多个和多层次的<strong>Entity</strong>用来构建场景内容。</p>
<p>现在，我们来看看初始项目中的<code>makeUIView</code>方法，它的实现步骤如下：</p>
<ol>
<li>创建一个<strong>ARView</strong>实例：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arView <span class="operator">=</span> <span class="type">ARView</span>(frame: .zero)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个<strong>ModelEntity</strong>的实例，并添加一些基础的材质。这里是创建了一个长宽高均为 0.1m，圆角 0.005m的正方体：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mesh <span class="operator">=</span> <span class="type">MeshResource</span>.generateBox(size: <span class="number">0.1</span>, cornerRadius: <span class="number">0.005</span>)</span><br><span class="line"><span class="keyword">let</span> material <span class="operator">=</span> <span class="type">SimpleMaterial</span>(color: .gray, roughness: <span class="number">0.15</span>, isMetallic: <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">let</span> model <span class="operator">=</span> <span class="type">ModelEntity</span>(mesh: mesh, materials: [material])</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建一个<strong>AnchotEntity</strong>实例，并将上面创建<strong>ModelEntity</strong>添加到这个实例上：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anchor <span class="operator">=</span> <span class="type">AnchorEntity</span>(.plane(.horizontal, classification: .any, minimumBounds: <span class="type">SIMD2</span>&lt;<span class="type">Float</span>&gt;(<span class="number">0.2</span>, <span class="number">0.2</span>)))</span><br><span class="line">        anchor.children.append(model)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将创建的<strong>AnchorEntity</strong>实例添加到<strong>ARView</strong>的<strong>Scene</strong>上：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">arView.scene.anchors.append(anchor)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>最后就是返回<strong>ARView</strong>的实例。</li>
</ol>
<h3 id="场景追踪和辅助层添加"><a href="#场景追踪和辅助层添加" class="headerlink" title="场景追踪和辅助层添加"></a>场景追踪和辅助层添加</h3><p>在一个 AR 的场景中，我们需要对当前的场景变化进行实时的场景追踪，例如识别到水平面后才放置 3D 对象。要想实现场景的追踪，需要用到<strong>ARKit</strong>，所以我们首先需要导入这个模块：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ARKit</span><br></pre></td></tr></table></figure>

<p>然后删除<code>makeUIView</code>中除了<code>ARView</code>实例创建的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeUIView</span>(<span class="params">context</span>: <span class="type">Context</span>) -&gt; <span class="type">ARView</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> arView <span class="operator">=</span> <span class="type">ARView</span>(frame: .zero)</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 待添加</span></span><br><span class="line">      <span class="keyword">return</span> arView</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接着就是在<code>TODO</code>部分实现场景追踪的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> session <span class="operator">=</span> arView.session <span class="comment">// 获取 ARView中的 session</span></span><br><span class="line"><span class="keyword">let</span> config <span class="operator">=</span> <span class="type">ARWorldTrackingConfiguration</span>() <span class="comment">// 世界追踪配置</span></span><br><span class="line">config.planeDetection <span class="operator">=</span> [.horizontal] <span class="comment">// 水平面追踪</span></span><br><span class="line">session.run(config) <span class="comment">// AR的session根据这个配置进行运行</span></span><br></pre></td></tr></table></figure>

<p>AR 的 session 用来支持视图的渲染，它是<strong>ARSession</strong>的实例。在<strong>RealityKit</strong>中会自动创建一个默认的<code>session</code>来管理视图。</p>
<p>如果此时运行项目，它已经能够实时的追踪当前场景中的平面了，为了更加直观的看到这种追踪的效果，可以在<strong>ARView</strong>中添加一个辅助层视图。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 辅助视图</span></span><br><span class="line">      <span class="keyword">let</span> coachingOverlay <span class="operator">=</span> <span class="type">ARCoachingOverlayView</span>()</span><br><span class="line">      coachingOverlay.autoresizingMask <span class="operator">=</span> [.flexibleWidth, .flexibleHeight]</span><br><span class="line">      coachingOverlay.session <span class="operator">=</span> session</span><br><span class="line">      coachingOverlay.goal <span class="operator">=</span> .horizontalPlane <span class="comment">// 目标为水平</span></span><br><span class="line">      arView.addSubview(coachingOverlay) <span class="comment">// 将赋值视图作为子视图添加到 ARView 上</span></span><br></pre></td></tr></table></figure>

<p>另外，当 AR 追踪到平面时可以让它显示特征点或者锚点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">arView.debugOptions <span class="operator">=</span> [.showFeaturePoints, .showAnchorOrigins, .showAnchorGeometry]</span><br></pre></td></tr></table></figure>

<p>此时项目运行后的效果如下：</p>
<p><video width="30%" controls="controls" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311291527924.MP4"></video></p>
<p>当 AR 场景中识别到水平面之后，就会显示水平面的特征点、一个锚点坐标轴锚点的几何形状。另外我们注意到AR 场景会识别到多个不同的水平面。</p>
<h3 id="从-Reality-Composer-中获取-usdz格式的模型"><a href="#从-Reality-Composer-中获取-usdz格式的模型" class="headerlink" title="从 Reality Composer 中获取.usdz格式的模型"></a>从 Reality Composer 中获取<code>.usdz</code>格式的模型</h3><p>从 iPad 或者 iPhone 的 App Store 中搜索下载<strong>Reality Composer</strong>这个软件。<strong>Reality Composer</strong>可以让我们简单快速的构建、调整和模拟一个 AR 场景。</p>
<p>在 <strong>Xcode 15.0</strong>之前集成了这个工具，但是目前最新版的<strong>Xcode</strong> 已经移除。</p>
<p>除此之外，还需要下载 **Reality Converter **，它可以帮助我们在 Mac 上查看、自定义以及转换不同格式的 3D 模型。</p>
<blockquote>
<p><strong>下载链接</strong>：<a href="https://developer.apple.com/augmented-reality/tools/">Creation tools for spatial apps - Augmented Reality - Apple Developer</a></p>
</blockquote>
<h3 id="点击放置物体对象"><a href="#点击放置物体对象" class="headerlink" title="点击放置物体对象"></a>点击放置物体对象</h3><p> <span style="color:red"><strong>未完待续！！</strong></span></p>
]]></content>
      <categories>
        <category>RealityKit</category>
      </categories>
      <tags>
        <tag>RealityKit</tag>
        <tag>Reality Composer</tag>
        <tag>Reality Converter</tag>
      </tags>
  </entry>
  <entry>
    <title>SceneKit基础之实现一个太阳系场景(二)</title>
    <url>/posts/75fc57c3.html</url>
    <content><![CDATA[<p>在上一篇文章中，我们已经通过<strong>Scene Editor</strong>实现了场景的布局。接下来我们将通过代码的方式来给节点添加图片材质、场景背景以及切换相机的视角。</p>
<h3 id="定义模型和实现切换"><a href="#定义模型和实现切换" class="headerlink" title="定义模型和实现切换"></a>定义模型和实现切换</h3><p>定义一个名为<strong>Planet</strong>的枚举用来管理节点数据：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Planet</span>: <span class="title class_">String</span>, <span class="title class_">CaseIterable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mercury</span><br><span class="line">    <span class="keyword">case</span> venus</span><br><span class="line">    <span class="keyword">case</span> earth</span><br><span class="line">    <span class="keyword">case</span> mars</span><br><span class="line">    <span class="keyword">case</span> saturn</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// 名字为首字母大写</span></span><br><span class="line">        rawValue.prefix(<span class="number">1</span>).capitalized <span class="operator">+</span> rawValue.dropFirst()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>定义一个名<strong>ViewModel</strong>的类用来管理场景中选中的节点以及节点的切换事件：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ViewModel</span>: <span class="title class_">NSObject</span>,<span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> selectedPlanet: <span class="type">Planet</span>?  <span class="comment">// 当前选中的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前选中的节点名称</span></span><br><span class="line">    <span class="keyword">var</span> title:<span class="type">String</span> &#123;</span><br><span class="line">        selectedPlanet<span class="operator">?</span>.name <span class="operator">??</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选择下一个</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">selectedNextPlanet</span>() &#123;</span><br><span class="line">        changeSelection(offset: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选择上一个</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">selectedPreviousPlanet</span>() &#123;</span><br><span class="line">        changeSelection(offset: <span class="operator">-</span><span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空选择</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">clearSelection</span>() &#123;</span><br><span class="line">        selectedPlanet <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点改变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">changeSelection</span>(<span class="params">offset</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> selectedPlanet <span class="operator">=</span> selectedPlanet, <span class="keyword">let</span> index <span class="operator">=</span> <span class="type">Planet</span>.allCases.firstIndex(of: selectedPlanet) <span class="keyword">else</span> &#123;</span><br><span class="line">            selectedPlanet <span class="operator">=</span> <span class="type">Planet</span>.allCases.first</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> newIndex <span class="operator">=</span> index <span class="operator">+</span> offset</span><br><span class="line">        <span class="keyword">if</span> newIndex <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.selectedPlanet <span class="operator">=</span> <span class="type">Planet</span>.allCases.last</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> newIndex <span class="operator">&lt;</span> <span class="type">Planet</span>.allCases.count &#123;</span><br><span class="line">            <span class="keyword">self</span>.selectedPlanet <span class="operator">=</span> <span class="type">Planet</span>.allCases[newIndex]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.selectedPlanet <span class="operator">=</span> <span class="type">Planet</span>.allCases.first</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回到<strong>ContentView</strong>文件中，实例化一个<strong>ViewModel</strong>的对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ObservedObject</span> <span class="keyword">var</span> viewModel <span class="operator">=</span> <span class="type">ViewModel</span>()</span><br></pre></td></tr></table></figure>

<p>然后在 <code>body</code>部分实现界面的完全布局：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">       <span class="type">ZStack</span> &#123;</span><br><span class="line">           <span class="type">SceneView</span>(scene: scene,</span><br><span class="line">                     pointOfView:setupCamera(planet: viewModel.selectedPlanet),</span><br><span class="line">                     options: [.allowsCameraControl, .autoenablesDefaultLighting])</span><br><span class="line">           .background(.secondary)</span><br><span class="line">           </span><br><span class="line">           <span class="type">VStack</span> &#123;</span><br><span class="line">               <span class="type">Spacer</span>()</span><br><span class="line">               <span class="type">HStack</span> &#123;</span><br><span class="line">                   <span class="type">HStack</span> &#123;</span><br><span class="line">                       <span class="type">HStack</span> &#123;</span><br><span class="line">                           <span class="type">Button</span>(action: &#123;</span><br><span class="line">                               viewModel.selectedPreviousPlanet()</span><br><span class="line">                           &#125;, label: &#123;</span><br><span class="line">                               <span class="type">Image</span>(systemName: <span class="string">&quot;arrow.backward.circle.fill&quot;</span>)</span><br><span class="line">                           &#125;)</span><br><span class="line">                           <span class="type">Button</span>(action: &#123;</span><br><span class="line">                               viewModel.selectedPreviousPlanet()</span><br><span class="line">                           &#125;, label: &#123;</span><br><span class="line">                               <span class="type">Image</span>(systemName: <span class="string">&quot;arrow.forward.circle.fill&quot;</span>)</span><br><span class="line">                           &#125;)</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="type">Spacer</span>()</span><br><span class="line">                       <span class="type">Text</span>(viewModel.title)</span><br><span class="line">                           .foregroundStyle(.black)</span><br><span class="line">                       <span class="type">Spacer</span>()</span><br><span class="line">                       <span class="comment">// 不为空时显示清除按钮</span></span><br><span class="line">                       <span class="keyword">if</span> viewModel.selectedPlanet <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                           <span class="type">Button</span>(action: &#123;</span><br><span class="line">                               viewModel.clearSelection()</span><br><span class="line">                           &#125;, label: &#123;</span><br><span class="line">                               <span class="type">Image</span>(systemName: <span class="string">&quot;xmark.circle.fill&quot;</span>)</span><br><span class="line">                           &#125;)</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               .padding(<span class="number">8</span>)</span><br><span class="line">               .background(.white)</span><br><span class="line">               .clipShape(<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">14</span>))</span><br><span class="line">               .padding(<span class="number">20</span>)</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       .ignoresSafeArea(.all)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>SceneView</code>多了一个<code>pointOfView</code>参数，它是一个<code>SCNNode</code>类型，它表示的是当前场景渲染时的<strong>视角点</strong>。我们可以通过切换视角点来切换当前场景中可见的内容。<code>setupCamera</code>函数的实现如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据选中的节点，改变相机的视点</span></span><br><span class="line">   <span class="keyword">func</span> <span class="title function_">setupCamera</span>(<span class="params">planet</span>: <span class="type">Planet</span>?) -&gt; <span class="type">SCNNode</span>? &#123;</span><br><span class="line">       <span class="comment">// 获取场景中的相机节点</span></span><br><span class="line">       <span class="keyword">let</span> cameraNode <span class="operator">=</span> scene<span class="operator">?</span>.rootNode.childNode(withName: <span class="string">&quot;camera&quot;</span>, recursively: <span class="literal">false</span>)</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">let</span> planet <span class="operator">=</span> planet,  <span class="keyword">let</span> planetNode <span class="operator">=</span> scene<span class="operator">?</span>.rootNode.childNode(withName: planet.rawValue, recursively: <span class="literal">false</span>) &#123;</span><br><span class="line">           <span class="keyword">let</span> constraint <span class="operator">=</span> <span class="type">SCNLookAtConstraint</span>(target: planetNode)</span><br><span class="line">           cameraNode<span class="operator">?</span>.constraints <span class="operator">=</span> [constraint]</span><br><span class="line">           <span class="keyword">let</span> globalPosition <span class="operator">=</span> planetNode.convertPosition(<span class="type">SCNVector3</span>(<span class="number">50</span>, <span class="number">10</span>, <span class="number">0</span>), to: <span class="literal">nil</span>)</span><br><span class="line">           <span class="keyword">let</span> move <span class="operator">=</span> <span class="type">SCNAction</span>.move(to: globalPosition, duration: <span class="number">1.0</span>)</span><br><span class="line">           cameraNode<span class="operator">?</span>.runAction(move)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cameraNode</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>它的实现如下：</p>
<ol>
<li>根据节点名<code>camera</code>获取相机节点<code>cameraNode</code>；</li>
<li>根据传进来的<code>planet</code>的<code>rawValue</code>获取当前选中的节点<code>planetNode</code>；</li>
<li>然后设置<code>cameraNode</code>的<code>constraints</code>；</li>
<li>给<code>cameraNode</code>添加一个移动的<code>action</code>；</li>
<li>然后新的相机节点<code>cameraNode</code>作为场景的<code>pointOfView</code>。</li>
</ol>
<h3 id="给星球节点添加图片材质"><a href="#给星球节点添加图片材质" class="headerlink" title="给星球节点添加图片材质"></a>给星球节点添加图片材质</h3><p>将准备好的星球图片素材拖入到<strong>Assets</strong>素材文件夹下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311221022305.png" style="zoom:20%"/>

<p>同理，拖入准备好的场景背景素材添加到这个文件夹下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311221056208.png" style="zoom:20%"/>

<p><strong>注意</strong>，这里的场景背景图片需要放入六张图片。因为给 3D 场景背景添加背景图片需要同时设置 6 个方向，即 XYZ 三个轴的正负方向。</p>
<p>接着定义一个名为<code>applyTextures</code>的方法来添加材质和背景：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给场景添加材质</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">applyTextures</span>(<span class="params">to</span> <span class="params">scene</span>: <span class="type">SCNScene</span>?) &#123;</span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> scene <span class="operator">=</span> scene <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">      <span class="comment">// 给每个星球添加图片材质</span></span><br><span class="line">      <span class="keyword">for</span> planet <span class="keyword">in</span> <span class="type">Planet</span>.allCases &#123;</span><br><span class="line">          <span class="keyword">let</span> identifier <span class="operator">=</span> planet.rawValue</span><br><span class="line">          <span class="keyword">let</span> node <span class="operator">=</span> scene.rootNode.childNode(withName: identifier, recursively: <span class="literal">false</span>)</span><br><span class="line">          <span class="keyword">let</span> texture <span class="operator">=</span> <span class="type">UIImage</span>(named: identifier)</span><br><span class="line">          node<span class="operator">?</span>.geometry<span class="operator">?</span>.firstMaterial<span class="operator">?</span>.diffuse.contents <span class="operator">=</span> texture</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 给整个场景添加背景材质</span></span><br><span class="line">      <span class="keyword">let</span> skyboxImages <span class="operator">=</span> (<span class="number">1</span><span class="operator">...</span><span class="number">6</span>).map &#123; <span class="type">UIImage</span>(named: <span class="string">&quot;skybox<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>) &#125;</span><br><span class="line">      scene.background.contents <span class="operator">=</span> skyboxImages</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>给节点添加材质通过设置节点的<code>geometry?.firstMaterial</code>或者<code>geometry?.materials</code>。前者是只添加一个材质；后者添加多个材质。</p>
<p>给场景添加添加背景通过设置场景的<code>background.contents</code>。</p>
<p>最后，别忘了在<code>makeScene</code>方法中调用这个方法。</p>
]]></content>
      <categories>
        <category>SceneKit 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>SCNScene</tag>
        <tag>SCNLight</tag>
        <tag>SCNNode</tag>
        <tag>SceneKit</tag>
      </tags>
  </entry>
  <entry>
    <title>SceneKit之在SwiftUI中使用SceneKit</title>
    <url>/posts/54d45a15.html</url>
    <content><![CDATA[<blockquote>
<p>SceneKit is a high-level 3D graphics framework that helps you create 3D animated scenes and effects in your apps. It incorporates a physics engine, a particle generator, and easy ways to script the actions of 3D objects so you can describe your scene in terms of its content — geometry, materials, lights, and cameras — then animate it by describing changes to those objects.</p>
</blockquote>
<p><a href="https://developer.apple.com/scenekit/">SceneKit - Apple Developer</a></p>
<p>来自 Apple 的官方文档的说法，SceneKit 是一个面向高层级 3D 图形框架，它可以帮助我们在app中创建一个3D 可变的场景和效果。它包括了物理引擎、粒子生成器以及更简单的给 3D 对象添加动作。</p>
<span id="more"></span>

<h3 id="创建-SwiftUI项目并布局"><a href="#创建-SwiftUI项目并布局" class="headerlink" title="创建 SwiftUI项目并布局"></a>创建 SwiftUI项目并布局</h3><p>首先，我们现创建一个简单SwiftUI项目，初始的布局代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">30</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用 SceneKit显示的3D场景部分</span></span><br><span class="line">            <span class="type">Color</span>.gray</span><br><span class="line">                .frame(height: <span class="type">UIScreen</span>.main.bounds.height<span class="operator">/</span><span class="number">2</span>)</span><br><span class="line">            <span class="comment">// 左右的切换按钮</span></span><br><span class="line">            <span class="type">HStack</span>(content: &#123;</span><br><span class="line">                <span class="type">Image</span>(systemName: <span class="string">&quot;chevron.left.circle&quot;</span>)</span><br><span class="line">                <span class="type">Spacer</span>()</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;地球&quot;</span>)</span><br><span class="line">                    .bold()</span><br><span class="line">                <span class="type">Spacer</span>()</span><br><span class="line">                <span class="type">Image</span>(systemName: <span class="string">&quot;chevron.right.circle&quot;</span>)</span><br><span class="line">            &#125;).font(.title)</span><br><span class="line">            </span><br><span class="line">            <span class="type">VStack</span>(alignment: .leading, spacing: <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;简介&quot;</span>)</span><br><span class="line">                    .font(.title2)</span><br><span class="line">                    .bold()</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;地球（英文名：Earth；拉丁文：Terra）是距离太阳的第三颗行星，也是人类已知的唯一孕育和支持生命的天体。地球的表面大约 29.2% 是由大陆和岛屿组成的陆地。剩余的 70.8% 被水覆盖，大部分被海洋、海湾和其他咸水体覆盖，也被湖泊、冰川、河流和其他淡水体覆盖着，尤其冰川覆盖最多,它们共同构成了水圈。&quot;</span>)</span><br><span class="line">                    .font(.body)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;.padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311151159305.png" style="zoom:10%"/>

<p>接下来，我们使用<strong>SceneKit</strong>创建一个 3D场景用来显示地球、月球或者火星等。</p>
<h3 id="准备好要在-app-中显示或者加载的-3D-模型"><a href="#准备好要在-app-中显示或者加载的-3D-模型" class="headerlink" title="准备好要在 app 中显示或者加载的 3D 模型"></a>准备好要在 app 中显示或者加载的 3D 模型</h3><p>如果要使用<strong>SceneKit</strong>显示一些 3D 的场景，我们可以使用内置的几何体对象进行创建，也可直接使用其他的软件创建的 3D 模型，例如 Maya、3DS Max、Blender 等。</p>
<p>不同的 3D 软件创建出来的模型文件格式各有不同，在 <strong>SceneKit</strong>中，Apple 更推荐我们<strong>USDZ</strong>的文件格式。为此，Apple 还提供了用来进行格式转换的<strong>Reality Converter</strong>工具和更专业的<strong>USDZ Tools</strong>，前者直接通过界面操作的方式进行格式转换，后者基于 Python 命令行的方式实现，可操作性更高。</p>
<p>二者均可在该处<a href="https://developer.apple.com/augmented-reality/tools/">Creation tools for spatial apps - Augmented Reality - Apple Developer</a>下载使用。</p>
<p>这里，我们直接使用一些网上现成提供的模型：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311151214374.png"/>

<p>在 Mac上，每个这样的模型都可以通过内置的<strong>预览</strong>进行查看，然后通过鼠标或者触控板手势与模型进行交互。</p>
<p>接着就是将这些模型直接<strong>拖入</strong>到我们的项目中即可。</p>
<p>拖入到项目中后，每个模型也可以在 Xcode 中进行查看。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311151217244.png" style="zoom:20%"/>

<h3 id="使用-SceneKit-展示-3D模型"><a href="#使用-SceneKit-展示-3D模型" class="headerlink" title="使用 SceneKit 展示 3D模型"></a>使用 SceneKit 展示 3D模型</h3><p>首先，在头部引入<strong>SceneKit</strong>模块：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SceneKit</span><br></pre></td></tr></table></figure>

<p>然后，使用<code>SceneView</code>创建一个展示 3D 场景的视图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SceneView</span>(scene: <span class="type">SCNScene</span>(named: <span class="string">&quot;Earth.usdz&quot;</span>), options: [.allowsCameraControl, .autoenablesDefaultLighting])</span><br><span class="line"> .frame(height: <span class="number">300</span>)</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们配置了<code>SceneView</code>的两个参数，一个是<code>scene</code>场景，另一个是<code>options</code>场景可选配置。前者用来展示一个场景，它是<code>SCNScene</code>类型，后者是<code>SceneView.Options</code>类型。</p>
<p>我们之前拖入的<code>.usdz</code>格式的 3D 模型在 Xcode 中本身就是一个<code>scene</code>，所以我们这里可以直接加载这个场景即可。对于可选的配置选项<code>options</code>，<code>allowsCameraControl</code>允许场景中的相机可以自由进行切换，即我们可以上下左右旋转查看模型；<code>autoenablesDefaultLighting</code>给场景添加默认的灯光效果。</p>
<p>此时的效果如下：</p>
<p><video controls="controls" width="20%" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311151414390.mp4"></video></p>
<h3 id="场景和内容切换"><a href="#场景和内容切换" class="headerlink" title="场景和内容切换"></a>场景和内容切换</h3><p>接下来，我们来实现让中间的两个按钮可以自由的左右切换不同的场景。</p>
<p>定义一个结构体类型的模型对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SceneModel</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="comment">// 星球名称</span></span><br><span class="line">    <span class="keyword">var</span> sceneName: <span class="type">String</span> <span class="comment">// 星球模型场景</span></span><br><span class="line">    <span class="keyword">var</span> introduce:<span class="type">String</span> <span class="comment">//星球简介</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个模型数据数组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> planetModels:[<span class="type">SceneModel</span>] <span class="operator">=</span> [</span><br><span class="line">      .<span class="keyword">init</span>(name: <span class="string">&quot;地球&quot;</span>, sceneName: <span class="string">&quot;Earth.usdz&quot;</span>, introduce: <span class="string">&quot;地球（英文名：Earth；拉丁文：Terra）是距离太阳的第三颗行星，也是人类已知的唯一孕育和支持生命的天体。地球的表面大约 29.2% 是由大陆和岛屿组成的陆地。剩余的 70.8% 被水覆盖，大部分被海洋、海湾和其他咸水体覆盖，也被湖泊、冰川、河流和其他淡水体覆盖着，尤其冰川覆盖最多,它们共同构成了水圈。&quot;</span>),</span><br><span class="line">      .<span class="keyword">init</span>(name: <span class="string">&quot;木星&quot;</span>, sceneName: <span class="string">&quot;Jupiter.usdz&quot;</span>, introduce: <span class="string">&quot;木星为太阳系最大的行星. 木星大到什麽程度呢? 做个比较，如果木星是个中空的球体，那麽其内部大约可以放入1300个地球，可见这颗行星有多巨大. 不过由於木星的密度较地球低，其质量仅为地球的317倍. 左边的图片为木星与地球依照比例呈现的图片。&quot;</span>),</span><br><span class="line">      .<span class="keyword">init</span>(name: <span class="string">&quot;火星&quot;</span>, sceneName: <span class="string">&quot;Mars.usdz&quot;</span>, introduce: <span class="string">&quot;太阳系八大行星的第四颗行星，介於地球与小行星群之间，距离太阳约1.52AU，体积大小仅为地球的1/6，而重量为地球的1/10. 为类地行星中距离太阳最远的. 火星古代又被称为荧惑，而英文Mars的意义为战神的意思.&quot;</span>),</span><br><span class="line">      .<span class="keyword">init</span>(name: <span class="string">&quot;冥王星&quot;</span>, sceneName: <span class="string">&quot;Pluto.usdz&quot;</span>, introduce: <span class="string">&quot;冥王星是太阳系中最後一个较大的行星 ，2006年以前与其他的八大行星并称九大行星，但2006年的天文大会已经将他降级成矮行星。&quot;</span>),</span><br><span class="line">      .<span class="keyword">init</span>(name: <span class="string">&quot;金星&quot;</span>, sceneName: <span class="string">&quot;Venus.usdz&quot;</span>, introduce: <span class="string">&quot;金星是太阳系八大行星的第二颗行星，距离太阳约0.72天文单位，轨道在水星与地球之间。金星的一天相当於地球的２３０天，磁场强度只有地球的 10 万分之一左右。此外金星的自转方向与地球以及其他行星的自转方向相反，十分奇特。&quot;</span>)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>使用<code>@State</code>定义一个响应式变量，用来追踪当前展示的场景索引:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> index: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure>

<p>修改<code>SceneView</code>的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SceneView</span>(scene: <span class="type">SCNScene</span>(named: planetModels[index].sceneName), options: [.allowsCameraControl, .autoenablesDefaultLighting])</span><br></pre></td></tr></table></figure>

<p>名称和简介的<code>Text</code>分别为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(planetModels[index].name)</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(planetModels[index].introduce)</span><br></pre></td></tr></table></figure>

<p>最后就是给中间的两个<code>Image</code>添加一个点击切换的手势和事件，</p>
<p>切换到上一个：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(systemName: <span class="string">&quot;chevron.left.circle&quot;</span>)</span><br><span class="line">                .onTapGesture &#123;</span><br><span class="line">                    withAnimation() &#123;</span><br><span class="line">                        index <span class="operator">=</span> index <span class="operator">==</span> <span class="number">0</span> <span class="operator">?</span> planetModels.count <span class="operator">-</span> <span class="number">1</span> : index <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>切换到下一个：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(systemName: <span class="string">&quot;chevron.right.circle&quot;</span>)</span><br><span class="line">                   .onTapGesture &#123;</span><br><span class="line">                       withAnimation &#123;</span><br><span class="line">                           index <span class="operator">=</span> index <span class="operator">==</span> planetModels.count <span class="operator">-</span> <span class="number">1</span> <span class="operator">?</span> <span class="number">0</span> : index <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">                       &#125;</span><br><span class="line">                       </span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:red"><strong>注意</strong></span>，在通过数组索引访问数组元素时，一定要注意<strong>数组索引越界</strong>的问题。</p>
<p>此时的效果如下：</p>
<p><video controls="controls" width="20%" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311151447381.mp4"> </video></p>
<p>至此，这个简单的项目就完成了。后续我们将逐步深入了解<strong>SceneKit</strong>中的基础元素，包括<strong>场景</strong>、<strong>节点</strong>、<strong>相机</strong>、<strong>灯光</strong>、<strong>物理引擎</strong>、<strong>粒子系统</strong>等。</p>
]]></content>
      <categories>
        <category>SceneKit 基础</category>
      </categories>
      <tags>
        <tag>Reality Converter</tag>
        <tag>SwiftUI</tag>
        <tag>SceneKit</tag>
        <tag>USDZ</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 中的常量和变量</title>
    <url>/posts/c6460431.html</url>
    <content><![CDATA[<h1 id="常量-变量"><a href="#常量-变量" class="headerlink" title="常量 &amp; 变量"></a>常量 &amp; 变量</h1><p>常量一旦被设置就不能被更改，使用关键字<strong>let</strong> 。变量被设置之后是可以被修改的，使用关键字<strong>var</strong>。</p>
<h2 id="声明常量和变量"><a href="#声明常量和变量" class="headerlink" title="声明常量和变量"></a>声明常量和变量</h2><p>常量和变量之后在被声明后才能使用，声明方式如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num:<span class="type">Int</span> <span class="operator">=</span> <span class="number">8</span></span><br><span class="line"><span class="keyword">let</span> x:<span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>这段代码的意思是：</p>
<p>“声明一个名为num，数据类型为<strong>Int</strong>，值为8的变量。然后声明一个名为x，数据类型为<strong>Int</strong>，值为10的常量。”</p>
<p>你可以在一行中声明多个常量或变量，使用逗号隔开：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x:<span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span>,y:<span class="type">Int</span> <span class="operator">=</span> <span class="number">12</span>,z:<span class="type">Int</span> <span class="operator">=</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h2><p>在上面常量与变量的声明中，我们标识的常量和变量数据类型均为<strong>Int</strong>类型。这意味着变量num和常量x在进行赋值时只能赋<strong>Int</strong>类型的数值。</p>
<p>上面的错误显示的是把一个字符串类型的10赋值给了一个指定类型为<strong>Int</strong>的常量，这在Swift中是不被允许的。</p>
<p>你可以在一行中定义多个相同类型的常量或者变量，只需要在结尾加上数据类型即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x,y,z:<span class="type">Int</span></span><br></pre></td></tr></table></figure>

<h2 id="类型安全与类型推断"><a href="#类型安全与类型推断" class="headerlink" title="类型安全与类型推断"></a>类型安全与类型推断</h2><p>Swift是一门类型安全的语言。类型安全的语言可以让你清楚地知道代码可以处理的值的类型。如果你的一部分代码期望获得<strong>String</strong>类型的值，你就不能错误的传给它一个<strong>Int</strong>类型的值。</p>
<p>因为Swift是类型安全的语言，所以Swift在编译的过程中会进行类型检查，任何不匹配的类型都会被标记为错误。</p>
<p>类型检查可以帮助我们在对一个已经声明好的常量或者变量进行赋值时，能够准备无误的赋一个指定类型的数据。但是，类型检查并不意味着我们每次声明时都需要明确指定数据类型，我们可以通过Swift中的类型判断来完成数据类型的指定。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> y <span class="operator">=</span> <span class="number">10.0</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们并没有给变量指定数据类型。Swift在编译的过程中通过类型判断推断x为<strong>Int</strong>类型，y为<strong>Double</strong>类型。</p>
<h2 id="常量与变量的命名"><a href="#常量与变量的命名" class="headerlink" title="常量与变量的命名"></a>常量与变量的命名</h2><p>常量和变量的命名几乎可以使用任何的字符，包括Unicode字符：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 你好 <span class="operator">=</span> <span class="string">&quot;你好&quot;</span></span><br><span class="line"><span class="keyword">var</span> 😃 <span class="operator">=</span>  <span class="string">&quot;😃&quot;</span></span><br><span class="line"><span class="keyword">var</span> `let` <span class="operator">=</span> <span class="string">&quot;let&quot;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用Swift中关键字进行命名是需要添加反引号（&#96;）。</p>
<p>虽然Swift在命名上可以使用很多字符，但是为了开发的方便与后期维护建议开发者在命名时尽量遵循一些标准化的命名规范，例如驼峰式命名法。</p>
]]></content>
      <categories>
        <category>Swift 基础语法</category>
      </categories>
      <tags>
        <tag>Foundation</tag>
      </tags>
  </entry>
  <entry>
    <title>SceneKit基础之实现一个太阳系场景(一)</title>
    <url>/posts/24c195ec.html</url>
    <content><![CDATA[<p>在这篇博文中，我们将实现下面这样的一个效果：</p>
<p><video width="20%" controls="controls" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311180936806.mp4"></video></p>
<p>在上面的效果中，使用<strong>SceneKit</strong>创建了一个 3D 的太阳系场景。在这个场景中，有我们常见的行星，然后我们还给场景设置了一个全场景的背景。最后就是通过下面的左右切换按钮可以切换视角查看不同的行星。</p>
<span id="more"></span>

<h3 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h3><p>在 Xcode 中，使用通用的模板创建一个 SwiftUI 的项目。然后在项目中创建一个<strong>SceneKit Scene File</strong>，即<strong>SceneKit 的场景文件</strong>。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311180957991.png" style="zoom: 40%"/>

<p>创建完成后，文件的扩展名为<code>.scn</code>：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311181003069.png" style="zoom:20%"/>

<p>接着，到<code>ContentView</code>文件中，定义一个名为<code>makeScene</code>的静态函数用来通过这个文件名加载场景：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">makeScene</span>() -&gt; <span class="type">SCNScene</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> scene <span class="operator">=</span> <span class="type">SCNScene</span>(named: <span class="string">&quot;Solar.scn&quot;</span>) <span class="comment">// 通过场景文件创建一个场景</span></span><br><span class="line">        <span class="keyword">return</span> scene</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将这个函数返回场景赋值给到一个变量，供后续使用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scene: <span class="type">SCNScene</span>? <span class="operator">=</span> makeScene()</span><br></pre></td></tr></table></figure>

<p>在<code>body</code>部分，通过<code>SceneView</code>来展示这个场景：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SceneView</span>(scene: scene, options: [.allowsCameraControl, .autoenablesDefaultLighting])</span><br></pre></td></tr></table></figure>

<p>此时通过预览或者编译运行项目，就能看到场景文件所展示的内容了。因为现在我们的场景文件中除了一个背景什么都没有，所以我们只能看到一个简单的效果。</p>
<h3 id="通过场景编辑器（Scene-Editor）来编辑布局场景"><a href="#通过场景编辑器（Scene-Editor）来编辑布局场景" class="headerlink" title="通过场景编辑器（Scene Editor）来编辑布局场景"></a>通过场景编辑器（Scene Editor）来编辑布局场景</h3><p>回到新建的<code>.scn</code>文件中，在这个文件中，Xcode 给我们提供了一个<strong>场景编辑器</strong>的功能，让我们可以直接通过界面的方式编辑一个场景。</p>
<p>在<strong>Scene Editor</strong>的左边区域，可以看到整个场景中包含的<strong>节点</strong>，新建的场景中摸下情况下只有一个<strong>相机（Camera）</strong>节点。让我们先来看一下 Apple 官方对<strong>场景（SCNScene）</strong>的定义：</p>
<blockquote>
<p>A container for the node hierarchy and global properties that together form a displayable 3D scene.</p>
</blockquote>
<p>在这个定义中，我们可以知道一个<strong>SCNScene</strong>是一系列节点的容器。这些节点属于<strong>SCNNode</strong>类型。</p>
<p><img data-src="https://docs-assets.developer.apple.com/published/4f035789b7/592d7da9-814c-4bbd-b1a7-0e07b3003d94.png" alt="文档示例图"></p>
<p>每个<strong>节点</strong>都有很多的属性可以在<strong>Scene Editor</strong>中进行设置，选中任意一个节点后，展开 Xcode 右侧的<strong>观察器</strong>：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311200948983.png" style="zoom:30%"/>

<p>熟悉UIKit中<strong>Storyboard</strong>界面编辑的同学会发现，这里多了很多的<strong>观察器</strong>：</p>
<ul>
<li><strong>Node inspector</strong>： 节点观察器，可以设置节点的基本属性，例如位置和大小；</li>
<li><strong>Attributes inspetor</strong>：属性观察器；</li>
<li><strong>Material inspector</strong>：材质观察器，可以设置节点的材质样式；</li>
<li><strong>Physics inspector</strong>： 物理观察器，给节点添加物理效果时用到；</li>
<li><strong>Scene inspector</strong>： 场景观察器，可以对场景进行设置。</li>
</ul>
<p>接下来，我们首先来调整一下场景中相机节点的相关属性。选中相机节点后，点击右侧的<strong>Node inspector</strong>，设置下面的属性：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311201006110.png" style="zoom:40%"/>

<p>在我们的场景中，每个节点都会有这些属性，每个属性都可以进行设置：</p>
<ul>
<li><strong>Identity</strong>： 节点名称，在代码中可以通过这个节点名获取到这个节点；</li>
<li><strong>Position</strong>：节点在场景中相对于父节点的位置；</li>
<li><strong>Euler</strong>： 节点相对于父节点的旋转；</li>
<li><strong>Scale</strong> ：在 x、y、z三个轴上的变换尺寸</li>
</ul>
<p>当我们改变了场景中相机节点的相关属性之后，可能看不到这个节点，可以通过对场景的缩放来查看找到节点。</p>
<h3 id="向场景中添加其他节点或对象"><a href="#向场景中添加其他节点或对象" class="headerlink" title="向场景中添加其他节点或对象"></a>向场景中添加其他节点或对象</h3><p>在<strong>Scene Editor</strong>中，点击Xcode顶部的**+**按钮：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311201033512.png" style="zoom:30%"/>

<p>然后，我们选择一个<strong>Sphere</strong>球体对象拖入到场景中：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311201035975.png" style="zoom:30%"/>

<p>此时，如果运行项目，我们是无法在场景中查看这个球体的，因为这个场景并不在相机的<strong>视野</strong>范围内容。我们可以来调整一下这个球体节点的属性。</p>
<h4 id="修改节点材质"><a href="#修改节点材质" class="headerlink" title="修改节点材质"></a>修改节点材质</h4><p>选中节点后，在观察器面板选择<strong>Materials inspector（材质观察器）</strong>。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311201405923.png" style="zoom:30%"/>

<p>接着，点击<strong>Diffuse</strong>的颜色选择选择器，设置一个<strong>Hex Color</strong>为**#F2FF2C<strong>，这样一来我们就给这个对象添加了一个颜色的材质效果。然后设置</strong>Illumination<strong>的颜色为</strong>white**，设置这个属性可以调整光在节点上的照明度，即便这个节点被和光源隔离，它依然能收到灯光。</p>
<h4 id="修改节点的大小和相机节点视野"><a href="#修改节点的大小和相机节点视野" class="headerlink" title="修改节点的大小和相机节点视野"></a>修改节点的大小和相机节点视野</h4><p>为了让这个节点显得更大一点，可以在<strong>Attributes inspector</strong>将<strong>Radius</strong>调整为<code>10</code>即可。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311201736484.png" style="zoom:30%"/>

<p>此时，我们会注意到这个节点依然没有在相机节点的视野内。一方面可以调整这个节点相对于相机的位置；另一方面可以直接调整相机的<strong>Z Clipping</strong> 属性。</p>
<p>这个属性有两个值，一个是<strong>Near</strong>，另一个是<strong>Far</strong>。这里我们将<strong>Far</strong>的值调整为<code>300</code>。此时的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311201742077.png" style="zoom:40%"/>

<h3 id="添加其他的节点"><a href="#添加其他的节点" class="headerlink" title="添加其他的节点"></a>添加其他的节点</h3><p>按照上面相同的方式添加其他的节点，同时设置节点的位置、大小、节点名、节点颜色材质以及节点光照效果。以下所有的节点均为<strong>Sphere</strong>。</p>
<h5 id="Mercury"><a href="#Mercury" class="headerlink" title="Mercury"></a>Mercury</h5><ul>
<li><strong>Name</strong>：mercury</li>
<li><strong>Position</strong>： x:0，y:0， z:15</li>
<li><strong>Diffuse</strong>： #BBBBBB</li>
<li><strong>Roughness</strong>：节点<strong>粗糙度</strong>为<code>1</code>，取值范围为 0～1。0 表示光滑，反光越多；1 表示粗糙，反光越少。</li>
</ul>
<h5 id="Venus"><a href="#Venus" class="headerlink" title="Venus"></a>Venus</h5><ul>
<li><strong>Name</strong>：venus</li>
<li><strong>Position</strong>： x:0，y:0， z:35</li>
<li><strong>Diffuse</strong>： #59B1D6</li>
<li><strong>Radius</strong>：2</li>
<li><strong>Roughness</strong>：节点<strong>粗糙度</strong>为<code>1</code>。</li>
</ul>
<h5 id="Earth"><a href="#Earth" class="headerlink" title="Earth"></a>Earth</h5><ul>
<li><strong>Name</strong>：earth</li>
<li><strong>Position</strong>： x:0，y:0， z:50</li>
<li><strong>Diffuse</strong>： #2F5CD6</li>
<li><strong>Radius</strong>：2</li>
<li><strong>Roughness</strong>：节点<strong>粗糙度</strong>为<code>1</code>。</li>
</ul>
<h5 id="Mars"><a href="#Mars" class="headerlink" title="Mars"></a>Mars</h5><ul>
<li><p><strong>Name</strong>：mars</p>
</li>
<li><p><strong>Position</strong>： x:0，y:0， z:75</p>
</li>
<li><p><strong>Diffuse</strong>： #C65B2C</p>
</li>
<li><p><strong>Radius</strong>：2</p>
</li>
<li><p><strong>Roughness</strong>：节点<strong>粗糙度</strong>为<code>1</code>。</p>
</li>
</ul>
<h5 id="Saturn"><a href="#Saturn" class="headerlink" title="Saturn"></a>Saturn</h5><ul>
<li><strong>Name</strong>：saturn</li>
<li><strong>Position</strong>： x:0，y:0， z:150</li>
<li><strong>Diffuse</strong>： #D69D5F</li>
<li><strong>Radius</strong>：5</li>
<li><strong>Roughness</strong>：节点<strong>粗糙度</strong>为<code>1</code>。</li>
</ul>
<h5 id="给土星添加星环"><a href="#给土星添加星环" class="headerlink" title="给土星添加星环"></a>给土星添加星环</h5><p>众所周知，土星有一个与众不同支持在于它有一个自己独特的星环。所以我们接下来要给<code>saturn</code>节点添加一个星环的子节点。</p>
<p>点击 Xcode 顶部的**+<strong>按钮，选择或者搜索一个</strong>Tube**形状节点添加到<code>saturn</code>节点上。添加完成后，在节点管理中中的结构如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311201810337.png"/>

<p>接着，我们调整<strong>Tube</strong>形状的以下属性：</p>
<ul>
<li><strong>Inner raduis</strong>： 7 </li>
<li><strong>Outer radius</strong>：9 </li>
<li><strong>Height</strong>：0.1</li>
</ul>
<p>然后，就是让这个<strong>Tube</strong> 节点使用和<code>saturn</code>相同的材质效果。在<strong>Tube</strong> 的<strong>Attritubes insepector</strong>中，找到<strong>Materials</strong>属性，</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311201815812.png" style="zoom: 40%"/>

<p>点击左边的➕按钮，选择对应的材质即可。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311201816771.png" style="zoom:20%"/>

<p>此时的场景中效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311201817415.png" style="zoom: 30%"/>
]]></content>
      <categories>
        <category>SceneKit 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>SCNScene</tag>
        <tag>SCNLight</tag>
        <tag>SCNNode</tag>
        <tag>SceneKit</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 中的循环</title>
    <url>/posts/73894dfa.html</url>
    <content><![CDATA[<p>Swift提供了多样化的控制流语句。包括<strong>while</strong>循环；<strong>for-in</strong>循环；<code>if</code>，<code>guard</code>和<code>switch</code>语句用来基于特定的条件执行不同的代码分支。</p>
<span id="more"></span>

<h4 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for-in 循环"></a>for-in 循环</h4><p>使用<strong>for-in</strong>循环来遍历数组，指定范围内的数字或者字符串中的字符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Felix&quot;</span>,<span class="string">&quot;Rudolf&quot;</span>,<span class="string">&quot;Zora&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好，<span class="subst">\(name)</span>！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">你好，<span class="type">Felix！</span></span><br><span class="line">你好，<span class="type">Rudolf！</span></span><br><span class="line">你好，<span class="type">Zora！</span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用<strong>for-in</strong>循环来遍历字典，遍历字典时我们可以同时遍历出字典中的键和值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> persons <span class="operator">=</span> [<span class="string">&quot;Felix&quot;</span>:<span class="number">23</span>,<span class="string">&quot;Rudolf&quot;</span>:<span class="number">34</span>,<span class="string">&quot;Zora&quot;</span>:<span class="number">33</span>]</span><br><span class="line"><span class="keyword">for</span> (name,age) <span class="keyword">in</span> persons &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> 今年<span class="subst">\(age)</span>岁！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Rudolf</span> 今年<span class="number">34</span>岁！</span><br><span class="line"><span class="type">Felix</span> 今年<span class="number">23</span>岁！</span><br><span class="line"><span class="type">Zora</span> 今年<span class="number">33</span>岁！</span><br></pre></td></tr></table></figure>

<p>循环打印出指定范围内的数字：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环打印出1到5的整数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的数字循环中我们通过<strong>区间运算符</strong>来辅助实现数字的循环。</p>
</blockquote>
<p>另外，我们在循环时for后面跟着的是一个被隐式声明的常量，我们不再需要使用let关键字再次进行声明。</p>
<p>在某些情况下，当我们只需要指定循环的次数，并不需要用到隐式声明的常量时，我们可以使用通配符“_”来省略声明的常量。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i自加5次</span></span><br><span class="line"><span class="keyword">var</span> i <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">5</span>&#123;</span><br><span class="line">    i <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p><strong>while</strong>循环通过判断条件执行分支代码。当条件为true时，执行循环内的代码，否则不行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> a <span class="operator">&lt;</span> b &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a小于b&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a小于b</span><br></pre></td></tr></table></figure>

<h5 id="repeat-while"><a href="#repeat-while" class="headerlink" title="repeat-while"></a>repeat-while</h5><p><strong>repeat-while</strong>是while循环的另一种形式，它相当与其他编程语言中的<strong>do-while</strong>循环，在判断循环条件之前它会先去执行一次循环代码块，然后重复循环直到判断条件为false。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a小于b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> a <span class="operator">&lt;</span> b</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift 基础语法</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 中的类</title>
    <url>/posts/338306b2.html</url>
    <content><![CDATA[<p>在Swift中，类是一种引用类型，用于封装数据和方法。类是面向对象编程的基础，它们允许我们创建具有特定属性和方法的自定义数据类型。在这篇文章中，我们将详细介绍Swift中的类及其使用方法。</p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>在Swift中，类使用<code>class</code>关键字定义。类的定义包括一个可选的名称、一对大括号<code>&#123;&#125;</code>，以及一个或多个属性和方法的定义。类的属性可以是<span style="color:red"><strong>值类型</strong></span>（例如<code>Int</code>、<code>String</code>等），也可以是<span style="color:red"><strong>引用类型</strong></span>（例如数组、字典等）。方法则包含在一个或多个大括号内，并遵循特定的语法规则。</p>
<span id="more"></span>

<p>下面是一个简单的类定义示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">sayHello</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello, my name is <span class="subst">\(name)</span> and I am <span class="subst">\(age)</span> years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个名为<code>Person</code>的类，它有两个属性（<code>name</code>和<code>age</code>）和一个方法（<code>sayHello</code>）。<code>init</code>方法是一个特殊的方法，用于初始化类的实例。当创建一个新的<code>Person</code>实例时，我们需要提供一个名字和一个年龄，然后<code>init</code>方法会将这些值分别赋给<code>name</code>和<code>age</code>属性。</p>
<p>定义好一个类之后，我们可以实例化一个类的对象，然后通过<strong>点语法</strong>去访问类的属性和方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Felix&quot;</span>, age: <span class="number">25</span>)</span><br><span class="line">person.sayHello()</span><br><span class="line">person.age <span class="operator">=</span> <span class="number">26</span> </span><br></pre></td></tr></table></figure>



<h2 id="类的构造器和属性访问修饰符"><a href="#类的构造器和属性访问修饰符" class="headerlink" title="类的构造器和属性访问修饰符"></a>类的构造器和属性访问修饰符</h2><p>在Swift中，我们可以使用构造器来初始化类的实例。构造器是一个特殊的函数，它在创建类的实例时被调用。构造器的名称与类名相同，并且没有返回类型。我们可以在构造器中设置实例的属性值。</p>
<p>在上面的<code>Person</code>类中，我们使用了<code>init</code>方法作为构造器。当我们创建一个新的<code>Person</code>实例时，需要提供名字和年龄参数，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Alice&quot;</span>, age: <span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<p>此外，我们还可以使用访问修饰符来控制属性和方法的访问权限。Swift提供了四种访问修饰符：<code>public</code>、<code>protected</code>、<code>internal</code>和默认（即不使用任何修饰符）。<strong>默认情况下，所有属性和方法都是公开的（可以在任何地方访问）</strong>。通过使用不同的访问修饰符，我们可以限制属性和方法的可见性，从而提高代码的安全性和可维护性。</p>
<p>例如，我们可以将上面的<code>Person</code>类修改为以下形式，将所有属性和方法设置为私有：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">func</span> <span class="title function_">sayHello</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello, my name is <span class="subst">\(name)</span> and I am (age) years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们再想通过实例化的对象访问 <code>name</code> 和 <code>age</code> 属性时，Xcode 会报以下的错误：</p>
<p> <span style="color:red"><code>&#39;age&#39; is inaccessible due to &#39;private&#39; protection level </code></span></p>
<h2 id="类的继承和多态性"><a href="#类的继承和多态性" class="headerlink" title="类的继承和多态性"></a>类的继承和多态性</h2><p>在Swift中，类可以继承自其他类，从而实现代码的重用和扩展。子类可以继承父类的属性和方法，并可以根据需要添加新的属性和方法。此外，Swift还支持多态性，这意味着我们可以使用父类的引用来操作子类的对象。</p>
<p>下面是一个关于类继承的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 子类独有的属性</span></span><br><span class="line">    <span class="keyword">var</span> school: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>, <span class="params">school</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.school <span class="operator">=</span> school</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 子类独有的方法</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">toSchool</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Go to school&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的这个例子中，我们定义了一个<code>Student</code> 子类，这个子类继承了<code>Person</code> 父类。这里的继承意味着<code>Student</code> 子类有父类的<code>age</code> 和<code>name</code>属性以及<code>sayHello</code>方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> student <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Felix&quot;</span>, age: <span class="number">26</span>, school: <span class="string">&quot;SBS&quot;</span>)</span><br><span class="line">student.toSchool() <span class="comment">// 调用字类方法</span></span><br><span class="line">student.sayHello() <span class="comment">// 调用父类方法</span></span><br></pre></td></tr></table></figure>



<p>在子类中，我们还可以重写父类的方法，使用 <code>override</code> 关键字：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 重写父类的方法</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">sayHello</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, my name is<span class="subst">\(name)</span> and I am <span class="subst">\(age)</span> years old. my school is <span class="subst">\(school)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Swift 基础语法</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 中的枚举</title>
    <url>/posts/251de72f.html</url>
    <content><![CDATA[<h3 id="Swift-中的枚举"><a href="#Swift-中的枚举" class="headerlink" title="Swift 中的枚举"></a>Swift 中的枚举</h3><p>在计算机编程中，枚举是一种数据类型，用于定义一定范围内的有名称的值。Swift语言中的枚举是强大且灵活的工具，我们可以在多种场景中使用它们，包括但不限于处理特定类型的数据、创建自定义的错误类型以及实现特定的设计模式。</p>
<h4 id="定义和基本用法"><a href="#定义和基本用法" class="headerlink" title="定义和基本用法"></a>定义和基本用法</h4><p>在Swift中，我们使用<code>enum</code>关键字来定义枚举。下面是一个简单的例子，展示了如何定义和使用一个名为<code>Weekday</code>的枚举，表示一周中的每一天：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Monday</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tuesday</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Wednesday</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Thursday</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Friday</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Saturday</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sunday</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>我们可以使用这个枚举来处理与一周中的某天相关的数据。例如，我们可以创建一个函数，根据给定的<code>Weekday</code>枚举值返回一周中的相应天数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">dayOfWeek</span>(<span class="keyword">_</span> <span class="params">weekday</span>: <span class="type">Weekday</span>) -&gt; <span class="type">String</span> &#123;  </span><br><span class="line">    <span class="keyword">switch</span> weekday &#123;  </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Monday</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Monday&quot;</span>  </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Tuesday</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Tuesday&quot;</span>  </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Wednesday</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wednesday&quot;</span>  </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Thursday</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Thursday&quot;</span>  </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Friday</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Friday&quot;</span>  </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Saturday</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Saturday&quot;</span>  </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Sunday</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Sunday&quot;</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以像下面这样使用这个函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> monday <span class="operator">=</span> <span class="type">Weekday</span>.<span class="type">Monday</span>  </span><br><span class="line"><span class="built_in">print</span>(dayOfWeek(monday)) <span class="comment">// 输出：Monday</span></span><br></pre></td></tr></table></figure>

<h4 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h4><p>Swift的枚举还可以定义关联值，这使得枚举能够更丰富地表达信息。例如，我们创建一个枚举表示用户的登录状态，并为其关联一个错误消息：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">UserLoginStatus</span> &#123;  </span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">String</span>)  </span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">String</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>UserLoginStatus</code>枚举有两个cases：<code>success</code>和<code>failure</code>。这两个cases都关联了一个String类型的值，表示成功或失败的状态信息。我们可以像下面这样使用这个枚举：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> successfulLogin <span class="operator">=</span> <span class="type">UserLoginStatus</span>.success(<span class="string">&quot;登录成功&quot;</span>)  </span><br><span class="line"><span class="keyword">let</span> failedLogin <span class="operator">=</span> <span class="type">UserLoginStatus</span>.failure(<span class="string">&quot;登录失败，请检查用户名和密码&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(successfulLogin) <span class="comment">// 输出：登录成功  </span></span><br><span class="line"><span class="built_in">print</span>(failedLogin) <span class="comment">// 输出：登录失败，请检查用户名和密码</span></span><br></pre></td></tr></table></figure>

<h4 id="在switch语句中使用枚举"><a href="#在switch语句中使用枚举" class="headerlink" title="在switch语句中使用枚举"></a>在switch语句中使用枚举</h4><p>由于Swift的枚举是全特性的，所以在switch语句中可以使用枚举的所有case值。这对于处理多种可能的枚举值非常有用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someWeekday: <span class="type">Weekday</span> <span class="operator">=</span> .<span class="type">Wednesday</span>  </span><br><span class="line"><span class="keyword">switch</span> someWeekday &#123;  </span><br><span class="line"><span class="keyword">case</span> .<span class="type">Monday</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;今天是星期一&quot;</span>)  </span><br><span class="line"><span class="keyword">case</span> .<span class="type">Tuesday</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;今天是星期二&quot;</span>)  </span><br><span class="line"><span class="keyword">case</span> .<span class="type">Wednesday</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;今天是星期三&quot;</span>)  </span><br><span class="line"><span class="keyword">case</span> .<span class="type">Thursday</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;今天是星期四&quot;</span>)  </span><br><span class="line"><span class="keyword">case</span> .<span class="type">Friday</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;今天是星期五&quot;</span>)  </span><br><span class="line"><span class="keyword">case</span> .<span class="type">Saturday</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;今天是星期六&quot;</span>)  </span><br><span class="line"><span class="keyword">case</span> .<span class="type">Sunday</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;今天是星期日&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用原始值和匿名枚举"><a href="#使用原始值和匿名枚举" class="headerlink" title="使用原始值和匿名枚举"></a>使用原始值和匿名枚举</h4><p>有时候，我们可能不需要为枚举的每个case关联一个特定的值，或者我们希望将所有值都关联到一个单一的原始值。在这种情况下，我们可以使用原始值和匿名枚举。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span>乏味的颜色: <span class="title class_">Int</span> &#123;  </span><br><span class="line">    <span class="keyword">case</span> red <span class="operator">=</span> <span class="number">1</span>, green <span class="operator">=</span> <span class="number">2</span>, blue <span class="operator">=</span> <span class="number">3</span>, yellow <span class="operator">=</span> <span class="number">4</span>, orange <span class="operator">=</span> <span class="number">5</span>,  <span class="comment">// 可以根据需要添加更多颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift 基础语法</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 中的结构体</title>
    <url>/posts/8745e5a7.html</url>
    <content><![CDATA[<h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><p>在Swift中，结构体是一种值类型，用于组合不同类型的值。它们可以被视为小型的数据模型，用于存储一组相关的数据。</p>
<h3 id="结构体的主要特点"><a href="#结构体的主要特点" class="headerlink" title="结构体的主要特点"></a>结构体的主要特点</h3><ol>
<li><strong>数据组合</strong>：结构体可以将不同类型的值组合在一起，形成一个有意义的数据结构。这使得结构体非常适合用于描述现实世界中的对象或数据模型。</li>
<li><strong>封装</strong>：结构体可以将数据封装在一起，形成一个单一的、可操作的数据单元。这有助于隐藏内部实现细节，提高代码的可读性和可维护性。</li>
<li><strong>代码复用</strong>：结构体可以通过定义公共的属性和方法，实现代码的复用。这可以在不同的代码片段中重复使用相同的结构体定义，提高代码的效率和可读性。</li>
<li><strong>数据类型安全</strong>：结构体是类型安全的，这意味着在编译时可以检测到类型错误。这有助于减少运行时错误，提高代码的稳定性和安全性。</li>
</ol>
<span id="more"></span>

<p>此外，结构体还具有以下特点：</p>
<ol>
<li><strong>值类型</strong>：结构体是值类型，这意味着当我们将一个结构体赋值给一个变量或者作为函数的参数时，它会进行一次深复制。这意味着修改一个结构体的副本不会影响原始结构体。</li>
<li><strong>语法简单</strong>：在Swift中定义结构体的语法非常简单。我们只需要使用<code>struct</code>关键字，后面跟着结构体的名称和定义它的变量和方法。</li>
<li><strong>内存管理简单</strong>：由于结构体通常存储的是基本数据类型和其他结构体，因此它们的内存管理相对简单。这使得使用结构体比使用类更加高效，尤其是在处理大量数据时。</li>
<li><strong>适用于小型对象</strong>：由于结构体的内存占用较小，因此它们更适合用于描述小型对象或数据模型。对于大型对象或需要复杂行为的数据类型，类可能是更好的选择。</li>
</ol>
<h3 id="定义一个结构体"><a href="#定义一个结构体" class="headerlink" title="定义一个结构体"></a>定义一个结构体</h3><p>让我们通过一个示例来深入理解结构体的使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> grade: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">updateAge</span>(<span class="params">newAge</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        age <span class="operator">=</span> newAge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了一个名为<code>Student</code>的结构体，它包含三个属性：<code>name</code>、<code>age</code>和<code>grade</code>，分别表示学生的姓名、年龄和年级。我们还定义了一个名为<code>updateAge</code>的方法，用于更新学生的年龄。</p>
<p>我们可以像下面这样创建一个<code>Student</code>实例并设置它的属性值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> student1 <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;张三&quot;</span>, age: <span class="number">20</span>, grade: <span class="string">&quot;大一&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(student1.name) <span class="comment">// 输出 &quot;张三&quot;</span></span><br><span class="line"><span class="built_in">print</span>(student1.age) <span class="comment">// 输出 &quot;20&quot;</span></span><br><span class="line"><span class="built_in">print</span>(student1.grade) <span class="comment">// 输出 &quot;大一&quot;</span></span><br><span class="line"></span><br><span class="line">student1.updateAge(newAge: <span class="number">21</span>) <span class="comment">// 更新学生年龄为21</span></span><br><span class="line"><span class="built_in">print</span>(student1.age) <span class="comment">// 输出 &quot;21&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们通过创建<code>Student</code>实例并设置它的属性值来描述一个学生对象。然后，我们使用<code>updateAge</code>方法来更新学生的年龄。请注意，由于<code>updateAge</code>方法修改了结构体的属性值，因此它被标记为<code>mutating</code>。这是因为在Swift中，非变异方法不能修改结构体的属性值。</p>
]]></content>
      <categories>
        <category>Swift 基础语法</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 中的数据类型</title>
    <url>/posts/6876d7b8.html</url>
    <content><![CDATA[<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>整数是没有小数部分的数字。整数可以是有符号的或者无符号。Swift提供来8，16，32和64位编码的有符号和无符号整数，例如UInt8表示8位无符号的整数，Int32表示32有符号整数。</p>
<span id="more"></span>

<h5 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h5><p>Swift 提供了一个特殊的整数类型<strong>Int</strong>，长度与当前平台的原生字长相同：</p>
<ul>
<li>在32位平台上，Int和Int32长度相同。</li>
<li>在64位平台上，Int和Int64长度相同。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age:<span class="type">Int</span> <span class="operator">=</span> <span class="number">27</span></span><br></pre></td></tr></table></figure>



<p>除非你需要特定长度的整数，一般来说使用Int就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，Int可以存储的整数范围也可以达到-2,147,483,648~2,147,483,647，大多数时候这已经足够大了。</p>
<h5 id="UInt"><a href="#UInt" class="headerlink" title="UInt"></a>UInt</h5><p>Swift 也提供了一个特殊的无符号类型<strong>UInt</strong>，长度与当前平台的原生字长相同：</p>
<ul>
<li>在32位平台上，<strong>UInt</strong>和<strong>UInt32</strong>长度相同。</li>
<li>在64位平台上，<strong>UInt</strong>和<strong>UInt64</strong>长度相同。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age:<span class="type">UInt</span> <span class="operator">=</span> <span class="number">29</span></span><br></pre></td></tr></table></figure>

<p>如果此时重新赋一个<span style="color:red"><strong>负值</strong></span>， Xcode 将会报错。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">age <span class="operator">=</span> <span class="operator">-</span><span class="number">27</span></span><br></pre></td></tr></table></figure>

<p>错误信息如下：<span style='color:red'>“<strong>Negative integer ‘-27’ overflows when stored into unsigned type ‘UInt’</strong>“</span>。</p>
<blockquote>
<p><strong>注意</strong><br>只在的确需要存储一个和当前平台原生字长度相同的无符号整数的时候才使用 UInt 。其他情况下，推荐使用 Int ，即使已经知道存储的值都是非负的。如同类型安全和类型推断中描述的那样，统一使用 Int 会提高代码的兼容性，同时可以避免不同数字类型之间的转换问题，也符合整数的类型推断。</p>
</blockquote>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数是有小数的数字，例如3.1425926。浮点类型相比整数类型来说能表示更大的范围的值，可以存储比Int更大或者更小的数字。Swift提供来两种有符号的浮点数类型：</p>
<ul>
<li><strong>Double</strong>代表63位的浮点数</li>
<li><strong>Float</strong>代表32位的浮点数</li>
</ul>
<blockquote>
<p><strong>注意</strong><br>Double有至少15位数字的精度，而Float的精度只有6位。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> floatPI: <span class="type">Float</span> <span class="operator">=</span> <span class="number">3.1415926535897932384626433832795028841971693993751058209</span></span><br><span class="line"><span class="keyword">var</span> doublePI: <span class="type">Double</span> <span class="operator">=</span> <span class="number">3.1415926535897932384626433832795028841971693993751058209</span></span><br></pre></td></tr></table></figure>

<p>显示结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">3.141593</span></span><br><span class="line"><span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure>



<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>Swift有一个基础布尔量类型，就是Bool，布尔量被作为逻辑值来引用，因为它的值只能是真或者假。Swift布尔量提供量两个常量值，<strong>true</strong>和<strong>false</strong>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isLocked: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span> </span><br><span class="line">isLocked <span class="operator">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串是一系列字符，例如”Hello world”。字符串类型用String表示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name:<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Felix&quot;</span></span><br></pre></td></tr></table></figure>

<p>多行字符串：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> multiLineString <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Hello,</span></span><br><span class="line"><span class="string">My name is Felix.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>字符指的是单个字母。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c:<span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h4><p>可选类型用来处理值可能确实的情况，可选类型表示有值或没有值。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><table>
<thead>
<tr>
<th>类型</th>
<th>大小（字节）</th>
<th>区间值</th>
</tr>
</thead>
<tbody><tr>
<td>Int8</td>
<td>1字节</td>
<td>-128到127</td>
</tr>
<tr>
<td>UInt8</td>
<td>1字节</td>
<td>0到255</td>
</tr>
<tr>
<td>Int32</td>
<td>4字节</td>
<td>-2147483648 到 2147483647</td>
</tr>
<tr>
<td>UInt32</td>
<td>4字节</td>
<td>0 到 4294967295</td>
</tr>
<tr>
<td>Int64</td>
<td>8字节</td>
<td>-9223372036854775808 到 9223372036854775807</td>
</tr>
<tr>
<td>UInt64</td>
<td>8字节</td>
<td>0 到 18446744073709551615</td>
</tr>
<tr>
<td>Float</td>
<td>4字节</td>
<td>1.2E-38 到 3.4E+38 (~6 digits)</td>
</tr>
<tr>
<td>Double</td>
<td>8字节</td>
<td>2.3E-308 到 1.7E+308 (~15 digits)</td>
</tr>
</tbody></table>
<blockquote>
<p>整数类型可以使用<strong>Int.max</strong>和<strong>Int.min</strong>获取Int的最大值和最小值。</p>
</blockquote>
]]></content>
      <categories>
        <category>Swift 基础语法</category>
      </categories>
      <tags>
        <tag>Foundation</tag>
        <tag>Swift</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 中的运算符</title>
    <url>/posts/c2a3f429.html</url>
    <content><![CDATA[<h3 id="Swift-中的运算符"><a href="#Swift-中的运算符" class="headerlink" title="Swift 中的运算符"></a>Swift 中的运算符</h3><p>运算符是一个符号，用于告诉编译器执行一个数学或逻辑运算。</p>
<h4 id="专门用语"><a href="#专门用语" class="headerlink" title="专门用语"></a>专门用语</h4><p>运算符包括一元、二元、三元：</p>
<ul>
<li>一元运算符对一个目标进行操作，例如-a。</li>
<li>二元运算符对两个目标进行操作，例如a+b。</li>
<li>三元运算符操作三个目标，Swift语言有仅只有一个三元运算符（a ? b : c）。</li>
</ul>
<p>Swift提供来以下几种运算符：</p>
<ul>
<li>算术运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>区间运算符</li>
<li>其他运算符</li>
</ul>
<span id="more"></span>

<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>Swift提供来四种标准的算术运算符：</p>
<ul>
<li>加（+）</li>
<li>减（-）</li>
<li>乘（*）</li>
<li>除（&#x2F;）</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="operator">+</span> <span class="number">2</span> <span class="comment">//equals 3</span></span><br><span class="line"><span class="number">5</span> <span class="operator">-</span> <span class="number">3</span> <span class="comment">//equals 2</span></span><br><span class="line"><span class="number">2</span> <span class="operator">*</span> <span class="number">3</span> <span class="comment">//equals 6</span></span><br><span class="line"><span class="number">10</span> <span class="operator">/</span> <span class="number">2</span>  <span class="comment">//equals 5</span></span><br></pre></td></tr></table></figure>

<p>加法运算符同时支持String的拼接：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello ,&quot;</span> <span class="operator">+</span> <span class="string">&quot;World&quot;</span> <span class="comment">//equals &quot;Hello, World&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><p>Swift支持所有C的所有标准比较运算符：</p>
<ul>
<li>相等 （a &#x3D;&#x3D; b）</li>
<li>不像等（a !&#x3D; b）</li>
<li>大于（a &gt; b）</li>
<li>小于（a &lt; b）</li>
<li>大于等于（a &gt;&#x3D; b）</li>
<li>小于等于（a &lt;&#x3D; b）</li>
</ul>
<p>每个比较运算符都会返回一个Bool来表示比较的结果是否为真：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="operator">==</span> <span class="number">2</span> <span class="comment">//false</span></span><br><span class="line"><span class="number">2</span> <span class="operator">!=</span> <span class="number">3</span> <span class="comment">//true</span></span><br><span class="line"><span class="number">2</span> <span class="operator">&gt;</span> <span class="number">1</span>  <span class="comment">//true</span></span><br><span class="line"><span class="number">2</span> <span class="operator">&lt;</span> <span class="number">1</span> <span class="comment">//false </span></span><br><span class="line"><span class="number">1</span> <span class="operator">&gt;=</span> <span class="number">1</span> <span class="comment">//true</span></span><br><span class="line"><span class="number">2</span> <span class="operator">&lt;=</span> <span class="number">3</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Swift同时也提供两个等价运算符（&#x3D;&#x3D;&#x3D; 和 !&#x3D;&#x3D; ）,你可以使用它们来判断两个对象的引用是否相同。</p>
</blockquote>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符可以修改或者合并布尔逻辑值true和false。Swift提供 以下三种标准的逻辑运算符：</p>
<ul>
<li>逻辑非 （ !a ）：对a的布尔值取反；</li>
<li>逻辑与 （ a&amp;&amp;b ）：若a和b均为true,则结果为true；若a和b中有一个或两个都为false，则结果为false。</li>
<li>逻辑或 （ a||b ）：若a和b其中一个为true，则结果为true。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span> </span><br><span class="line"><span class="keyword">var</span> b:<span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"><span class="operator">!</span>a  <span class="comment">//false</span></span><br><span class="line">a<span class="operator">&amp;&amp;</span>b <span class="literal">false</span></span><br><span class="line">a<span class="operator">||</span>b <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符用来对二位进制位进行操作，Swift提供以下几种位运算符：</p>
<ul>
<li>取反（～）</li>
<li>按位与（&amp;）</li>
<li>按位或（|）</li>
<li>按位异或（^）</li>
</ul>
<table>
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>p&amp;q</th>
<th>p</th>
<th>q</th>
<th>p^q</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符（a &#x3D; b）可是初始化或者更新a的值为b:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">a <span class="operator">=</span> b <span class="comment">//此时，a的值为10</span></span><br></pre></td></tr></table></figure>

<p>除了简单的赋值运算符，Swift还提供了组合赋值运算符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">10</span> </span><br><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> c <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">c <span class="operator">+=</span> a <span class="comment">//  c = c+a</span></span><br><span class="line">c <span class="operator">-=</span> a  <span class="comment">// c = c - a</span></span><br><span class="line">c <span class="operator">*=</span> a <span class="comment">// c = c * a</span></span><br><span class="line">c <span class="operator">/=</span> a  <span class="comment">// c = c / a</span></span><br><span class="line">c <span class="operator">%=</span> a  <span class="comment">// c = c % a</span></span><br></pre></td></tr></table></figure>

<h4 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h4><p>Swift包含了两个区间运算符，他们表示一个范围的值的便捷方式。</p>
<h5 id="闭区间运算符（a…b）定义了从a到b的一组范围，并且包含了a和b。a的值不能大于b。"><a href="#闭区间运算符（a…b）定义了从a到b的一组范围，并且包含了a和b。a的值不能大于b。" class="headerlink" title="闭区间运算符（a…b）定义了从a到b的一组范围，并且包含了a和b。a的值不能大于b。"></a>闭区间运算符（a…b）定义了从a到b的一组范围，并且包含了a和b。a的值不能大于b。</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(i)  <span class="comment">//循环打印出1～5的整数，包括1和5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于循环控制流的内容将在后续内容中出现。</p>
</blockquote>
<h5 id="半开区间运算符"><a href="#半开区间运算符" class="headerlink" title="半开区间运算符"></a>半开区间运算符</h5><p>半开区间运算符（a..&lt;b）定义了从a到b但不包括b的区间。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(i)  <span class="comment">//循环打印出1～4的整数,包括4，不包括5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单侧区间"><a href="#单侧区间" class="headerlink" title="单侧区间"></a>单侧区间</h5><p>单侧区间主要用在数组的遍历。当我们需要遍历数组中的指定索引前或者后的元素时可以使用单侧区间。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历数组items索引2后的所有元素</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items[<span class="number">2</span><span class="operator">...</span>]&#123;</span><br><span class="line">    <span class="built_in">print</span>(item) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历数组items索引2前的所有元素</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items[<span class="operator">...</span><span class="number">2</span>]&#123;</span><br><span class="line">    <span class="built_in">print</span>(item) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数组items索引2前的所有元素,不包括索引2的元素</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items[<span class="operator">..&lt;</span><span class="number">2</span>]&#123;</span><br><span class="line">    <span class="built_in">print</span>(item) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>三元条件运算符是一种有三部分的特殊运算符，它类似于 question ? answer1 : answer2。如果question为真，则会判断answer1并且返回它的值；否则它判断为answer2并且返回它的值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> question &#123;</span><br><span class="line">    answer1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    answer2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift 基础语法</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 中的集合类型</title>
    <url>/posts/5f278529.html</url>
    <content><![CDATA[<p>Swift 语言提供 <code>Arrays</code>、<code>Sets</code> 和 <code>Dictionaries</code> 三种基本的集合类型用来存储集合数据。<strong>数组（Arrays）</strong>是有序数据的集。<strong>集合（Sets）</strong>是无序无重复数据的集。<strong>字典（Dictionaries）</strong>是无序的键值对的集。</p>
<p>Swift 语言中的 <code>Arrays</code>、<code>Sets</code> 和 <code>Dictionaries</code> 中存储的数据值<strong>类型必须明确</strong>。这意味着我们不能把错误的数据类型插入其中。</p>
<span id="more"></span>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中，这意味着数组中的元素是可以重复的。</p>
<h5 id="创建一个空数组"><a href="#创建一个空数组" class="headerlink" title="创建一个空数组"></a>创建一个空数组</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someInts <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line"><span class="keyword">var</span> someStr:[<span class="type">String</span>] <span class="operator">=</span> []</span><br></pre></td></tr></table></figure>

<h5 id="创建一个带有默认值的数组"><a href="#创建一个带有默认值的数组" class="headerlink" title="创建一个带有默认值的数组"></a>创建一个带有默认值的数组</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeDouble <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">0.3</span>, count: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(threeDouble)</span><br></pre></td></tr></table></figure>

<p>这里我们使用<code>Array</code>默认构造方法创建了一个长度大小为3，初始元素值为0.3的双精度类型的数组。参数说明：</p>
<ul>
<li>repeating:初始时元素的值</li>
<li>count：元素的个数或者数组的长度</li>
</ul>
<p>此时，打印数组的显示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.3, 0.3, 0.3]</span><br></pre></td></tr></table></figure>

<h5 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h5><p>我们可以根据数组的索引来访问数组中的元素，不过需要注意的一点是数组的索引是从0开始的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nameArr <span class="operator">=</span> [<span class="string">&quot;Felix&quot;</span>,<span class="string">&quot;Zhao&quot;</span>,<span class="string">&quot;Rudolf&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一个元素<span class="subst">\(nameArr[<span class="number">0</span>])</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第二个元素<span class="subst">\(nameArr[<span class="number">1</span>])</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第三个元素<span class="subst">\(nameArr[<span class="number">1</span>])</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h5><h6 id="添加数组元素"><a href="#添加数组元素" class="headerlink" title="添加数组元素"></a>添加数组元素</h6><p>我们可以使用<code>append</code>方法或者赋值运算符<code>+=</code>将一个元素添加到数组的末尾。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">nameArr.append(<span class="string">&quot;Wells&quot;</span>)</span><br><span class="line">nameArr <span class="operator">+=</span> [<span class="string">&quot;Wells&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>此时的数组为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;Felix&quot;</span>, <span class="string">&quot;Zhao&quot;</span>, <span class="string">&quot;Rudolf&quot;</span>, <span class="string">&quot;Wells&quot;</span>, <span class="string">&quot;Wells&quot;</span>]</span><br></pre></td></tr></table></figure>

<h5 id="循环遍历数组"><a href="#循环遍历数组" class="headerlink" title="循环遍历数组"></a>循环遍历数组</h5><p>我们可以使用<code>for-in</code>循环来遍历数组中的每一个元素。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> nameArr &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们同时需要每个元素的值和对应的索引，我们可以使用<code>enumerate()</code>方法来遍历数组。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (index,name) <span class="keyword">in</span> nameArr.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前索引:<span class="subst">\(index)</span>,当前值：<span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">当前索引:<span class="number">0</span>,当前值：<span class="type">Felix</span></span><br><span class="line">当前索引:<span class="number">1</span>,当前值：<span class="type">Zhao</span></span><br><span class="line">当前索引:<span class="number">2</span>,当前值：<span class="type">Rudolf</span></span><br><span class="line">当前索引:<span class="number">3</span>,当前值：<span class="type">Wells</span></span><br></pre></td></tr></table></figure>

<h5 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h5><p>当我们有两个数据类型相同数组需要合并时，可以使用<code>+</code>运算符来合并数组。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nameArr <span class="operator">=</span> [<span class="string">&quot;Felix&quot;</span>,<span class="string">&quot;Zhao&quot;</span>,<span class="string">&quot;Rudolf&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> newNameArr <span class="operator">=</span> [<span class="string">&quot;Lily&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> newArr <span class="operator">=</span> newNameArr <span class="operator">+</span> nameArr</span><br></pre></td></tr></table></figure>

<p>此时，newArr的元素为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Felix&quot;</span>, <span class="string">&quot;Zhao&quot;</span>, <span class="string">&quot;Rudolf&quot;</span>]</span><br></pre></td></tr></table></figure>

<h5 id="数组相关属性"><a href="#数组相关属性" class="headerlink" title="数组相关属性"></a>数组相关属性</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(nameArr.count) </span><br><span class="line"><span class="built_in">print</span>(nameArr.isEmpty) </span><br></pre></td></tr></table></figure>

<p><code>.count</code>用来获取数组元素的个数；<code>.isEmpty</code>判断数组是否为空，返回值为布尔值。</p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Swift中的字典是一个用来存储无序的相同类型数据的集合。字典中每个值(value)对应一个唯一的键(key)，键被作为值在这个字典里的标识符。字典里的数据是没有具体顺序的，我们只能通过值对应的键来访问到这个数据。另外，字典中的键可以是整型或者字符串类型，但是一个字典里键的类型必须是唯一的。</p>
<h5 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h5><p>Swift中的字典使用<code>Dictionary&lt;Key,Value&gt;</code>的形式定义，其中<code>Key</code>是字典中键的数据类型，<code>Value</code>是字典中值的数据类型。我们使用这样形式来定义一个空的字典：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyDcit <span class="operator">=</span> <span class="type">Dictionary</span>&lt;<span class="type">String</span>,<span class="type">String</span>&gt;()</span><br></pre></td></tr></table></figure>

<p>Swift中也给我们提供了一种简化的语法来定义字典：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyDcit <span class="operator">=</span> [<span class="type">String</span>:<span class="type">String</span>]()</span><br></pre></td></tr></table></figure>

<p>两种方式都是定义了一个键和值都为字符串类型的空字典，在实际使用过程中，我们更多的是使用后面简化的定义方法。</p>
<p>在项目开发中，如果我们只需要定义一个字典，但是不需要对它进行初始化操作的话，我们可以使用下面的这中方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dic:[<span class="type">String</span>:<span class="type">String</span>]<span class="operator">!</span></span><br></pre></td></tr></table></figure>

<h5 id="字典的访问与修改"><a href="#字典的访问与修改" class="headerlink" title="字典的访问与修改"></a>字典的访问与修改</h5><p>我们可以根据键来修改字典中对应的值，我们也可以使用一些内置的方法来添加、删除元素。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countryDic:[<span class="type">String</span>:<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;JP&quot;</span>:<span class="string">&quot;日本&quot;</span>,<span class="string">&quot;CN&quot;</span>:<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;UK&quot;</span>:<span class="string">&quot;英国&quot;</span>,<span class="string">&quot;FR&quot;</span>:<span class="string">&quot;法国&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(countryDic[<span class="string">&quot;CN&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(countryDic[<span class="string">&quot;JP&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>在上面的实例代码中，我们定义了一个键为国家英文缩写，值为国家的中文简写。我们分别使用键<code>CN</code>和<code>JP</code>访问字典。</p>
<p>当我们需要字典中添加一个新的元素时候，可以使用以下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">countryDic[<span class="string">&quot;IN&quot;</span>] <span class="operator">=</span> <span class="string">&quot;印度&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们需要修改字典中的某个元素的值，使用以下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">countryDic[<span class="string">&quot;CN&quot;</span>] <span class="operator">=</span> <span class="string">&quot;中华人民共和国&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们发现，我们添加新的元素和修改原有元素的值的方法是一样的。这是因为当我们通过键去修改字典的时候，会根据键名先去查询字典中是否包含对应的键名，如果包含的话就修改对应的值，如果不包含就添加新的元素。</p>
<p>经过上面的添加和修改之后，此时的字典元素如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;UK&quot;</span>: <span class="string">&quot;英国&quot;</span>, <span class="string">&quot;JP&quot;</span>: <span class="string">&quot;日本&quot;</span>, <span class="string">&quot;FR&quot;</span>: <span class="string">&quot;法国&quot;</span>, <span class="string">&quot;CN&quot;</span>: <span class="string">&quot;中华人民共和国&quot;</span>, <span class="string">&quot;IN&quot;</span>: <span class="string">&quot;印度&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>我们经常会遇到根据键名去删除字典中对应的元素，这时，我们可以使用以下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">countryDic.removeValue(forKey: <span class="string">&quot;CN&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我们经常会使用到的方法还有：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> countryDic.index(countryDic.startIndex, offsetBy: <span class="number">1</span>)</span><br><span class="line">countryDic.remove(at: index)  <span class="comment">//根据指定的索引删除元素</span></span><br><span class="line">countryDic.removeAll() <span class="comment">//清空字典</span></span><br></pre></td></tr></table></figure>

<h5 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h5><p>在之前的学习中，我们使用了<code>for-in</code>循环来遍历数组，同样的我们也可以使用<code>for-in</code>来遍历字典，不同的是遍历字典返回的是每个元素对应的键和值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (key,value) <span class="keyword">in</span> countryDic &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;键：<span class="subst">\(key)</span>,值：<span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以值循环遍历出字典的键或者值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> countryDic.keys &#123;</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span>  countryDic.values &#123;</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，在学习数组的时候，我们使用<code>isEmpty</code>属性来判断一个数组是否为空，我们同样可以使用这个方法来判断字典是否为空。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>Swift 中的集合（Set）是一种无序的、不重复的数据结构，它允许你存储不同类型的元素。集合的主要用途是检查元素是否存在于集合中，因为集合中的<strong>元素是唯一</strong>的，所以当你尝试添加一个已经存在的元素时，集合不会发生变化。</p>
<h5 id="创建一个集合"><a href="#创建一个集合" class="headerlink" title="创建一个集合"></a>创建一个集合</h5><p>创建集合的常见方法是使用字面量语法或者初始化器（initializer）。下面是一些关于如何创建和使用集合的示例：</p>
<ol>
<li>使用字面量语法创建集合：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">Int</span>&gt;() <span class="comment">// 创建一个空的整数集合</span></span><br><span class="line"><span class="keyword">let</span> fruits <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">String</span>&gt;(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>) <span class="comment">// 创建一个包含三个字符串元素的集合</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用初始化器创建集合：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emptySet: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> [] <span class="comment">// 创建一个空的整数集合</span></span><br><span class="line"><span class="keyword">var</span> fruitsSet <span class="operator">=</span> <span class="type">Set</span>([<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>]) <span class="comment">// 创建一个包含三个字符串元素的集合</span></span><br><span class="line"><span class="keyword">var</span> mixedSet: <span class="type">Set</span>&lt;<span class="keyword">Any</span>&gt; <span class="operator">=</span> [<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>, <span class="number">3.14</span>] <span class="comment">// 创建一个包含整数和浮点数的混合类型集合</span></span><br></pre></td></tr></table></figure>

<h5 id="集合中元素的访问、修改和删除"><a href="#集合中元素的访问、修改和删除" class="headerlink" title="集合中元素的访问、修改和删除"></a>集合中元素的访问、修改和删除</h5><p>向集合中添加新的元素使用<code>insert</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">numbers.insert(<span class="number">1</span>) <span class="comment">// 添加一个元素到集合中</span></span><br><span class="line">fruits.insert(<span class="string">&quot;grape&quot;</span>) <span class="comment">// 向集合中添加一个元素，如果元素已经存在，则不会改变集合</span></span><br></pre></td></tr></table></figure>

<p>使用<code>remove</code> 方法移除集合中的元素：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">numbers.remove(<span class="number">1</span>) <span class="comment">// 从集合中移除一个元素，如果元素不存在，则不会改变集合</span></span><br><span class="line">fruits.remove(<span class="string">&quot;banana&quot;</span>) <span class="comment">// 从集合中移除一个元素，如果元素不存在，则不会改变集合</span></span><br></pre></td></tr></table></figure>

<h5 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h5><p>集合的遍历和数组的遍历类似，使用 <code>for-in</code>循环语句。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">    <span class="built_in">print</span>(number) <span class="comment">// 输出集合中的每个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> fruits &#123;</span><br><span class="line">    <span class="built_in">print</span>(fruit) <span class="comment">// 输出集合中的每个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="检查元素是否存在于集合中"><a href="#检查元素是否存在于集合中" class="headerlink" title="检查元素是否存在于集合中"></a>检查元素是否存在于集合中</h5><p>判断一个元素是否存在于集合中可以使用<code>contains</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> fruits.contains(<span class="string">&quot;apple&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;苹果存在于集合中&quot;</span>) <span class="comment">// 如果集合包含指定的元素，则输出相应的信息</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;苹果不存在于集合中&quot;</span>) <span class="comment">// 如果集合不包含指定的元素，则输出相应的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="获取集合的大小"><a href="#获取集合的大小" class="headerlink" title="获取集合的大小"></a>获取集合的大小</h5><p>获取集合的大小或元素的数量使用<code>count</code> 属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> size <span class="operator">=</span> fruits.count <span class="comment">// 获取集合中的元素个数</span></span><br></pre></td></tr></table></figure>

<h5 id="判断两个集合是否相等（即它们包含相同的元素）"><a href="#判断两个集合是否相等（即它们包含相同的元素）" class="headerlink" title="判断两个集合是否相等（即它们包含相同的元素）"></a>判断两个集合是否相等（即它们包含相同的元素）</h5><p>判断两个集合是否相等可以使用<code>==</code> 运算符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> setA <span class="operator">=</span> <span class="type">Set</span>([<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>])</span><br><span class="line"><span class="keyword">let</span> setB <span class="operator">=</span> <span class="type">Set</span>([<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>])</span><br><span class="line"><span class="keyword">let</span> isEqual <span class="operator">=</span> setA <span class="operator">==</span> setB <span class="comment">// 判断两个集合是否相等，如果相等则返回 true，否则返回 false</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift 基础语法</category>
      </categories>
      <tags>
        <tag>Foundation</tag>
        <tag>Swift</tag>
        <tag>集合类型</tag>
        <tag>数组</tag>
        <tag>集合</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 介绍</title>
    <url>/posts/ea0a67e1.html</url>
    <content><![CDATA[<h1 id="Swift-编程语言介绍"><a href="#Swift-编程语言介绍" class="headerlink" title="Swift 编程语言介绍"></a>Swift 编程语言介绍</h1><p>Swift 是一种强大且直观的编程语言，由 Apple Inc. 开发，用于 iOS, macOS, watchOS 和 tvOS 的应用开发。Swift 结合了 C 和 Objective-C 的优点，并且支持函数式编程，面向对象编程和泛型编程。它的目标是提供一种安全、高效、灵活和现代化的编程语言，可以让开发者创造出更快、更稳定、更易用的应用程序。</p>
<span id="more"></span>

<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Swift 强调类型安全和内存管理。它不允许隐式转换到不安全的类型，这可以防止许多常见的编程错误。此外，Swift 使用自动引用计数（ARC）来管理内存，减少了内存泄露的可能性。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Swift 旨在提供高性能的应用程序。它的编译器进行了优化，以提高运行速度和减少能源消耗。Swift 的语法糖也有助于编写简洁且高效的代码。</p>
<h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><p>Swift 的语法清晰简洁，易于学习和使用。它的设计哲学是“简单就是美”，使得 Swift 代码既美观又易读。</p>
<h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p>Swift 是开源的，这意味着开发者可以查看和修改其源代码。这使得 Swift 成为一个活跃的社区项目，不断有新的功能和改进加入其中。</p>
<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>Swift 是一种静态类型语言，这意味着你在编写代码时必须为每个变量明确指定类型。这可以避免许多类型错误，并使得代码更加易于理解和维护。</p>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>Swift 完全支持面向对象编程，包括类、结构体、协议、继承和多态等概念。它也支持协议扩展，这使得你可以向现有类添加新的方法或者属性，而无需改变原有的代码。</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>Swift 同时支持函数式编程和面向对象编程。你可以在函数中使用闭包，这为处理异步事件或者创建高阶函数提供了强大的工具。</p>
<h3 id="Playgrounds"><a href="#Playgrounds" class="headerlink" title="Playgrounds"></a>Playgrounds</h3><p>Xcode 集成了一个强大的交互式编程环境——Playgrounds。你可以在 Playgrounds 中尝试 Swift 的各种特性，而无需创建完整的项目。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Swift 是一种强大、直观且安全的编程语言，它专注于提供最好的用户体验和性能。无论你是初学者还是有经验的开发者，Swift 都能帮助你更有效地编写代码。</p>
]]></content>
      <categories>
        <category>Swift 基础语法</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 控件之 Text</title>
    <url>/posts/c90f7d11.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在 SwiftUI 中，如果我们想要显示文本内容，可以使用 <strong>Text</strong> 控件。</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="常用的属性设置"><a href="#常用的属性设置" class="headerlink" title="常用的属性设置"></a>常用的属性设置</h3><h4 id="设置文字的颜色"><a href="#设置文字的颜色" class="headerlink" title="设置文字的颜色"></a>设置文字的颜色</h4><p>通过<code>foregroundColor</code> 设置文字的颜色：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">     .foregroundColor(.black)</span><br></pre></td></tr></table></figure>

<p>**<span style="color:red">注意</span>**，在 <span style="color:red"> Xcode 15.0</span>中，Apple 更推荐我们使用下面的方式设置文字的颜色，而且上面的修饰器将会在不久后被移除：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">    .foregroundStyle(.black)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="设置字体的大小"><a href="#设置字体的大小" class="headerlink" title="设置字体的大小"></a>设置字体的大小</h4><p>通过 <code>font</code> 设置字体的大小：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">    .foregroundStyle(.black)</span><br><span class="line">    .font(.title)</span><br></pre></td></tr></table></figure>

<p>在上面代码中，我们直接使用了Apple 已经设计好的 <strong>Dynamic Type sizes</strong> 字体大小，详细介绍可以在 <a href="">《Human Interface Guidelines》</a>中找到  <a href="https://developer.apple.com/design/human-interface-guidelines/typography#iOS-iPadOS-Dynamic-Type-sizes">iOS, iPadOS Dynamic Type sizes</a>。</p>
<p>除了使用 Apple 设计的动态尺寸大小的字体，我们也可以使用下面的方式定义字体的大小：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.font(.system(size: <span class="number">12</span>))</span><br></pre></td></tr></table></figure>

<h4 id="设置字重"><a href="#设置字重" class="headerlink" title="设置字重"></a>设置字重</h4><p>设置字重可以使用 <code>fontWeight</code> :</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.fontWeight(.bold)</span><br></pre></td></tr></table></figure>

<p>如果只是对字体进行<strong>加粗</strong>操作，可以直接使用下面的<strong>修饰器</strong> ：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.bold()</span><br></pre></td></tr></table></figure>

<p><strong><span style="color:red">注意</span></strong> ，上面的两种设置字重的方式均只能在 <span style="color:red">iOS 16.0</span> 之后的系统中可用。</p>
<h4 id="设置字体的对齐方式"><a href="#设置字体的对齐方式" class="headerlink" title="设置字体的对齐方式"></a>设置字体的对齐方式</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.multilineTextAlignment(.leading) <span class="comment">// 多行文本左对齐 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>.center</code>： 居中对齐；</li>
<li><code>.leading</code> ： 左对齐；</li>
<li><code>.trailing</code>： 右对齐。</li>
</ul>
<h4 id="限制文本显示的行数"><a href="#限制文本显示的行数" class="headerlink" title="限制文本显示的行数"></a>限制文本显示的行数</h4><p>默认的情况下， <strong>Text</strong> 会完整的显示我们提供的字符串内容，在一些情况下我们需要限定最多所能显示的行数，可以使用<code>lineLimit</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.lineLimit(<span class="number">2</span>) <span class="comment">// 最多只能显示两行</span></span><br></pre></td></tr></table></figure>

<p>限制文本显示的行数后，多余的文本将会被隐藏，然后以 <strong>…</strong> 的方式结尾。</p>
<h4 id="设置内边距和行间距"><a href="#设置内边距和行间距" class="headerlink" title="设置内边距和行间距"></a>设置内边距和行间距</h4><p>当<code>Text</code> 中的文本内容超过多行的时候，我们可以使用<code>padding</code>和<code>lineSpacing</code>修饰器来设置文本的行间距和内边距。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Swift is a powerful and intuitive programming language for all Apple platforms. It’s easy to get started using Swift, with a concise-yet-expressive syntax and modern features you’ll love. Swift code is safe by design and produces software that runs lightning-fast.&quot;</span>)</span><br><span class="line">               .padding()</span><br><span class="line">               .lineSpacing(<span class="number">10</span>)</span><br><span class="line">               .fontWeight(.bold)</span><br></pre></td></tr></table></figure>

<h4 id="旋转字体"><a href="#旋转字体" class="headerlink" title="旋转字体"></a>旋转字体</h4><p> SwiftUI 给我们提供了一个<code>rotateEffec</code> 修饰器来帮助我们简单的实现文本的旋转。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.rotationEffect(.degrees(<span class="number">45</span>)) <span class="comment">// 顺时针旋转 45°</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，将按照文本的中心作为锚点进行旋转，我们也可以指定旋转的锚点，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.rotationEffect(.degrees(<span class="number">45</span>),anchor: .topLeading) <span class="comment">//以左上角的点作为锚点顺时针旋转 45°</span></span><br></pre></td></tr></table></figure>

<p><code>rotationEffect</code> 实现的是 2D 的旋转效果，SwiftUI 还提供了 <code>rotation3DEffect</code>修饰器来实现一个 3D 的旋转效果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.rotation3DEffect(.degrees(<span class="number">60</span>),axis: (x:<span class="number">1.0</span>, y:<span class="number">0</span>, z:<span class="number">0</span>)) <span class="comment">// 绕着 X 轴旋转 60°</span></span><br></pre></td></tr></table></figure>

<h4 id="给文字添加阴影"><a href="#给文字添加阴影" class="headerlink" title="给文字添加阴影"></a>给文字添加阴影</h4><p>如果想要给文字添加阴影，可以使用<code>shadow</code>修饰器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.shadow(color:.gray, radius: <span class="number">2</span>,x: <span class="number">0</span>, y: <span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p><code>shadow</code>可以设置颜色、圆角、x轴和 y 轴多个参数。</p>
<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309301052661.png" style="zoom:10%"/>

<h4 id="使用自定义的字体"><a href="#使用自定义的字体" class="headerlink" title="使用自定义的字体"></a>使用自定义的字体</h4><p>在一下 app 中，我们可能想要使用自定义的字体而不是系统的字体。例如，我们想要使用<a href="https://fonts.google.com/specimen/Nunito">https://fonts.google.com/specimen/Nunito</a> 字体作为我们 app 的字体。那么我们就需要自定义 app 使用的字体。</p>
<p>首先，我们需要下载我们要使用的字体。一般情况下，字体都会提供多种样式，例如常规（regular）、加粗（bold）或者黑体（black）。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309301101260.png" style="zoom:20%"/>

<p>我们可以根据自己的需要将指定样式的字体加入的到我们的app 项目中。例如，我们这里只需要使用常规（regular）字体，那么我将 <strong>Nunito-Regular.ttf</strong>这个文件拖入到项目中即可。拖入时，注意勾选下面的选项：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309301106752.png" style="zoom:30%"/>

<p>然后在项目的<strong>Info</strong>配置选项的<strong>Custom iOS Target Properties</strong>中添加字体的配置项，如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309301110667.png" style="zoom:30%"/>

<p>接着就是使用我们添加的字体：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.font(.custom(<span class="string">&quot;Nunito&quot;</span>, size: <span class="number">20</span>))</span><br></pre></td></tr></table></figure>

<p>此时我们的字体效果就出现了。但是需要注意的一点就是，因为我们只添加了常规样式的字体到我们的 app 中，所以即使我们给文本添加了<code>.fontWeight(.bold)</code> 加粗的修饰器，文本依然只显示常规样式，除非我们把加粗的字体也添加到app 中。</p>
<h4 id="展示-Markdown-格式的文本内容"><a href="#展示-Markdown-格式的文本内容" class="headerlink" title="展示 Markdown 格式的文本内容"></a>展示 Markdown 格式的文本内容</h4><p>Markdown 是一种轻量级的标记语言，被开发者们广泛使用。在 SwiftUI 中，<strong>Text</strong> 也支持将这个标记语言编辑的文本格式化为我们常见的文本内容。例如，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;**这是一段使用markdown编辑的加粗文本内容**。<span class="subst">\n</span> 下面这是一个链接，如果使用模拟器运行点击后可以直接使用Safari浏览器打开。[Swift 博文](https://zhaofelix.github.io/swift-blogs)&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309301122891.png" style="zoom:50%"/>

<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://developer.apple.com/documentation/swiftui/text">Text | Apple Developer Documentation</a></p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Text</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 中的基础动画和过渡（一）</title>
    <url>/posts/b2c22197.html</url>
    <content><![CDATA[<p>SwiftUI 给我们提供了两种动画的实现方式： <strong>隐式(implicit)动画</strong> 和<strong>显式(explicit)动画</strong>。这两种动画方式都可以让我们给视图添加动画和过渡。<strong>隐式动画</strong>通过修饰器<code>animation</code>给视图添加动画效果，<strong>显式动画</strong>则是使用<code>withAnimation</code>代码块的方式添加到视图。</p>
<h3 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> circleColor: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> heartColor: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> heartSize: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span>() &#123;</span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">150</span>, height: <span class="number">150</span>)</span><br><span class="line">                .foregroundStyle(circleColor <span class="operator">?</span>  <span class="type">Color</span>(.systemGray5) : .red)</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;heart.fill&quot;</span>)</span><br><span class="line">                .foregroundStyle(heartColor <span class="operator">?</span>  .red : .white)</span><br><span class="line">                .font(.system(size: <span class="number">80</span>))</span><br><span class="line">                .scaleEffect(heartSize <span class="operator">?</span> <span class="number">1.0</span> : <span class="number">0.5</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            <span class="comment">// 每次点击之后，三个状态值都进行取反操作</span></span><br><span class="line">            circleColor.toggle()</span><br><span class="line">            heartColor.toggle()</span><br><span class="line">            heartSize.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们实现了：</p>
<ol>
<li>使用<code>@State</code>定义了三个状态变量，用来控制圆的颜色、❤️的颜色以及大小；</li>
<li>使用<code>Circle</code>绘制了一个圆，然后在这个圆显示一个系统的图标，将二者使用<code>ZStack</code>进行组合；</li>
<li>给<code>ZStack</code>添加 一个点击手势<code>onTapGesture</code>，每次点击都对三个状态值进行取反操作，即<code>toggle</code>；</li>
<li>运用<strong>三目运算符</strong> 根据不同的状态值显式不同的颜色和大小。</li>
</ol>
<span id="more"></span>

<p>具体效果如下：</p>
<p><video width="20%" height="50%" controls="controls" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310141544030.mp4"> </video></p>
<p>通过上面的效果我们会发现，每次点击之后对应视图的颜色和大小都会发生变化，但是这个变化是比较生硬的，这是因为我们没有给视图添加动画的原因。接着我们就分别给<code>Circle</code>和<code>Image</code>添加一个隐式的动画效果，即给每一个视图添加一个<code>animation</code>修饰器。</p>
<p><code>Circle</code>的动画如下 ：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.animation(.easeInOut, value: circleColor)</span><br></pre></td></tr></table></figure>

<p><code>Image</code>的动画如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.animation(.easeInOut, value: heartColor)</span><br></pre></td></tr></table></figure>

<p>这里我们使用的<code>animation</code>修饰器需要两个参数，一个是动画类型，另一个是对应的一个动态变量的值。它的含义是当对应状态变量的值发生变化时，实现相关的动画效果。</p>
<p>此时的点击切换效果如下：</p>
<p><video width="20%" controls="controls" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310141554539.mp4"></video></p>
<p>SwiftUI 中给我们提供了很多种的动画类型，包括各种的<code>ease</code>、<code>linear</code>、<code>spring</code>等。关于不同的<code>ease</code>动画，可以到<a href="https://easings.net/">Easing Functions Cheat Sheet (easings.net)</a> 查看。</p>
<h3 id="显式动画"><a href="#显式动画" class="headerlink" title="显式动画"></a>显式动画</h3><p>上面的动画效果，我们同样可以使用<strong>显式动画</strong>来实现，在<code>onTapGesture</code>中将三个状态值的取反操作包裹在一个<code>withAnimation</code>代码块中，即：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">withAnimation &#123;</span><br><span class="line">                circleColor.toggle()</span><br><span class="line">                heartColor.toggle()</span><br><span class="line">                heartSize.toggle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时点击，视图已经有了一个默认的动画效果。当然，我们也可以去定义动画的类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">withAnimation(.spring(duration: <span class="number">1.2</span>, bounce: <span class="number">1</span>, blendDuration: <span class="number">3</span>) &#123;</span><br><span class="line">               circleColor.toggle()</span><br><span class="line">               heartColor.toggle()</span><br><span class="line">               heartSize.toggle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><video width="20%" controls="controls" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310141628100.mp4"> </video></p>
<p>在显式动画中，我们能很好的控制视图的动画效果。例如，如果我们不希望给❤️图标的大小变化添加任何的动画效果，只需要把<code>heartSize.toggle()</code>这行代码移到<code>withAnimation</code>代码块外面即可。如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">withAnimation(.spring(duration: <span class="number">1.2</span>, bounce: <span class="number">1</span>, blendDuration: <span class="number">3</span>) &#123;</span><br><span class="line">                circleColor.toggle()</span><br><span class="line">                heartColor.toggle()</span><br><span class="line">            &#125;</span><br><span class="line">heartSize.toggle()</span><br></pre></td></tr></table></figure>

<p>如果我们想要在<strong>隐式动画</strong> 中实现和上面同样的效果，我们可以通过重新排序修饰器的方式来进行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> circleColor: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> heartColor: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> heartSize: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span>() &#123;</span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">150</span>, height: <span class="number">150</span>)</span><br><span class="line">                .foregroundStyle(circleColor <span class="operator">?</span>  <span class="type">Color</span>(.systemGray5) : .red)</span><br><span class="line">                .animation(.spring(duration: <span class="number">1.0</span>, bounce: <span class="number">1</span>,blendDuration: <span class="number">3</span>), value: circleColor)</span><br><span class="line">          </span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;heart.fill&quot;</span>)</span><br><span class="line">                .foregroundStyle(heartColor <span class="operator">?</span>  .red : .white)</span><br><span class="line">                .font(.system(size: <span class="number">80</span>))</span><br><span class="line">                .animation(.spring(duration: <span class="number">1.0</span>, bounce: <span class="number">1</span>,blendDuration: <span class="number">3</span>), value: heartColor)</span><br><span class="line">                .scaleEffect(heartSize <span class="operator">?</span> <span class="number">0.7</span> : <span class="number">0.5</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            circleColor.toggle()</span><br><span class="line">            heartColor.toggle()</span><br><span class="line">            heartSize.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，针对<code>Image</code>的动画，我们将<code>animation</code>修饰器放在了<code>scaleEffect</code> 前面，那么当对应的状态值<code>heartColor</code>发生变化时这个动画效果就不会作用在<code>scaleEffect</code>上，即❤️的图标不会有尺寸变化的效果。</p>
]]></content>
      <categories>
        <category>SwiftUI 进阶</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>withAnimation</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 中的基础动画和过渡（二）</title>
    <url>/posts/a0094105.html</url>
    <content><![CDATA[<p>在上一篇文章中，我们已经介绍了 SwiftUI 中的<strong>隐式动画</strong>和<strong>显式动画</strong>。</p>
<p>在 SwiftUI中，只需要更多的关注动画的开始和结束，动画的过程由 SwiftUI 帮我们自动完成。接着我们来实现一些常见的动画效果。</p>
<h3 id="创建一个加载动画"><a href="#创建一个加载动画" class="headerlink" title="创建一个加载动画"></a>创建一个加载动画</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isLoading: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span>() &#123;</span><br><span class="line">          <span class="type">Circle</span>()</span><br><span class="line">                .trim(from: <span class="number">0</span>, to: <span class="number">0.8</span>)</span><br><span class="line">                .stroke(lineWidth: <span class="number">10</span>)</span><br><span class="line">                .fill(.green)</span><br><span class="line">                .rotationEffect(.degrees(isLoading <span class="operator">?</span>  <span class="number">360</span> : <span class="number">0</span>))</span><br><span class="line">                .animation(.default.repeatForever(autoreverses: <span class="literal">false</span>), value: isLoading)</span><br><span class="line">        &#125;</span><br><span class="line">        .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">        .onAppear &#123;</span><br><span class="line">            isLoading <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>



<p>在上面的代码中，</p>
<ol>
<li>使用 <code>Circle</code>创建了一个非闭合的圆环；</li>
<li>给<code>Cricle</code>添加了<code>rotationEffect</code>修饰器实现旋转的效果，它需要一个角度作为参数；</li>
<li>给<code>Circle</code>添加了<strong>隐式动画</strong>和动态变量<code>isLoading</code>进行绑定；</li>
<li>当整个视图显式的时候，将动态变量<code>isLoading</code>的值改为<code>true</code>，开始动画；</li>
</ol>
<p>这里的<code>animation</code>动画的效果我们使用的是默认<code>default</code>，然后链式调用了 <code>repeatForever</code>方法，这个方法中可以设置动画是否反转。</p>
<p>不反转：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310160942851.gif" />

<p>反转：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310160943712.gif"/>

<p>即设置为反转后，动画结束后会回到动画开始前的效果。</p>
<p>如果我们想要改变动画的速度，只需要将默认<code>default</code>动画设置为<code>linear</code>，然后修改<code>duration</code>参数即可。如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.animation(.linear(duration: <span class="number">1</span>).repeatForever(autoreverses: <span class="literal">false</span>), value: isLoading)</span><br></pre></td></tr></table></figure>

<p><strong><code>duration</code>值越大，动画速度越慢，即持续时间越长。</strong></p>
<p>另外，<code>onAppear</code>修饰器是 SwiftUI 中视图的生命周期函数，类似于 UIKit的中<code>viewDidAppear</code>方法，它的作用是当视图出现在屏幕是自动调用。</p>
<p>类似地，我们可以对代码稍加修改即可实习下面的这样效果：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310160958398.gif"/>

<p>修改后的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isLoading: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span>() &#123;</span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .stroke(lineWidth: <span class="number">10</span>)</span><br><span class="line">                .fill(<span class="type">Color</span>(.systemGray5))</span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .trim(from: <span class="number">0</span>, to: <span class="number">0.2</span>)</span><br><span class="line">                .stroke(lineWidth: <span class="number">10</span>)</span><br><span class="line">                .fill(.green)</span><br><span class="line">                .rotationEffect(.degrees(isLoading <span class="operator">?</span> <span class="number">360</span> : <span class="number">0</span>))</span><br><span class="line">                .animation(.linear(duration: <span class="number">1</span>).repeatForever(autoreverses: <span class="literal">false</span>), value: isLoading)</span><br><span class="line">        &#125;</span><br><span class="line">        .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">        .onAppear &#123;</span><br><span class="line">            isLoading <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="动画延迟"><a href="#动画延迟" class="headerlink" title="动画延迟"></a>动画延迟</h3><p>通过设置<code>duration</code>可以修改动画的速度，同样地可以通过设置<code>delay</code>来设置的延迟效果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isLoading: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span>() &#123;</span><br><span class="line">            <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">4</span>, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                <span class="type">Circle</span>()</span><br><span class="line">                    .fill(.green)</span><br><span class="line">                    .frame(width: <span class="number">10</span>, height: <span class="number">10</span>)</span><br><span class="line">                    .scaleEffect(isLoading <span class="operator">?</span> <span class="number">0.3</span> : <span class="number">1</span>)</span><br><span class="line">                    .animation(.linear(duration: <span class="number">0.6</span>).repeatForever(autoreverses: <span class="literal">true</span>).delay(<span class="number">0.2</span> <span class="operator">*</span> <span class="type">Double</span>(index)), value: isLoading)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .onAppear &#123;</span><br><span class="line">            isLoading <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用<code>ForEach</code>创建了四个相同的<code>Circle</code>，然后都给它们添加了一个大小改变的修饰器<code>sacleEffect</code>，动画效果我们设置为<code>linear</code>，链式调用了<code>repeatForever</code>和<code>deplay</code>方法。</p>
<p><code>delay</code>通过<code>0.2*Double(index)</code>设置，即四个<code>Circle</code>的延迟动画时间分别为：0，0.2，0.4，0.6。通过设置延迟时间，可以让<code>Circle</code>动画的开始时间不同。 如果没有这个延迟时间，所有的<code>Circle</code>都将同时开始出现动画效果。</p>
<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310161007140.gif"/>



<h3 id="矩形变换为圆"><a href="#矩形变换为圆" class="headerlink" title="矩形变换为圆"></a>矩形变换为圆</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> recordBegin: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> recording: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: recordBegin <span class="operator">?</span> <span class="number">30</span> : <span class="number">5</span>)</span><br><span class="line">                .fill(recordBegin <span class="operator">?</span> .red : .green)</span><br><span class="line">                .frame(width: recordBegin <span class="operator">?</span> <span class="number">60</span> : <span class="number">240</span>, height: <span class="number">60</span>)</span><br><span class="line">                .overlay &#123;</span><br><span class="line">                    <span class="type">Image</span>(systemName: <span class="string">&quot;mic.fill&quot;</span>)</span><br><span class="line">                        .font(.title)</span><br><span class="line">                        .foregroundStyle(.white)</span><br><span class="line">                        .scaleEffect(recording <span class="operator">?</span> <span class="number">0.7</span> : <span class="number">1.0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: recordBegin <span class="operator">?</span>  <span class="number">35</span> : <span class="number">10</span>)</span><br><span class="line">                .trim(from: <span class="number">0</span>, to: recordBegin <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">                .stroke(lineWidth: <span class="number">5</span>)</span><br><span class="line">                .fill(.green)</span><br><span class="line">                .frame(width: recordBegin <span class="operator">?</span> <span class="number">70</span> : <span class="number">250</span>, height: <span class="number">70</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            withAnimation(.linear(duration: <span class="number">0.3</span>)) &#123;</span><br><span class="line">                recordBegin.toggle()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            withAnimation(.default.repeatForever().delay(<span class="number">0.5</span>)) &#123;</span><br><span class="line">                recording.toggle()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们通过两个状态变量控制<code>RoundedRectangle</code>的<code>frame</code>和<code>cornerRadius</code>来实现一个圆角矩形到圆的变换效果。</p>
<p>效果如下：</p>
<p><video width="30%" controls="controls" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310161058603.mp4"></video></p>
]]></content>
      <categories>
        <category>SwiftUI 进阶</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>withAnimation</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 之 List 常见设置</title>
    <url>/posts/4c9505b9.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，<strong>List</strong> 是非常常用的一个组件。它可以帮助我们快速实现一个列表视图。</p>
<p>假设，我们现在下面这样的一个<strong>List</strong>示例：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310231554363.png" style="zoom:10%"/>

<p>示例代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> books: [<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;三国演义&quot;</span>,<span class="string">&quot;水浒传&quot;</span>, <span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;西游记&quot;</span>]</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">List</span>(books, id: \.<span class="keyword">self</span>) &#123; book <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(book)</span><br><span class="line">            &#125;</span><br><span class="line">            .listStyle(.in<span class="keyword">set</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对<strong>List</strong>，我们可以进行很多的样式设置。</p>
<span id="more"></span>

<h3 id="改变-List-中分割线的颜色"><a href="#改变-List-中分割线的颜色" class="headerlink" title="改变 List 中分割线的颜色"></a>改变 List 中<span style="color:red">分割线</span>的颜色</h3><p>默认情况下，<strong>List</strong>中分割线的颜色默认的灰色。想改变它的默认颜色，可以使用下面的这个修饰器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.listRowSeparatorTint(.green)</span><br></pre></td></tr></table></figure>

<p>但是，这这里需要<span style="color:red"><strong>注意</strong></span>的一点就是，这个修饰器我们需要添加到<code>List</code>里面的子视图中，在本示例中为<code>Text</code>，即</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(book)</span><br><span class="line">     .listRowSeparatorTint(.green)</span><br></pre></td></tr></table></figure>

<h3 id="隐藏分割线"><a href="#隐藏分割线" class="headerlink" title="隐藏分割线"></a>隐藏分割线</h3><p>隐藏<code>List</code>中的分割线可以使用<code>listRowSeparator</code>修饰器，它的参数为<code>hidden</code>或<code>visible</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.listRowSeparator(.hidden)</span><br></pre></td></tr></table></figure>

<h3 id="自定义-List-滚动区域的背景"><a href="#自定义-List-滚动区域的背景" class="headerlink" title="自定义 List 滚动区域的背景"></a>自定义 List 滚动区域的背景</h3><p>在 <strong>iOS 16</strong> 之后，<code>List</code>支持自定义它的背景。例如，如果我们要想给 <code>List</code>添加一个背景色：</p>
<p>首先，需要隐藏<code>List</code>的滚动内容背景，即</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.scrollContentBackground(.hidden)</span><br></pre></td></tr></table></figure>

<p>然后，可以使用<code>background</code>修饰器设置新的背景：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.background(</span><br><span class="line">                <span class="comment">// 使用渐变色作为背景</span></span><br><span class="line">                <span class="type">LinearGradient</span>(colors: [.red, .green], startPoint: .top, endPoint: .center)</span><br><span class="line">            )</span><br></pre></td></tr></table></figure>

<p>此时，效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310231645149.png" style="zoom:20%"/>

<p>如果想要让<code>List</code>的显示内容也使用我们自定义的背景颜色，可以让<code>List</code>中的每一行颜色都变为透明色即可</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.listRowBackground(<span class="type">Color</span>.clear)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310231652348.png" style="zoom:10%"/>

<p>完整代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> books: [<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;三国演义&quot;</span>,<span class="string">&quot;水浒传&quot;</span>, <span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;西游记&quot;</span>]</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">List</span>(books, id: \.<span class="keyword">self</span>) &#123; book <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(book)</span><br><span class="line">                    .listRowSeparator(.visible)</span><br><span class="line">                    .listRowBackground(<span class="type">Color</span>.clear)</span><br><span class="line">                    .foregroundStyle(.white)</span><br><span class="line">                    .bold()</span><br><span class="line">                    .listRowSeparatorTint(.white.opacity(<span class="number">0.5</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            .scrollContentBackground(.hidden)</span><br><span class="line">            .background(</span><br><span class="line">                <span class="comment">// 使用渐变色作为背景</span></span><br><span class="line">                <span class="type">LinearGradient</span>(colors: [.red, .green], startPoint: .top, endPoint: .center)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 之使用 Path 和 Shape 进行形状绘制</title>
    <url>/posts/cde0e673.html</url>
    <content><![CDATA[<h3 id="了解-Path"><a href="#了解-Path" class="headerlink" title="了解 Path"></a>了解 Path</h3><p>在 SwiftUI 中，如果想要绘制线条或者形状，可以使用<strong>Path</strong>，<strong>Path</strong> 是一个结构体用来实现2D 形状的绘制。</p>
<p>如果我们想要绘制下面的形状，</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310100930158.png" style="zoom:20%"/>

<p>代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span>() &#123; path <span class="keyword">in</span></span><br><span class="line">          path.move(to: <span class="type">CGPoint</span>(x: <span class="number">20</span>, y: <span class="number">20</span>))</span><br><span class="line">          path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">300</span>, y: <span class="number">20</span>))</span><br><span class="line">          path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">300</span>, y: <span class="number">200</span>))</span><br><span class="line">          path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">20</span>, y: <span class="number">200</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      .fill(.green) <span class="comment">// 填充色</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在上面的代码中：</p>
<ol>
<li>使用<code>move</code>明确形状起点为<code>(20,20)</code>；</li>
<li>使用<code>addLine</code>绘制点<code>(20,20)</code>到点<code>(300,20)</code>的线 ；</li>
<li>使用<code>addLine</code>绘制点<code>(300,20)</code>到点<code>(300,200)</code>的线 ；</li>
<li>使用<code>addLine</code>绘制点<code>(300,200)</code>到点<code>(20,200)</code>的线 ；</li>
<li>使用<code>fill</code>进行形状的颜色填充。</li>
</ol>
<h3 id="使用-Stroke-绘制形状边框"><a href="#使用-Stroke-绘制形状边框" class="headerlink" title="使用 Stroke 绘制形状边框"></a>使用 Stroke 绘制形状边框</h3><p>有时候，绘制的形状我们不一定是需要完全填充的，我们仅仅需要使用线条呈现出形状即可。这样的效果可以使用<code>stroke</code>修饰器实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span>() &#123;path <span class="keyword">in</span></span><br><span class="line">               path.move(to: <span class="type">CGPoint</span>(x: <span class="number">20</span>, y: <span class="number">20</span>))</span><br><span class="line">               path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">300</span>, y: <span class="number">20</span>))</span><br><span class="line">               path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">300</span>, y: <span class="number">200</span>))</span><br><span class="line">               path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">20</span>, y: <span class="number">200</span>))</span><br><span class="line">           &#125;</span><br><span class="line">           .stroke(.green, lineWidth: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p><code>stroke</code>提供了线条颜色和线条宽度两个参数。</p>
<p>此时的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310100940054.png" style="zoom:40%"/>

<p>我们会发现此时的形状有一边是缺失的，在使用<code>fill</code>修饰器的时候，因为是整个面积都使用了颜色进行填充，所以我们没有发现这个问题。为什么会出现这样的问题呢，如果我们再去回看我们绘制形状的步骤，我们会发现我们并没有添加点<code>(20,200)</code>和点<code>(20,20)</code>的线。</p>
<p>解决这个问题有两中方法，一是添加回到起点的线：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">20</span>, y: <span class="number">20</span>))</span><br></pre></td></tr></table></figure>

<p>另一种就是使用<code>Path</code>提供了方法，让形状自动闭合：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">path.closeSubpath()</span><br></pre></td></tr></table></figure>

<h3 id="绘制Curves"><a href="#绘制Curves" class="headerlink" title="绘制Curves"></a>绘制Curves</h3><p><code>Path</code>内置的很多 API 可以帮助我们绘制很多的形状，不仅仅是局限于直线。<code>addQuadCurve</code>、<code>addCurve</code>和<code>addArc</code>可以帮助我们绘制曲线和圆弧。</p>
<p>如果我们想要绘制下面的形状效果，就可以使用<code>addQuadCurve</code>方法，这个方法需要两个参数<strong>锚点</strong>和<strong>控制点</strong>。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310100952816.png" style="zoom:30%"/>

<p>针对上面的曲线部分，它有两个锚点，分别是<code>(40,60)</code>和<code>(210,60)</code>， 它的控制点是<code>(125,0)</code>。当然，控制点是不是固定的，我们可以通过调节控制点的坐标来实现不同的曲线效果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span>() &#123;path <span class="keyword">in</span></span><br><span class="line">               path.move(to: <span class="type">CGPoint</span>(x: <span class="number">20</span>, y: <span class="number">60</span>))</span><br><span class="line">               path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">40</span>, y: <span class="number">60</span>))</span><br><span class="line">               path.addQuadCurve(to: <span class="type">CGPoint</span>(x: <span class="number">210</span>, y: <span class="number">60</span>), control: <span class="type">CGPoint</span>(x: <span class="number">125</span>, y: <span class="number">0</span>))</span><br><span class="line">               path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">230</span>, y: <span class="number">60</span>))</span><br><span class="line">               path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">230</span>, y: <span class="number">100</span>))</span><br><span class="line">               path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">20</span>, y: <span class="number">100</span>))</span><br><span class="line">               path.closeSubpath()</span><br><span class="line">           &#125;</span><br><span class="line">           .fill(.purple)</span><br></pre></td></tr></table></figure>

<h3 id="绘制圆弧和饼状图"><a href="#绘制圆弧和饼状图" class="headerlink" title="绘制圆弧和饼状图"></a>绘制圆弧和饼状图</h3><p>如果我们想要绘制圆弧或者饼状图，可以使用<code>addArc</code>方法。<code>addArc</code>方法需要多个参数，包括<strong>中心点</strong>、<strong>半径</strong>、<strong>开始角度</strong>、<strong>结束角度</strong>以及<strong>绘制方向</strong>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span>() &#123; path <span class="keyword">in</span></span><br><span class="line">             path.move(to: <span class="type">CGPoint</span>(x: <span class="number">200</span>, y: <span class="number">200</span>))</span><br><span class="line">             path.addArc(center: <span class="type">CGPoint</span>(x: <span class="number">200</span>, y: <span class="number">200</span>), radius: <span class="number">150</span>, startAngle: .degrees(<span class="number">0</span>), endAngle: .degrees(<span class="number">60</span>), clockwise: <span class="literal">true</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         .fill(.green)</span><br></pre></td></tr></table></figure>

<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310101029654.png" style="zoom:30%"/>



<h3 id="使用形状创建一个进度条指示器"><a href="#使用形状创建一个进度条指示器" class="headerlink" title="使用形状创建一个进度条指示器"></a>使用形状创建一个进度条指示器</h3><p>首先，使用<code>LinearGradient</code>定义一个渐变色：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进度条渐变色</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> purpleGradient <span class="operator">=</span> <span class="type">LinearGradient</span>(gradient: <span class="type">Gradient</span>(colors: [</span><br><span class="line">      <span class="type">Color</span>(red:<span class="number">207</span><span class="operator">/</span><span class="number">255</span> , green: <span class="number">207</span><span class="operator">/</span><span class="number">255</span>, blue: <span class="number">207</span><span class="operator">/</span><span class="number">255</span>),</span><br><span class="line">      <span class="type">Color</span>(red:<span class="number">107</span><span class="operator">/</span><span class="number">255</span> , green: <span class="number">116</span><span class="operator">/</span><span class="number">255</span>, blue: <span class="number">179</span><span class="operator">/</span><span class="number">255</span>)</span><br><span class="line">  ]), startPoint: .trailing, endPoint: .leading)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>使用内置形状<code>Circle</code>绘制一个圆：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Circle</span>()</span><br><span class="line">              .stroke(<span class="type">Color</span>(.systemGray6), lineWidth: <span class="number">10</span>)</span><br><span class="line">              .frame(width: <span class="number">300</span>, height: <span class="number">300</span>)</span><br></pre></td></tr></table></figure>

<p>接着，在灰色圆的上面再添加一个使用渐变色定义的圆：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Circle</span>()</span><br><span class="line">               .trim(from: <span class="number">0</span>, to: <span class="number">0.85</span>) <span class="comment">// 从起点裁剪到 85%的位置</span></span><br><span class="line">               .stroke(purpleGradient, lineWidth: <span class="number">10</span>)</span><br><span class="line">               .frame(width: <span class="number">300</span>, height: <span class="number">300</span>)</span><br><span class="line">               .overlay &#123;</span><br><span class="line">                   <span class="type">VStack</span>(spacing: <span class="number">5</span>) &#123;</span><br><span class="line">                       <span class="type">Text</span>(<span class="string">&quot;85%&quot;</span>)</span><br><span class="line">                           .font(.title)</span><br><span class="line">                           .fontWeight(.bold)</span><br><span class="line">                           .foregroundColor(.red)</span><br><span class="line">                       <span class="type">Text</span>(<span class="string">&quot;完成度&quot;</span>)</span><br><span class="line">                           .font(.body)</span><br><span class="line">                           .fontWeight(.bold)</span><br><span class="line">                           .foregroundStyle(.gray)</span><br><span class="line">                   &#125;</span><br><span class="line">                   </span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们用到了<code>trim</code>修饰器，它可以帮助我们定义<code>Circle</code>裁切。</p>
<p>此时效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310121910110.png" style="zoom:50%"/>

<h3 id="绘制一个环状图"><a href="#绘制一个环状图" class="headerlink" title="绘制一个环状图"></a>绘制一个环状图</h3><p>使用上面<code>trim</code>，我们可以使用<code>Circle</code>绘制一个环状图。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span>() &#123;</span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .trim(from: <span class="number">0</span>, to: <span class="number">0.3</span>)</span><br><span class="line">                .stroke(<span class="type">Color</span>(.systemBrown), lineWidth: <span class="number">50</span>)</span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .trim(from: <span class="number">0.3</span>, to: <span class="number">0.5</span>)</span><br><span class="line">                .stroke(<span class="type">Color</span>(.systemBlue), lineWidth: <span class="number">50</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .trim(from: <span class="number">0.5</span>, to: <span class="number">0.8</span>)</span><br><span class="line">                .stroke(<span class="type">Color</span>(.systemMint), lineWidth: <span class="number">50</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .trim(from: <span class="number">0.8</span>, to: <span class="number">0.9</span>)</span><br><span class="line">                .stroke(<span class="type">Color</span>(.systemPink), lineWidth: <span class="number">50</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .trim(from: <span class="number">0.9</span>, to: <span class="number">1</span>)</span><br><span class="line">                .stroke(<span class="type">Color</span>(.systemTeal), lineWidth: <span class="number">50</span>)</span><br><span class="line">                .overlay &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;10%&quot;</span>)</span><br><span class="line">                        .offset(<span class="type">CGSize</span>(width: <span class="number">90</span>, height: <span class="operator">-</span><span class="number">120</span>))</span><br><span class="line">                        .fontWeight(.bold)</span><br><span class="line">                        .font(.headline)</span><br><span class="line">                        .foregroundStyle(.white)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .frame(width: <span class="number">300</span>, height: <span class="number">300</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310121924908.png" style="zoom:50%"/>
]]></content>
      <categories>
        <category>SwiftUI 进阶</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Shape</tag>
        <tag>Path</tag>
        <tag>Stroke</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 介绍</title>
    <url>/posts/96cb395e.html</url>
    <content><![CDATA[<h1 id="SwiftUI-简介"><a href="#SwiftUI-简介" class="headerlink" title="SwiftUI 简介"></a>SwiftUI 简介</h1><p>SwiftUI 是 Apple 在 2019 年 WWDC 推出的一种现代化的 UI 开发框架，它是 iOS 13 和 macOS Catalina 的一部分。SwiftUI 可以让用户更容易地创建美观且响应式的用户界面，并且与 Core Data、Realm 等数据存储解决方案集成得非常好。此外，SwiftUI 还在不断更新和完善，以满足开发者的需求。</p>
<h2 id="SwiftUI-的特点"><a href="#SwiftUI-的特点" class="headerlink" title="SwiftUI 的特点"></a>SwiftUI 的特点</h2><h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>SwiftUI 采用了声明式编程的方式，与传统的命令式编程相比，这种方式让代码更加简洁易读。你只需要描述应用程序的界面应该如何显示，而不需要详细指定每一个视图的属性和方法。</p>
<span id="more"></span>

<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>SwiftUI 提供了强大的响应式布局能力，可以轻松地创建出适应不同设备和屏幕尺寸的应用程序。它支持线性布局、网格布局和灵活的布局组合，让你可以轻松地构建出复杂的界面。</p>
<h3 id="内置动画和过渡"><a href="#内置动画和过渡" class="headerlink" title="内置动画和过渡"></a>内置动画和过渡</h3><p>SwiftUI 提供了丰富的内置动画和过渡效果，可以让你轻松地为应用程序添加生动的交互效果。这些动画和过渡效果与硬件加速相结合，可以让你的应用程序看起来更加流畅和自然。</p>
<h3 id="与-Core-Data-和-Realm-集成"><a href="#与-Core-Data-和-Realm-集成" class="headerlink" title="与 Core Data 和 Realm 集成"></a>与 Core Data 和 Realm 集成</h3><p>SwiftUI 可以很容易地与 Core Data 和 Realm 等数据存储解决方案集成。你可以在应用程序中方便地访问和操作数据，而无需手动处理繁琐的数据库操作。</p>
<h2 id="开始使用-SwiftUI"><a href="#开始使用-SwiftUI" class="headerlink" title="开始使用 SwiftUI"></a>开始使用 SwiftUI</h2><p>要开始使用 SwiftUI，你需要先安装 Xcode（macOS 10.15 及更高版本自带），然后创建一个新的 iOS 或 macOS 项目。在项目中，你可以直接使用默认的 <code>ContentView</code> 模板来开始编写 SwiftUI 代码。</p>
<p>下面是一个简单的 SwiftUI 示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Hello, SwiftUI!&quot;</span>)</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                .padding()</span><br><span class="line">            <span class="type">Button</span>(action: &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Button tapped!&quot;</span>)</span><br><span class="line">            &#125;) &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Tap me!&quot;</span>)</span><br><span class="line">                    .font(.title)</span><br><span class="line">                    .foregroundColor(.white)</span><br><span class="line">                    .padding()</span><br><span class="line">                    .background(<span class="type">Color</span>.blue)</span><br><span class="line">                    .cornerRadius(<span class="number">10</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了一个简单的页面，包含一个标题和一个按钮。当用户点击按钮时，控制台会输出 “Button tapped!”。你可以根据自己的需求修改这个示例，或者尝试创建更复杂的界面。</p>
<p>总之，SwiftUI 是一种功能强大、易于使用的 UI 开发框架，它可以帮助你更高效地构建出美观且响应式的应用程序。如果你已经熟悉 Swift 语言，那么学习 SwiftUI 将会是一件非常愉快的事情。</p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Swift</tag>
        <tag>Apple</tag>
        <tag>WWDC</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 控件之 Button(二)</title>
    <url>/posts/c45d65f5.html</url>
    <content><![CDATA[<h3 id="使用渐变色作为按钮的背景颜色"><a href="#使用渐变色作为按钮的背景颜色" class="headerlink" title="使用渐变色作为按钮的背景颜色"></a>使用渐变色作为按钮的背景颜色</h3><p>在 SwiftUI 中，我们不仅仅能使用一个明确的颜色作为按钮的背景色，也可以使用<strong>渐变色</strong>作为按钮的背景色。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span>(action: &#123;</span><br><span class="line">&#125;, label: &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Button&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.padding()</span><br><span class="line">.foregroundStyle(.white)</span><br><span class="line">.background(.linearGradient(<span class="type">Gradient</span>(colors: [.red, .blue]), startPoint: .leading, endPoint: .trailing))</span><br><span class="line">.clipShape(<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>, style: .circular))</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用了<code>linearGradient</code>创建了一个<strong>线性渐变色</strong>作为按钮的背景颜色，<code>linearGradient</code>需要三个参数，</p>
<ul>
<li>参数一是一个<code>Gradient</code>类型的对象，需要给它设置一个<code>Color</code>类型数组作为渐变的颜色；</li>
<li>参数二和参数三分别是渐变的<strong>开始点</strong>和<strong>结束点</strong>，例如示例中表示的是渐变从左到右进行。</li>
</ul>
<p>具体的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310060933521.png"/>

<span id="more"></span>

<h3 id="创建一个屏幕与屏幕等宽的按钮"><a href="#创建一个屏幕与屏幕等宽的按钮" class="headerlink" title="创建一个屏幕与屏幕等宽的按钮"></a>创建一个屏幕与屏幕等宽的按钮</h3><p>当一个按钮越大时，越能吸引到用户的注意力。所以，在一些情况下下，我们需要创建一个和屏幕完全等宽的按钮。想要实现这样的效果，我们可以给按钮添加<code>frame</code>修饰器，然后通过设置<code>frame</code>的参数来进行设置。</p>
<p>在上面示例的基础上添加<code>frame</code>修饰器，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.frame(minWidth: <span class="number">0</span>, maxWidth: .infinity)</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们给按钮设置了最小的宽度为 0，最大的宽度为<strong>无限</strong>，<strong>这意味着按钮将以尽可能的宽度填充在容器视图中</strong>。</p>
<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310060947242.png" style="zoom:20%"/>

<p><span style="color:red"><strong>需要注意的一点是：</strong></span>在 SwiftUI 中，同时添加<code>padding</code>和<code>frame</code>修饰器时，应当将<code>frame</code>修饰器置于<code>padding</code>前面。即</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.frame(minWidth: <span class="number">0</span>, maxWidth: .infinity)</span><br><span class="line">.padding()</span><br></pre></td></tr></table></figure>

<p>而不是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.padding()</span><br><span class="line">.frame(minWidth: <span class="number">0</span>, maxWidth: .infinity)</span><br></pre></td></tr></table></figure>

<p>类似地，还有<code>padding</code>和<code>background</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.padding()</span><br><span class="line">.background(.linearGradient(<span class="type">Gradient</span>(colors: [.red, .blue]), startPoint: .leading, endPoint: .trailing))</span><br></pre></td></tr></table></figure>

<p>而不是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.background(.linearGradient(<span class="type">Gradient</span>(colors: [.red, .blue]), startPoint: .leading, endPoint: .trailing))</span><br><span class="line">.padding()</span><br></pre></td></tr></table></figure>

<h3 id="使用-ButtonStyle-定义按钮的样式"><a href="#使用-ButtonStyle-定义按钮的样式" class="headerlink" title="使用 ButtonStyle 定义按钮的样式"></a>使用 ButtonStyle 定义按钮的样式</h3><p>在实际开发一个app 的过程中，我们都会让整个 app 中的按钮风格统一，这就意味这所有的按钮都会用到相同的修饰器。为了减少相同代码的冗余，我们可以通过自定义修饰器的方式来将一些需要重复使用的风格样式进行单独定义。针对<strong>Button</strong>而言，我们就可以通过<strong>ButtonStyle</strong>来重新定义一个新的按钮样式。</p>
<p> 首先，自定义一个结构体，这个结构体需要实现<strong>ButtonStyle</strong>协议，在实现这个协议之后，这个协议需要实现一个<code>makeBody</code>的协议方法。</p>
<p><code>makeBody</code>有一个<code>configuration</code>的参数，它是<code>Configuration</code>类型，<code>configuration</code>包含了一个名为<code>label</code>的属性，将我们通用的样式修饰器添加到这个属性上即可修改按钮的样式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GradientBackgroundStyle</span>: <span class="title class_">ButtonStyle</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeBody</span>(<span class="params">configuration</span>: <span class="type">Configuration</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        configuration.label           </span><br><span class="line">            .frame(minWidth: <span class="number">0</span>, maxWidth: .infinity)</span><br><span class="line">            .padding()</span><br><span class="line">            .foregroundStyle(.white)</span><br><span class="line">            .background(.linearGradient(<span class="type">Gradient</span>(colors: [.red, .blue]), startPoint: .leading, endPoint: .trailing))</span><br><span class="line">            .clipShape(<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">20</span>, style: .circular))</span><br><span class="line">            .padding(.horizontal, <span class="number">20</span>)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义好这个风格样式之后，只需要在原来的<strong>Button</strong>之后添加<code>buttonStyle</code>修饰器，然后创建一个<code>GradientBackgroundStyle</code>的对象作为参数传进去即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span>(action: &#123;</span><br><span class="line">           &#125;, label: &#123;</span><br><span class="line">               <span class="type">Text</span>(<span class="string">&quot;Delete&quot;</span>)</span><br><span class="line">           &#125;)</span><br><span class="line">           .buttonStyle(<span class="type">GradientBackgroundStyle</span>())</span><br></pre></td></tr></table></figure>

<p>效果还是和之前一样，只是我们可以将相同的样式应用到多个按钮上。</p>
<h3 id="使用-Button-Role"><a href="#使用-Button-Role" class="headerlink" title="使用 Button Role"></a>使用 Button Role</h3><p>在 iOS 15 之后，SwiftUI 为 <strong>Button</strong>提供了一个<code>role</code>选项，设置了这个选项之后，SwiftUI 会根据设置的选项进行渲染。<code>role</code>选项提供了两种不同的类型，分别是<code>cancel</code>和<code>destructive</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span>(role: .cancel) &#123;</span><br><span class="line">                &#125; label: &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Delete&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                .buttonStyle(.borderedProminent)</span><br><span class="line">                <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;.cancel&quot;</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;.borderedProminent&quot;</span>)</span><br><span class="line">                &#125;.fontWeight(.bold)</span><br></pre></td></tr></table></figure>

<p>不同的样式效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310061047489.png"/>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Button</tag>
        <tag>Gradient</tag>
        <tag>Modifier</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 控件之 ColorPicker</title>
    <url>/posts/d1bc9d76.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，除了常见的<strong>Picker</strong>和<strong>DatePicker</strong> ，还有一个<strong>ColorPicker（颜色选择器）</strong>，它在我们需要进行颜色选择时非常有用。</p>
<h3 id="创建一个颜色选择器"><a href="#创建一个颜色选择器" class="headerlink" title="创建一个颜色选择器"></a>创建一个颜色选择器</h3><p>首先，使用<code>@State</code>创建一个<code>Color</code>类型的变量作为<code>ColorPicker</code>选中绑定值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> selectedOptions:<span class="type">Color</span> <span class="operator">=</span> .red</span><br></pre></td></tr></table></figure>

<p>创建<code>ColorPicker</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">ColorPicker</span>(selection: <span class="variable">$selectedOptions</span>, label: &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;选择你最喜欢的颜色&quot;</span>)</span><br><span class="line">           &#125;)</span><br></pre></td></tr></table></figure>

<p>运行项目，点击的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309261444511.png" style="zoom:20%"/>

<span id="more"></span>

<p>默认情况下，<strong>ColorPicker</strong>也支持颜色的透明度选择，如果不想用户选择颜色的透明度，可以将<code>ColorPicker</code>的参数<code>supportsOpacity</code>设置为<code>false</code>即可。如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">ColorPicker</span>(selection: <span class="variable">$selectedOptions</span>, supportsOpacity: <span class="literal">false</span>, label: &#123;</span><br><span class="line">               <span class="type">Text</span>(<span class="string">&quot;选择你最喜欢的颜色&quot;</span>)</span><br><span class="line">           &#125;)</span><br></pre></td></tr></table></figure>

<p>此时的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309261450028.png" style="zoom:20%"/>

<p><strong>ColorPicker</strong>并不支持我们过多的进行自定义，很多场景下，我们使用它的默认样式即可。</p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>ColorPicker</tag>
        <tag>Picker</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 控件之 DatePicker</title>
    <url>/posts/b30b2594.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，<strong>Picker</strong>可以帮助我们实现一些常见的选择器应用场景。除此之外，SwiftUI 还给我们提供了其他两种常见的选择器，<strong>DatePicker（时间选择器）</strong>和 <strong>ColorPicker （选择器）</strong>。</p>
<h3 id="创建一个-DatePicker"><a href="#创建一个-DatePicker" class="headerlink" title="创建一个 DatePicker"></a>创建一个 DatePicker</h3><p><strong>DatePicker</strong>的创建和<strong>Picker</strong>创建一样，需要使用<code>@State</code>定义一个类型为<code>Date</code>的动态变量，然后将这个动态变量和<code>DatePicker</code>进行绑定：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> selectedOptions:<span class="type">Date</span> <span class="operator">=</span> <span class="type">Date</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DatePicker</span>(<span class="string">&quot;选择日期&quot;</span>, selection: <span class="variable">$selectedOptions</span>)</span><br></pre></td></tr></table></figure>

<p>默认情况下的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309250930378.png" style="zoom:60%"/>

<span id="more"></span>

<p>默认情况下，我们可以选择日期和时间两种格式。我们也可以通过给<code>DatePicker</code>添加<code>displayedComponents</code>来配置可选项，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DatePicker</span>(<span class="string">&quot;选择日期&quot;</span>, selection: <span class="variable">$selectedOptions</span>, displayedComponents: [.date]) <span class="comment">// 只可选择日期</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DatePicker</span>(<span class="string">&quot;选择日期&quot;</span>, selection: <span class="variable">$selectedOptions</span>, displayedComponents: [.hourAndMinute]) <span class="comment">// 只可选择时间</span></span><br></pre></td></tr></table></figure>

<p>以及</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DatePicker</span>(<span class="string">&quot;选择日期&quot;</span>, selection: <span class="variable">$selectedOptions</span>, displayedComponents: [.hourAndMinute, .date]) <span class="comment">// 默认均可选</span></span><br></pre></td></tr></table></figure>



<p>不同样式的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309250936280.png" style="zoom:60%"/>

<h3 id="设置-DatePicker-的不同样式"><a href="#设置-DatePicker-的不同样式" class="headerlink" title="设置 DatePicker 的不同样式"></a>设置 DatePicker 的不同样式</h3><p><strong>DatePicker</strong>的样式可以通过<code>datePickerStyle</code>修饰器来进行设置，它提供了<code>compact</code>、<code>graphical</code>和<code>wheel</code>三种样式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DatePicker</span>(<span class="string">&quot;选择日期&quot;</span>, selection: <span class="variable">$selectedOptions</span>, displayedComponents: [.hourAndMinute, .date]) <span class="comment">// 默认均可选</span></span><br><span class="line">                    .datePickerStyle(.graphical)</span><br></pre></td></tr></table></figure>

<p>不同的样式如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309250948482.png" style="zoom:20%"/>

<h3 id="设置可选择的日期范围"><a href="#设置可选择的日期范围" class="headerlink" title="设置可选择的日期范围"></a>设置可选择的日期范围</h3><p>在一些情况下，我们可能需要将可选择的日期限定在一定的范围内，这只需要我们给<code>DatePicker</code>添加一个<code>in</code>参数即可。<code>in</code>参数要求的是<code>ClosedRange&lt;Date&gt;</code>类型的一个范围区间，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bounds: <span class="type">ClosedRange</span>&lt;<span class="type">Date</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> calendar <span class="operator">=</span> <span class="type">Calendar</span>.current</span><br><span class="line">      <span class="comment">// 开始日期为当前的日期的前三天</span></span><br><span class="line">      <span class="keyword">let</span> start <span class="operator">=</span> calendar.date(byAdding: .day, value: <span class="operator">-</span><span class="number">3</span>, to: .now)<span class="operator">!</span></span><br><span class="line">      <span class="comment">// 结束日期为当前日期的未来三天</span></span><br><span class="line">      <span class="keyword">let</span> end <span class="operator">=</span> calendar.date(byAdding: .day, value: <span class="number">3</span>, to: .now)<span class="operator">!</span></span><br><span class="line">      <span class="keyword">return</span> start<span class="operator">...</span>end <span class="comment">// 返回一个开区间</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DatePicker</span>(<span class="string">&quot;选择日期&quot;</span>, selection: <span class="variable">$date</span>, in: bounds, displayedComponents: [.date])</span><br><span class="line">               .datePickerStyle(.graphical)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309261529211.png" style="zoom:50%"/>

<h3 id="DatePicker-本地化"><a href="#DatePicker-本地化" class="headerlink" title="DatePicker 本地化"></a>DatePicker 本地化</h3><p>默认情况下，<strong>DatePicker</strong> 以英文的形式进行显示，如果我们需要让它显示为中文，就需要进行<strong>本地化</strong>处理。本地化处理的流程就是给<code>DatePicker</code>添加一个<code>environment</code>修饰器，然后将本地的语言设置为中文即可，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DatePicker</span>(<span class="string">&quot;选择日期&quot;</span>, selection: <span class="variable">$selectedOptions</span>)</span><br><span class="line">              .datePickerStyle(.graphical)</span><br><span class="line">              .environment(\.locale, <span class="type">Locale</span>.<span class="keyword">init</span>(identifier: <span class="string">&quot;zh&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>本地化前后对比：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309250959187.png" style="zoom: 20%"/>

<p><span style="color:red"><strong>注意：</strong></span>在 <strong>Xcode 15.0 Beta</strong>中，并没有针对星期的显示进行本地化处理，无法确定是 <strong>Xcode 15.0</strong> 本身的问题还是最新的SwiftUI更新后的特性，在之前的的 <strong>Xcode 14.0</strong>中 本地化的处理也会对星期进行本地化，如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309251005729.png" style="zoom:20%"/>  



<p>具体原因待后续观察！</p>
<h3 id="MultiDatePicker（多日期选择器）"><a href="#MultiDatePicker（多日期选择器）" class="headerlink" title="MultiDatePicker（多日期选择器）"></a>MultiDatePicker（多日期选择器）</h3><p>有时间我们可能需要选择多个日期，这是就需要使用到<strong>MultiDatePicker</strong>。与<strong>DatePicker</strong>不同，<code>MultiDatePicker</code>的绑定值为<code>DateComponents</code>的元组<code>Set</code>类型，即：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">MultiDatePicker</span>(<span class="string">&quot;选择日期&quot;</span>, selection: <span class="variable">$dates</span>)</span><br><span class="line">                .frame(height: <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309261509022.png" style="zoom:20%"/>

<p><strong>注意</strong>，<span style="color:red"><strong>MultiDatePciker</strong> 的风格样式只支持<code>graphical</code>样式。不支持其他的风格。</span>需要注意的另外一点就是，在设置<code>MultiDatePicker</code>的可选时间范围时，同样是给它添加一个<code>in</code>参数，但是它需要的是一个<code>Range&lt;Date&gt;</code>类型的日期范围而不是<code>ClosedRange&lt;Date&gt;</code>类型，前者要求的<strong>开区间范围</strong>，而后者要求的是一个<strong>闭区间范围</strong>。</p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Picker</tag>
        <tag>DatePicker</tag>
        <tag>MultiDatePicker</tag>
        <tag>Range</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 控件之 Image</title>
    <url>/posts/6b844059.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，我们可以使用<strong>Image</strong>控件来展示一张图片。</p>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>在 SwiftUI中，如果我们需要使用<strong>Image</strong>显示一张图片，首先我们需要先将图片资源拖到蓝色的<span style="color:blue"><strong>Assets</strong></span>文件夹中，然后使用图片的文件名加载显示。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309081000150.png"/>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(<span class="string">&quot;avatar&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在最新的<span style="color:red"> <strong>Xcode 15.0</strong></span>中，增加了使用下面的方式加载资源文件夹中的图片的特性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(.avatar)</span><br></pre></td></tr></table></figure>

<p>上面两种方式的效果是一样的。</p>
<span id="more"></span>

<h3 id="常用的修饰器"><a href="#常用的修饰器" class="headerlink" title="常用的修饰器"></a>常用的修饰器</h3><h4 id="宽高"><a href="#宽高" class="headerlink" title="宽高"></a>宽高</h4><p>设置图片显示的<code>frame</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(.avatar)</span><br><span class="line">	.frame(width: <span class="number">100</span>, height: <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>当我们设置<strong>Image</strong>的<code>frame</code>后，我们发现它并没有按照我们所给的宽高进行显示，这是因为我们需要先添加 <code>resizzble</code> 修饰器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(.avatar)</span><br><span class="line">	.resizable()</span><br><span class="line">	.frame(width: <span class="number">100</span>, height: <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p>但是此时我们可能会发现，我们的图片显示<strong>变形</strong> 了，这主要是因为我们的图片宽高比例和所给的<code>frame</code> 的宽高比例并不一致。我们可以通过设置<code>scaledToFill</code>或者<code>scaledToFit</code> 修饰器来修饰图片的填充样式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Image</span>(.avatar)</span><br><span class="line">                    .resizable()</span><br><span class="line">                    .scaledToFit()</span><br><span class="line">                    .frame(width: <span class="number">100</span>, height: <span class="number">200</span>)</span><br><span class="line">                    .border(.red)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;scaledToFit&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Divider</span>()</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Image</span>(.avatar)</span><br><span class="line">                    .resizable()</span><br><span class="line">                    .aspectRatio(contentMode: .fill)</span><br><span class="line">                    .scaledToFill()</span><br><span class="line">                    .frame(width: <span class="number">100</span>, height: <span class="number">200</span>)</span><br><span class="line">                    .border(.red)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;scaledToFill&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309081112939.png" style="zoom:20%"/>

<p>在预览图中，<span style="color:red"><strong>红色</strong></span> 的边框表示我们实际设置的<code>frame</code> 范围。在同一张图片和同样的<code>frame</code>设置下，我们可以很清楚的看到<code>scaledToFit</code>和<code>scaledToFill</code>的区别：</p>
<ul>
<li><code>scaledToFit</code> 会优先按照给定的<code>frame</code> <strong>宽度（width）</strong>进行填充；</li>
<li><code>scaledToFill</code> 会优先按照给定的<code>frame</code> <strong>高度（height）</strong>进行填充。</li>
</ul>
<h4 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h4><p>我们可以在通过<code>frame</code>设置宽高的时候来设置图片的对齐方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.frame(width: <span class="number">100</span>, height: <span class="number">200</span>,alignment: .center)</span><br></pre></td></tr></table></figure>

<p>默认情况下为居中（center）对齐方式.</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309081120845.png"/>

<h4 id="图片裁切"><a href="#图片裁切" class="headerlink" title="图片裁切"></a>图片裁切</h4><p>当图片超出定义的<code>frame</code>范围时，可以使用<code>clipped</code> 修饰器让图片显示的范围和我们定义的<code>frame</code> 一致：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(.avatar)</span><br><span class="line">     .resizable()</span><br><span class="line">     .scaledToFill()</span><br><span class="line">     .frame(width: <span class="number">100</span>, height: <span class="number">200</span>,alignment: .top)</span><br><span class="line">     .border(.red)</span><br><span class="line">     .clipped()</span><br></pre></td></tr></table></figure>



<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309081148253.png" style="zoom:20%"/>

<p>将图片按照形状进行裁切：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.clipShape(<span class="type">Circle</span>())</span><br></pre></td></tr></table></figure>

<h4 id="给图片添加一个-Overlay"><a href="#给图片添加一个-Overlay" class="headerlink" title="给图片添加一个 Overlay"></a>给图片添加一个 Overlay</h4><p>如果我们想要给<code>Image</code>添加一个遮罩层可以使用<code>overlay</code>修饰器，它的参数是一个<code>View</code>类型，这意味这我们可以将任意一个<code>View</code>类型的视图作为遮罩层。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.overlay &#123;</span><br><span class="line">                  <span class="type">Image</span>(systemName: <span class="string">&quot;heart.fill&quot;</span>)</span><br><span class="line">                      .foregroundStyle(.white)</span><br><span class="line">                      .font(.system(size: <span class="number">40</span>))</span><br><span class="line">                      .opacity(<span class="number">0.8</span>)</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310010946106.png" style="zoom:50%"/>

<p><code>overlay</code>也可以通过设置<code>alignment</code>参数来设置遮罩层的对齐方式，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.overlay(alignment: .center, content: &#123;</span><br><span class="line">               <span class="type">Text</span>(<span class="string">&quot;这是用AI生成的一个头像&quot;</span>)</span><br><span class="line">                   .foregroundStyle(.black)</span><br><span class="line">                   .font(.title)</span><br><span class="line">                   .fontWeight(.bold)</span><br><span class="line">                   .padding()</span><br><span class="line">                   .background(.white)</span><br><span class="line">                   .clipShape(<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">8</span>)) <span class="comment">// 添加圆角</span></span><br><span class="line">                   .opacity(<span class="number">0.8</span>) <span class="comment">// 透明度</span></span><br><span class="line">           &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Image-加载显示-SF-Symbols"><a href="#Image-加载显示-SF-Symbols" class="headerlink" title="Image 加载显示 SF Symbols"></a>Image 加载显示 SF Symbols</h4><p><strong>SF Symbols</strong> 是 Apple 提供的一套系统内置的常用图标集。在最新的<strong>SF Symbols 5</strong> 中已经提供了总共<strong>5296</strong>个各种各样的图标。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310011000319.png" style="zoom:20%"/>

<p>在使用这些系统图标时，只需要使用<code>Image(systemName:String)</code>这个方法即可，<code>systemName</code>就是图标的名称。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(systemName: <span class="string">&quot;heart.circle&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的一点是，<span style="color:red"><strong>SF Symbols</strong> 本质上还是属于字体的一部分，所以很多适用于字体设置的修饰器同样也适用于它。</span>例如，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(systemName: <span class="string">&quot;heart.circle&quot;</span>)</span><br><span class="line">             .font(.title)</span><br><span class="line">             .fontWeight(.bold)</span><br><span class="line">             .foregroundStyle(.red)</span><br></pre></td></tr></table></figure>

<p><strong>SF Symbols</strong>支持多种颜色和多种渲染模式。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310011015286.png" style="zoom:30%"/>

<p>通过代码可以这么进行设置：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(systemName: <span class="string">&quot;pencil.circle.fill&quot;</span>)</span><br><span class="line">           .font(.largeTitle)</span><br><span class="line">           .fontWeight(.bold)</span><br><span class="line">           .symbolRenderingMode(.palette) <span class="comment">// 渲染模式</span></span><br><span class="line">           .foregroundStyle(.yellow, .tint, .red) <span class="comment">// 颜色设置</span></span><br></pre></td></tr></table></figure>

<p>对于一些特殊的<strong>Symbols</strong>，它可以设置一个可变的值，根据这个实现不同的样式。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(systemName: <span class="string">&quot;slowmo&quot;</span>, variableValue: <span class="number">0.2</span>)</span><br><span class="line">                .font(.system(size: <span class="number">50</span>))</span><br><span class="line">                .foregroundStyle(.indigo)</span><br></pre></td></tr></table></figure>

<p>不同值的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310011023505.png"/>

<p><strong>在最新的 SwiftUI 和 SF Symbols中还支持添加动画效果，我们将在后续动画部分进行介绍。</strong></p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Xcode</tag>
        <tag>Image</tag>
        <tag>SF Symbols</tag>
        <tag>Overlay</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 控件之 ScrollView(一)</title>
    <url>/posts/35d3a19e.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，<strong>ScrollView</strong> 是一个可滚动的视图。</p>
<h4 id="创建一个-ScrollView"><a href="#创建一个-ScrollView" class="headerlink" title="创建一个 ScrollView"></a>创建一个 ScrollView</h4><p>当我们使用<code>ForEach</code> 循环创建超出一整个屏幕的内容时：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">      <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">100</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">          <span class="type">Text</span>(<span class="string">&quot;当前行<span class="subst">\(index)</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用<code>VStack</code>和<code>ForEach</code> 创建了 100 个<code>Text</code>，此时要显示的内容已经超出了一个屏幕所能显示的内容，我们无法看到超出屏幕范围的内容。为了解决这个问题，我们就可以在最外层嵌套一个<code>ScrollView</code>，让整个视图变成滚动显示的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">ScrollView</span> &#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">100</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;当前行<span class="subst">\(index)</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们就可以通过上下滚动的方式查看所有的<code>Text</code> 了。</p>
<span id="more"></span>

<h4 id="ScrollView的相关配置"><a href="#ScrollView的相关配置" class="headerlink" title="ScrollView的相关配置"></a>ScrollView的相关配置</h4><h5 id="控制-ScrollView-的滚动位置"><a href="#控制-ScrollView-的滚动位置" class="headerlink" title="控制 ScrollView 的滚动位置"></a>控制 ScrollView 的滚动位置</h5><p>可以通过<code>defaultScrollAnchor</code> 修饰器配置<code>ScrollView</code>的开始滚动的起始位置，它支持以下几个位置：</p>
<ul>
<li><code>top</code> : 从顶部开始滚动；</li>
<li><code>bottom</code> : 从底部开始滚动；</li>
<li><code>center</code>： 从中间位置开始滚动；</li>
<li><code>leading</code>: 从左侧开始滚动；</li>
<li><code>trailing</code>： 从右侧开始滚动；</li>
<li><code>topLeading</code>：从左上开始滚动；</li>
<li><code>topTrailing</code>：从右上开始滚动；</li>
<li><code>bottomLeading</code>：从左下开始滚动；</li>
<li><code>bottomTrailing</code>：从右下开始滚动。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.defaultScrollAnchor(.center)</span><br></pre></td></tr></table></figure>

<h5 id="控制-ScrollView-滚动的方向"><a href="#控制-ScrollView-滚动的方向" class="headerlink" title="控制 ScrollView 滚动的方向"></a>控制 ScrollView 滚动的方向</h5><p><strong>ScrollView</strong> 支持水平<code>horizontal</code>和垂直<code>vertical</code>方向的滚动。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">ScrollView</span>(.vertical) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="控制-ScrollView-滚动指示器的显示-隐藏"><a href="#控制-ScrollView-滚动指示器的显示-隐藏" class="headerlink" title="控制 ScrollView 滚动指示器的显示&#x2F;隐藏"></a>控制 ScrollView 滚动指示器的显示&#x2F;隐藏</h5><p><strong>ScrollView</strong> 滚动的时候，视图边缘会有一个滚动的指示器。可以使用<code>scrollIndicators</code> 修饰器来控制它的显示或者隐藏。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.scrollIndicators(.hidden)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hidden</code>: 表示隐藏；</li>
<li><code>visible</code>: 表示显示；</li>
<li><code>never</code>：和<code>hidden</code> 一致；</li>
</ul>
<p>指定水平或垂直方向上的显示或者隐藏：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.scrollIndicators(.hidden, axes: [.horizontal])</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>ScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI中的基础动画和过渡（三）</title>
    <url>/posts/9d6e228c.html</url>
    <content><![CDATA[<p>在之前关于<strong>隐式动画</strong>和<strong>显式动画</strong>的文章中，我们都是将动画添加给一个已经存在的视图。在 SwiftUI，它允许我们去定义一个视图的出现和移除，这被叫做<strong>过渡（Transitions）</strong>。</p>
<p> 默认情况下，SwiftUI 中的视图的出现和移除使用的<strong>fade-in</strong>和<strong>fade-out</strong>过渡效果。除此之外，SwiftUI 也内置了<strong>slide</strong>、<strong>move</strong>、<strong>opacity</strong>等过渡效果。</p>
<h3 id="构建一个简单的过渡效果"><a href="#构建一个简单的过渡效果" class="headerlink" title="构建一个简单的过渡效果"></a>构建一个简单的过渡效果</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>)</span><br><span class="line">                .frame(width: <span class="number">300</span>, height: <span class="number">300</span>)</span><br><span class="line">                .foregroundStyle(.green)</span><br><span class="line">                .overlay &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;显示详情&quot;</span>)</span><br><span class="line">                        .font(.system(.largeTitle, design: .rounded))</span><br><span class="line">                        .bold()</span><br><span class="line">                        .foregroundStyle(.white)</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>)</span><br><span class="line">                .frame(width: <span class="number">300</span>, height: <span class="number">300</span>)</span><br><span class="line">                .foregroundStyle(.purple)</span><br><span class="line">                .overlay &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;哇哦，详情信息&quot;</span>)</span><br><span class="line">                        .font(.system(.largeTitle, design: .rounded))</span><br><span class="line">                        .bold()</span><br><span class="line">                        .foregroundStyle(.white)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在上面的代码中，我们使用<code>VStack</code>布局管理了两个<code>RoundedRectangle</code>。接着，我们先让第二个紫色的<code>RoundedRectangle</code>隐藏，当我们点击第一个绿色的<code>RoundedRectangle</code>时在显示。</p>
<p>这里，我们先来定义一个状态变量，用来控制第二个紫色<code>RoundedRectangle</code>的显示或隐藏。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@State var isShow: Bool = false</span><br></pre></td></tr></table></figure>

<p>然后将第二个<code>RoundedRectangle</code>使用<code>if</code>语句进行包裹：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> isShow &#123;</span><br><span class="line">              <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>)</span><br><span class="line">                  .frame(width: <span class="number">300</span>, height: <span class="number">300</span>)</span><br><span class="line">                  .foregroundStyle(.purple)</span><br><span class="line">                  .overlay &#123;</span><br><span class="line">                      <span class="type">Text</span>(<span class="string">&quot;哇哦，详情信息&quot;</span>)</span><br><span class="line">                          .font(.system(.largeTitle, design: .rounded))</span><br><span class="line">                          .bold()</span><br><span class="line">                          .foregroundStyle(.white)</span><br><span class="line">                  &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>此时，因为<code>isShow</code>值为<code>false</code>，所以第二个<code>RoundedRectangle</code>是不会显示的。</p>
<p>接着，我们给绿色的<code>RoundedRectangle</code>添加<code>onTaGesture</code>修饰器去识别点击手势，当点击手势发生后，对<code>isShow</code>的状态值为取反，并使用<code>withAnimation</code>添加一个默认的过渡动画。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.onTapGesture &#123;</span><br><span class="line">                   withAnimation &#123;</span><br><span class="line">                       isShow.toggle()</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>

<p>默认的过渡动画如下：</p>
<p><video controls="controls" width="20%" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310201524703.mp4"></video></p>
<p>如果想要改变过渡的动画效果，可以给第二个紫色的<code>RoundedRectangle</code>添加<code>transition</code>修饰器，这个修饰器需要一个动画效果的参数，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.transition(.scale(scale: <span class="number">0</span>, anchor: .center))</span><br></pre></td></tr></table></figure>

<p><code>scale</code>是一个缩放的效果，它需要两个参数，一个是开始时的比例；另一个是缩放开始的锚点。除了<code>scale</code>效果，还有<code>slide</code>、<code>offset</code>、<code>move</code>、<code>opaque</code>等。</p>
<h3 id="组合过渡效果"><a href="#组合过渡效果" class="headerlink" title="组合过渡效果"></a>组合过渡效果</h3><p>如果我们想要要视图呈现多个过渡效果，可以使用<code>combined</code>方法来组合多个动画效果，例如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.transition(.offset(x: <span class="operator">-</span><span class="number">600</span>, y:<span class="number">0</span>).combined(with: .scale(scale: <span class="number">0</span>, anchor: .leading)))</span><br></pre></td></tr></table></figure>

<p>当然我们也可以组合多个：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.transition(.offset(x: <span class="operator">-</span><span class="number">600</span>, y:<span class="number">0</span>).combined(with: .scale(scale: <span class="number">0</span>, anchor: .leading)).combined(with: .opacity))</span><br></pre></td></tr></table></figure>

<h3 id="定义重复使用的动画"><a href="#定义重复使用的动画" class="headerlink" title="定义重复使用的动画"></a>定义重复使用的动画</h3><p>有时候，我们可能想要重复使用一个动画效果。这种情况下，我们可以通用定义一个<code>AnyTransition</code>的扩展来实现，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">AnyTransition</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> offsetScaleOpacity: <span class="type">AnyTransition</span> &#123;</span><br><span class="line">        <span class="type">AnyTransition</span>.offset(x: <span class="operator">-</span><span class="number">600</span>, y:<span class="number">0</span>).combined(with: .scale).combined(with: .opacity)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.transition(.offsetScaleOpacity)</span><br></pre></td></tr></table></figure>

<h3 id="动画练习"><a href="#动画练习" class="headerlink" title="动画练习"></a>动画练习</h3><h4 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h4><p>使用动画和过渡创建下面的效果：</p>
<p><video width="20%" controls="controls" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310201704934.mp4"></video></p>
<h5 id="完整代码和注释"><a href="#完整代码和注释" class="headerlink" title="完整代码和注释"></a>完整代码和注释</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> processing <span class="operator">=</span> <span class="literal">false</span> <span class="comment">// 是否正在处理中</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> completed <span class="operator">=</span> <span class="literal">false</span> <span class="comment">// 是否已处理完成</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> loading <span class="operator">=</span> <span class="literal">false</span> <span class="comment">// 是否正在加载中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">30</span>)</span><br><span class="line">                .frame(width: processing <span class="operator">?</span> <span class="number">250</span> : <span class="number">200</span>, height: <span class="number">60</span>)</span><br><span class="line">                .foregroundStyle(completed <span class="operator">?</span> .red : .green)</span><br><span class="line">            <span class="comment">// 如果不是在处理过程中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="operator">!</span>processing &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Submit&quot;</span>)</span><br><span class="line">                    .font(.system(.title, design: .rounded))</span><br><span class="line">                    .bold()</span><br><span class="line">                    .foregroundStyle(.white)</span><br><span class="line">                    .transition(.move(edge: .top))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 正在处理并且处于未完成状态</span></span><br><span class="line">            <span class="keyword">if</span> processing <span class="operator">&amp;&amp;</span> <span class="operator">!</span>completed &#123;</span><br><span class="line">                <span class="type">HStack</span> &#123;</span><br><span class="line">                    <span class="type">Circle</span>()</span><br><span class="line">                        .trim(from: <span class="number">0</span>, to: <span class="number">0.7</span>)</span><br><span class="line">                        .stroke(<span class="type">Color</span>.white, lineWidth: <span class="number">3</span>)</span><br><span class="line">                        .frame(width: <span class="number">20</span>, height: <span class="number">30</span>)</span><br><span class="line">                        .rotationEffect(.degrees(loading <span class="operator">?</span> <span class="number">360</span> : <span class="number">0</span> ))</span><br><span class="line">                        .animation(.easeInOut.repeatForever(autoreverses: <span class="literal">false</span>), value: loading)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Processing&quot;</span>)</span><br><span class="line">                        .font(.system(.title, design: .rounded))</span><br><span class="line">                        .bold()</span><br><span class="line">                        .foregroundStyle(.white)</span><br><span class="line">                &#125;</span><br><span class="line">                .transition(.opacity)</span><br><span class="line">                .onAppear &#123;</span><br><span class="line">                    <span class="comment">// 页面出现时调用</span></span><br><span class="line">                    startProcessing()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 完成后显示</span></span><br><span class="line">            <span class="keyword">if</span> completed &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">                    .font(.system(.title, design: .rounded))</span><br><span class="line">                    .bold()</span><br><span class="line">                    .foregroundStyle(.white)</span><br><span class="line">                    .onAppear &#123;</span><br><span class="line">                        <span class="keyword">self</span>.endProcessing()</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .animation(.spring, value: loading)</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="operator">!</span>loading &#123;</span><br><span class="line">                processing.toggle()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始处理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">startProcessing</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.loading <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 模拟处理过程，4s 后更新为处理完成状态</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.completed <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束处理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">endProcessing</span>() &#123;</span><br><span class="line">        <span class="comment">// 3s 后重置按钮的所有状态</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.processing <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">            <span class="keyword">self</span>.completed <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">            <span class="keyword">self</span>.loading <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SwiftUI 进阶</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>withAnimation</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI中的状态管理</title>
    <url>/posts/177cbef.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，<strong>响应式</strong>是区别于 UIKit 的一大特点。SwiftUI 中的<strong>响应式</strong>主要依赖与数据的状态来进行视图的更新和重绘。</p>
<h3 id="State"><a href="#State" class="headerlink" title="@State"></a>@State</h3><p>假设我们想要实现一个简单的计数功能，即点击➕按钮实现次数的加一。如下的代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;当前次数<span class="subst">\(count)</span>&quot;</span>)</span><br><span class="line">            <span class="type">Button</span>(action: &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;, label: &#123;</span><br><span class="line">                <span class="type">Image</span>(systemName: <span class="string">&quot;plus&quot;</span>)</span><br><span class="line">                    .font(.title)</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们简单地在<code>Button</code>的<code>action</code>部分添加<code>count += 1</code>，如果我们这样做了，程序会报以下错误：</p>
<p><span style="color:red"><strong>Left side of mutating operator isn’t mutable: ‘self’ is immutable</strong></span></p>
<span id="more"></span>

<p>这是因为在 Swift 中<strong>结构体</strong>是<strong>值类型</strong>，它不能让我们直接修改它的成员属性。如果要想解决这个问题，只需要给<code>count</code>添加一个<code>@State</code> 的属性包装器，即</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> count: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure>

<p>当添加了这个属性包装器之后，SwiftUI 会自动去管理<code>count</code>这个变量。</p>
<h3 id="Binding"><a href="#Binding" class="headerlink" title="@Binding"></a>@Binding</h3><p>在 SwiftUI 中，很多的控件需要一个变量值进行<strong>双向绑定</strong>。例如，<strong>TextField</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">TextField</span>(text: <span class="operator">&lt;</span><span class="type">Binding</span>&lt;<span class="type">String</span>&gt;<span class="operator">&gt;</span>, label: <span class="operator">&lt;</span>() -&gt; <span class="type">View</span><span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure>

<p>上面是<code>TextField</code>的一个基础构造方法，它的第一个参数<code>Text</code>要求的就是一个<code>Binding&lt;String&gt;</code>类型的值，这里要求的就是一个<strong>双向绑定</strong>，即当输入框的值发现变化时，变量的值同步发生改变；或者变量值发生变化时，输入框显示的内容也同步发生变化。</p>
<p>具体的用法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> inputText:<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> <span class="comment">// 声明一个状态变量</span></span><br></pre></td></tr></table></figure>

<p>将这个状态变量和<code>TextField</code>控件使用<code>$</code>语法建立双向绑定：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">TextField</span>(text: <span class="variable">$inputText</span>) &#123;</span><br><span class="line">               <span class="type">Text</span>(<span class="string">&quot;输入&quot;</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在另外的一种情况下，如果我们想让父视图和子视图建立类似的双向状态值绑定，需要在子视图中使用<code>@Binding</code>属性包装器来定义一个变量接受父视图传过来的状态值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子视图</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> inputText: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TextField</span>(text: <span class="variable">$inputText</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;输入&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父视图中调用这个子视图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> inputText:<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> <span class="comment">// 声明一个状态变量</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">10</span>) &#123;</span><br><span class="line">           <span class="type">SubContentView</span>(inputText: <span class="variable">$inputText</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，父视图和子视图中的值将同步发生变化，进而更新视图。</p>
<h3 id="ObservableObject-和-ObservedObject"><a href="#ObservableObject-和-ObservedObject" class="headerlink" title="ObservableObject 和 ObservedObject"></a>ObservableObject 和 ObservedObject</h3><p>上面的<code>@State</code>和<code>@Binding</code>我们常用于基础的状态管理，在实际的开发应用中，我们更多的是通过一个数据模型的方式来管理视图的状态。</p>
<p>例如，我们先声明一个<code>class</code> 的数据模型，同时让它实现<code>ObservableObject</code>协议，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataManager</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> dataList: [<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;西游记&quot;</span>, <span class="string">&quot;水浒传&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个<code>class</code>模型中，会存在多个属性。如果我们需要指定属性，当这个属性的值发生变化是同步更新相关的视图，那么我们需要使用<code>@Published</code>属性包装器来修饰这个变量。</p>
<p>在使用时，需要使用<code>@ObservedObject</code>属性包装器来修饰这个模型类型的变量，以达到”订阅“的作用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> dataManager: <span class="type">DataManager</span> <span class="operator">=</span> <span class="type">DataManager</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(dataManager.dataList,id:\.<span class="keyword">self</span>) &#123; data <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(data)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Button</span>(action: &#123;</span><br><span class="line">                dataManager.dataList.append(<span class="string">&quot;红楼梦&quot;</span>)</span><br><span class="line">            &#125;, label: &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;添加&quot;</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个和<code>@ObservedObject</code>类似的属性包装器<code>@StateObejct</code>，二者的作用类似，后面我们会专门讲解二者的区别。</p>
<h3 id="EnvironmentObject"><a href="#EnvironmentObject" class="headerlink" title="EnvironmentObject"></a>EnvironmentObject</h3><p>在 SwiftUI 中，View 提供了 <code>environmentObject(_)</code> 方法，来把某个 ObservableObject 的值注入到当前 View 层级及其子层级中去。在这个 View 的子层级中，可以使用 <code>@EnvironmentObject</code> 来直接获取这个绑定的环境值。</p>
<p>使用<code>EnvironmentObject</code>可以帮助我们实现将数据值进行多层视图的注入。例如在<code>ContentView</code>根视图中注入一个值，然后在多层子视图中获取和更新对应的值。</p>
<p><code>ContentView</code>中注入数据值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> dataManager: <span class="type">DataManager</span> <span class="operator">=</span> <span class="type">DataManager</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationStack</span> &#123;</span><br><span class="line">            <span class="type">ChildContentView</span>()</span><br><span class="line">        &#125;.environmentObject(dataManager)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一层的子视图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一层子视图</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChildContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">SubChildContentView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二层子视图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二层子视图</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubChildContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> dataManager: <span class="type">DataManager</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">List</span>(dataManager.dataList, id: \.<span class="keyword">self</span>) &#123; data <span class="keyword">in</span></span><br><span class="line">            <span class="type">Text</span>(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们在创建一个和第一层子视图平行的视图，在这个视图里面更新值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平行子视图</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BalanceChildContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> dataManager: <span class="type">DataManager</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            dataManager.dataList.append(<span class="string">&quot;红楼梦&quot;</span>)</span><br><span class="line">        &#125;, label: &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;添加&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将这个视图放到<code>ContentView</code>的<code>NavigationStack</code>中，使用一个<code>VStack</code>进行管理，即</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">         <span class="type">ChildContentView</span>()</span><br><span class="line">         <span class="type">BalanceChildContentView</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们就实现了多个子视图间的数据同步更新了。</p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>State</tag>
        <tag>Binding</tag>
        <tag>StateObject</tag>
        <tag>ObserableObject</tag>
        <tag>ObservedObject</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI中的状态管理和绑定</title>
    <url>/posts/72b6a6d3.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，<strong>状态管理</strong>是一个非常重要的概念。假设我们有一个播放音乐的 app，当我们点击播放按钮▶️后，按钮的状态从暂停状态⏸️切换到了播放状态。这里我们可以理解为播放的状态从<strong>一个状态</strong>转移到了<strong>另一个状态</strong>，当然，在实际的应用中，我们可能存在<strong>很多个状态</strong>，当<strong>状态发生变化</strong>时，app 需要根据状态切换到对应用户界面，即 UI。</p>
<p>SwiftUI内置了状态管理的方式，它使用<code>@State</code><strong>属性包装器</strong>去修饰一个变量，这个状态变量会被 SwiftUI 自动存储到应用内，当这个变量的值发生变化时，SwiftUI 会自动重新计算和更新视图，即更新 UI。</p>
<h3 id="State的基本使用"><a href="#State的基本使用" class="headerlink" title="@State的基本使用"></a>@State的基本使用</h3><p>首先，我们来看一下下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> playStatus: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span> <span class="comment">// 当为 true 表示正在播放</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(action: &#123;</span><br><span class="line">                playStatus.toggle() <span class="comment">// 布尔值取反</span></span><br><span class="line">            &#125;, label: &#123;</span><br><span class="line">                <span class="type">Image</span>(systemName: playStatus <span class="operator">?</span> <span class="string">&quot;stop.circle.fill&quot;</span> : <span class="string">&quot;play.circle.fill&quot;</span> )</span><br><span class="line">                    .resizable()</span><br><span class="line">                    .frame(width: <span class="number">80</span>, height: <span class="number">80</span>)</span><br><span class="line">                    .foregroundStyle(playStatus <span class="operator">?</span> .red : .green)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>上面的代码中有以下的几个步骤：</p>
<ol>
<li>使用<code>@State</code>修饰了 一个名为<code>playStatus</code>的变量，这个变量用来管理后面视图中的状态，这个状态变量是一个<code>Bool</code>类型，所以这个变量只有<code>true</code>和<code>false</code>两种状态；</li>
<li>在视图部分，有一个<code>Button</code>，按钮根据<code>playStatus</code>状态值的不同显示不用的颜色和按钮图片；</li>
<li>在点击按钮的时候，切换<code>playStatus</code>的状态，即有 <strong>true-&gt;false或者 false-&gt;true</strong>。</li>
</ol>
<p>效果如下：</p>
<p><video src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310081036991.mp4" width="20%"></video></p>
<h3 id="状态值和视图进行双向绑定"><a href="#状态值和视图进行双向绑定" class="headerlink" title="状态值和视图进行双向绑定"></a>状态值和视图进行双向绑定</h3><p>现在，我们想创建一个计数的按钮，每当按钮被点击一次，按钮上的文字次数都加一。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> counter: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(action: &#123;</span><br><span class="line">                counter <span class="operator">+=</span> <span class="number">1</span> <span class="comment">// 每点击一次，counter + 1</span></span><br><span class="line">            &#125;, label: &#123;</span><br><span class="line">                <span class="type">Circle</span>()</span><br><span class="line">                    .fill(.red)</span><br><span class="line">                    .frame(width: <span class="number">120</span>,height: <span class="number">120</span>)</span><br><span class="line">                    .shadow(radius: <span class="number">8</span>)</span><br><span class="line">                    .overlay &#123;</span><br><span class="line">                        <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(counter)</span>&quot;</span>)</span><br><span class="line">                            .font(.largeTitle)</span><br><span class="line">                            .foregroundStyle(.white)</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><video src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310081050156.mp4" width="20%"></video></p>
<p>这里我们设想一下，如果我们需要创建多个相同的<code>Button</code>，那么我们应该如何操作呢？在这种情况下，我们都会专门定义一个<strong>子视图</strong>，如果是定义一个子视图，那么就需要父视图的状态值传递给到子视图，这是就需要使用到<code>@Binding</code>属性包装器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CounterButton</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> counter: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            counter <span class="operator">+=</span> <span class="number">1</span> <span class="comment">// 每点击一次，counter + 1</span></span><br><span class="line">        &#125;, label: &#123;</span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .fill(.red)</span><br><span class="line">                .frame(width: <span class="number">120</span>,height: <span class="number">120</span>)</span><br><span class="line">                .shadow(radius: <span class="number">8</span>)</span><br><span class="line">                .overlay &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(counter)</span>&quot;</span>)</span><br><span class="line">                        .font(.largeTitle)</span><br><span class="line">                        .foregroundStyle(.white)</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，同样地需要在子视图中定义一个变量，用来接收从父视图传过来的，因为我们这里要接收的是从父视图传过来的使用<code>@State</code>定义的变量，所以子视图中的变量就需要使用<code>@Binding</code>进行修饰。</p>
<p>接着就是在父视图中使用这个子视图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">CounterButton</span>(counter: <span class="variable">$counter</span>)</span><br></pre></td></tr></table></figure>

<p>此时的效果和之前的是一样的，但是这里如果我们想要重复定义多个类似的<code>Button</code>只需要使用<code>CounterButton</code>这个子视图就好。</p>
<p>另外就是，这里的<span style="color:red"><strong>$</strong></span>符号是 SwiftUI 的一种语法格式，它表示<strong>让使用@State定义的变量<code>counter</code>和子视图<code>CounterButton</code>进行一个双向绑定。即，当这个值发生变化时，子视图同步重新进行计算和渲染。</strong></p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>State</tag>
        <tag>Binding</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI之 VStack、 HStack、 ZStack</title>
    <url>/posts/e7687e8f.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，我们会经常使用到 <strong>VStack</strong>、<strong>HStack</strong>、<strong>ZStack</strong> 来帮助我们进行布局。</p>
<h4 id="VStack"><a href="#VStack" class="headerlink" title="VStack"></a>VStack</h4><p>在<strong>VStack</strong>中的子视图都将按照<strong>垂直方向</strong>进行排列。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">        .font(.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的布局效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309090914844.png"/>

<span id="more"></span>

<h4 id="HStack"><a href="#HStack" class="headerlink" title="HStack"></a>HStack</h4><p>和<strong>VStack</strong> 类似，不过 <strong>HStack</strong>是将子视图按照<strong>水平方向</strong> 进行排列。</p>
<p> 类似地，将上面示例代码中的<strong>VStack</strong> 改为<strong>HStack</strong> :</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">        .font(.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309090918393.png"/>

<p>对于 <strong>VStack</strong> 和 <strong>HStack</strong> 而言，都可以设置它们子视图之前的间距<code>spacing</code> 和对齐方式<code>alignment</code> 。</p>
<p>区别在于，<strong>VStack</strong> 的对齐方式有：</p>
<ul>
<li><code>center</code>：居中对齐；</li>
<li><code>leading</code> ：左对齐；</li>
<li><code>trailing</code> ： 右对齐。</li>
</ul>
<p><strong>HStack</strong> 的对齐方式有：</p>
<ul>
<li><code>center</code> ：居中对齐；</li>
<li><code>top</code> ：顶部对齐；</li>
<li><code>bottom</code>：底部对齐。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span>(alignment: .leading, spacing: <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">                .font(.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">HStack</span>(alignment: .top, spacing: <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">                .font(.body)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h4 id="ZStack"><a href="#ZStack" class="headerlink" title="ZStack"></a>ZStack</h4><p><strong>ZStack</strong> 是让子视图按照<strong>Z轴方向</strong> 堆叠排列。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">ZStack</span> &#123;</span><br><span class="line">        <span class="type">Image</span>(<span class="string">&quot;avatar&quot;</span>)</span><br><span class="line">            .resizable()</span><br><span class="line">            .frame(width: <span class="number">200</span>, height: <span class="number">200</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">            .font(.body)</span><br><span class="line">            .foregroundStyle(.white)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309090942670.png"/>

<p><strong>ZStack</strong> 只能设置对齐方式<code>alignment</code>，它的对齐方式包括：</p>
<ul>
<li><code>top</code>：顶部对齐；</li>
<li><code>bottom</code>：底部对齐；</li>
<li><code>center</code>：居中对齐；</li>
<li><code>leading</code>：左对齐；</li>
<li><code>trailing</code>: 右对齐；</li>
<li><code>topLeading</code>：左上角对齐；</li>
<li><code>topTrailing</code>：右上角对齐；</li>
<li><code>bottomLeading</code>：左下角对齐；</li>
<li><code>bottomTrailing</code>: 右下角对齐。</li>
</ul>
<h4 id="布局示例"><a href="#布局示例" class="headerlink" title="布局示例"></a>布局示例</h4><h5 id="VStack-1"><a href="#VStack-1" class="headerlink" title="VStack"></a>VStack</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VStackContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// 左对齐，上下间距为10</span></span><br><span class="line">        <span class="type">VStack</span>(alignment: .leading, spacing: <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">...</span><span class="number">10</span>, id: \.<span class="keyword">self</span>) &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;选项<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>)</span><br><span class="line">                <span class="type">Divider</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.padding(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HStack-1"><a href="#HStack-1" class="headerlink" title="HStack"></a>HStack</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HStackContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;朋友圈&quot;</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span>(alignment: .center, spacing: <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(title)</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;chevron.right&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ZStack-1"><a href="#ZStack-1" class="headerlink" title="ZStack"></a>ZStack</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ZStackContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="comment">// ZStack 实现头像置于背景之上的效果</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="type">Image</span>(<span class="string">&quot;bg&quot;</span>)</span><br><span class="line">                .resizable()</span><br><span class="line">                .scaledToFit()</span><br><span class="line">                .frame(height: <span class="number">300</span>)</span><br><span class="line">            <span class="type">Image</span>(<span class="string">&quot;avatar&quot;</span>)</span><br><span class="line">                .resizable()</span><br><span class="line">                .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">                .clipShape(<span class="type">Circle</span>()) <span class="comment">// 圆形头像设置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="VStack、-HStack和-ZStack-一起使用"><a href="#VStack、-HStack和-ZStack-一起使用" class="headerlink" title="VStack、 HStack和 ZStack 一起使用"></a>VStack、 HStack和 ZStack 一起使用</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LayoutDemo</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> options <span class="operator">=</span> [<span class="string">&quot;朋友圈&quot;</span>, <span class="string">&quot;发现&quot;</span>, <span class="string">&quot;游戏&quot;</span>, <span class="string">&quot;更多&quot;</span>]</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">ZStackContentView</span>()</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">ForEach</span>(options, id: \.<span class="keyword">self</span>) &#123; title <span class="keyword">in</span></span><br><span class="line">                    <span class="type">HStackContentView</span>(title: title)</span><br><span class="line">                    <span class="type">Divider</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ContentView"><a href="#ContentView" class="headerlink" title="ContentView"></a>ContentView</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> selectedSeg:<span class="type">Int</span> <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> segmentArr <span class="operator">=</span> [<span class="string">&quot;VStack&quot;</span>, <span class="string">&quot;HStack&quot;</span>, <span class="string">&quot;ZStack&quot;</span>, <span class="string">&quot;Layout&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="type">Picker</span>(selection: <span class="variable">$selectedSeg</span>) &#123;</span><br><span class="line">                <span class="type">ForEach</span>(<span class="number">0</span> <span class="operator">..&lt;</span> segmentArr.count) &#123;</span><br><span class="line">                    <span class="type">Text</span>(segmentArr[<span class="variable">$0</span>]).tag(<span class="variable">$0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; label: &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            .pickerStyle(.segmented) <span class="comment">//设置选择器的样式</span></span><br><span class="line">            <span class="comment">// 根据选择器绑定值的变化不同，显示不同的布局视图</span></span><br><span class="line">            <span class="keyword">switch</span> selectedSeg &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="type">VStackContentView</span>()</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="type">HStackContentView</span>()</span><br><span class="line">                <span class="type">Divider</span>()</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="type">ZStackContentView</span>()</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="type">LayoutDemo</span>()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="type">Spacer</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<video type="video/mp4"  width="30%" height="50%" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309090955427.mp4" controls="controls"/>

]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>VStack</tag>
        <tag>HStack</tag>
        <tag>ZStack</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI之app的生命周期</title>
    <url>/posts/2626effb.html</url>
    <content><![CDATA[<p>在 SwiftUI之前，我们管理 app 的生命周期使用<strong>AppDelegate</strong>，这在使用 <strong>UIKit</strong> 开发时是非常常见的。在 iOS 13.0 之后，对于 SwifUI 的 app 可以使用<strong>AppDelegate</strong>和<strong>SceneDelegate</strong>来管理 app 的生命周期。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppLifeycleApp</span>: <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="meta">@UIApplicationDelegateAdaptor</span>(<span class="type">AppDelegate</span>.<span class="keyword">self</span>) <span class="keyword">var</span> delegate</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">WindowGroup</span> &#123;</span><br><span class="line">            <span class="type">ContentView</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><code>AppleDelegate</code>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AppDelegate</span>: <span class="title class_">NSObject</span>, <span class="title class_">UIApplicationDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="type">UIApplication</span>.<span class="params">LaunchOptionsKey</span> : <span class="keyword">Any</span>]<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;启动&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中使用了<code>@UIApplicationDelegateAdaptor</code>包装器。如果还需要使用<code>SceneDelegate</code>来调用更多的生命周期函数，可以先定义一个<code>SceneDelegate</code>的类：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SceneDelegate</span>: <span class="title class_">NSObject</span>,<span class="title class_">UIWindowSceneDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">scene</span>(<span class="keyword">_</span> <span class="params">scene</span>: <span class="type">UIScene</span>, <span class="params">willConnectTo</span> <span class="params">session</span>: <span class="type">UISceneSession</span>, <span class="params">options</span> <span class="params">connectionOptions</span>: <span class="type">UIScene</span>.<span class="type">ConnectionOptions</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">_</span> <span class="operator">=</span> (scene <span class="keyword">as?</span> <span class="type">UIWindowScene</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">sceneDidEnterBackground</span>(<span class="keyword">_</span> <span class="params">scene</span>: <span class="type">UIScene</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;场景进入后台&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>AppDelegate</code>中添加下面这个函数，让它和<code>SceneDelegate</code>进行关联：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">configurationForConnecting</span> <span class="params">connectingSceneSession</span>: <span class="type">UISceneSession</span>, <span class="params">options</span>: <span class="type">UIScene</span>.<span class="type">ConnectionOptions</span>) -&gt; <span class="type">UISceneConfiguration</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> sceneConfig: <span class="type">UISceneConfiguration</span> <span class="operator">=</span> <span class="type">UISceneConfiguration</span>(name: <span class="literal">nil</span>, sessionRole: connectingSceneSession.role)</span><br><span class="line">       sceneConfig.delegateClass <span class="operator">=</span> <span class="type">SceneDelegate</span>.<span class="keyword">self</span></span><br><span class="line">       <span class="keyword">return</span> sceneConfig</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:red"><strong>需要注意的是</strong></span>，但我们使用<code>AppDelegate</code>来管理 app 的生命周期时，需要针对不同的平台进行判断。相反，使用后面的这种方式则不用。</p>
<blockquote>
<p><strong>Note</strong></p>
<p>If you enable scene support in your app, iOS always uses your scene delegates in iOS 13 and later. In iOS 12 and earlier, the system uses your app delegate.</p>
</blockquote>
<p>在<strong>iOS 14</strong>之后，SwiftUI 中提供了一种新的方式来管理 app 的生命周期：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppLifeycleApp</span>: <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="meta">@Environment</span>(\.scenePhase) <span class="keyword">var</span> scenePhase</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">WindowGroup</span> &#123;</span><br><span class="line">            <span class="type">ContentView</span>()</span><br><span class="line">                .onChange(of: scenePhase, &#123;</span><br><span class="line">                    <span class="keyword">switch</span> scenePhase &#123;</span><br><span class="line">                    <span class="keyword">case</span> .background:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;进入后台&quot;</span>)</span><br><span class="line">                    <span class="keyword">case</span> .inactive:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;不活跃&quot;</span>)</span><br><span class="line">                    <span class="keyword">case</span> .active:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;活跃&quot;</span>)</span><br><span class="line">                    <span class="keyword">@unknown</span> default:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;默认&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们是直接使用<code>Environment</code>中的<code>scenePhase</code>来获取当前 app 的状态。</p>
<blockquote>
<p>参考文章： <strong><a href="https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle?source=post_page-----e9be79e75fef--------------------------------">Managing  your app’s life cycle </a></strong></p>
</blockquote>
]]></content>
      <categories>
        <category>SwiftUI 进阶</category>
      </categories>
      <tags>
        <tag>SiwftUI</tag>
        <tag>scenePhase</tag>
        <tag>AppDelegate</tag>
        <tag>SceneDelegate</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI之使用 Combine 和 ViewModel 构建一个注册页面</title>
    <url>/posts/cd699355.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，<strong>Combine</strong> 是<strong>声明式UI</strong>的核心关键。接下来，我们将构建一个包含三个<code>TextField</code>的注册页面，以及实现常见表单验证来学习和掌握<strong>Combine</strong>的基础原理。</p>
<h3 id="构建基础页面"><a href="#构建基础页面" class="headerlink" title="构建基础页面"></a>构建基础页面</h3><p>首先，我们构建下面的一个基础界面：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311011348656.png" style="zoom:10%"/>

<span id="more"></span>

<p><code>ContentView.swift</code>视图部分：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> userName: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> password: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> confirmationPassword: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;创建账号&quot;</span>)</span><br><span class="line">                .font(.system(.largeTitle, design: .rounded))</span><br><span class="line">                .bold()</span><br><span class="line">                .padding(.bottom, <span class="number">30</span>)</span><br><span class="line">            <span class="type">FormTextField</span>(fieldValue: <span class="variable">$userName</span>, fieldName: <span class="string">&quot;用户名&quot;</span>)</span><br><span class="line">            <span class="type">RequirementText</span>(text: <span class="string">&quot;用户名不能少于四个字符&quot;</span>)</span><br><span class="line">                .padding()</span><br><span class="line">            <span class="type">FormTextField</span>(isSecure: <span class="literal">true</span>,fieldValue: <span class="variable">$password</span>, fieldName: <span class="string">&quot;密码&quot;</span>)</span><br><span class="line">            <span class="type">RequirementText</span>(iconName: <span class="string">&quot;lock.open&quot;</span>, text: <span class="string">&quot;密码至少为8个字符&quot;</span>,isStrikeThrough: <span class="literal">true</span>)</span><br><span class="line">                .padding()</span><br><span class="line">            </span><br><span class="line">            <span class="type">FormTextField</span>(isSecure: <span class="literal">true</span>, fieldValue: <span class="variable">$confirmationPassword</span>, fieldName: <span class="string">&quot;二次确认密码&quot;</span>)</span><br><span class="line">            <span class="type">RequirementText</span>(text: <span class="string">&quot;密码前后输入必须一致&quot;</span>,isStrikeThrough: <span class="literal">false</span>)</span><br><span class="line">                .padding()</span><br><span class="line">                .padding(.bottom, <span class="number">50</span>)</span><br><span class="line">            <span class="type">SignInButton</span>()</span><br><span class="line">            <span class="type">FooterView</span>()</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FormTextField</code>视图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表单输入框</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FormTextField</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isSecure: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> fieldValue: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> fieldName: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> isSecure &#123;</span><br><span class="line">                <span class="type">SecureField</span>(fieldName, text: <span class="variable">$fieldValue</span>)</span><br><span class="line">                    .font(.system(size: <span class="number">20</span>, weight: .semibold, design: .rounded))</span><br><span class="line">                    .padding(.horizontal)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">TextField</span>(fieldName, text: <span class="variable">$fieldValue</span>)</span><br><span class="line">                    .font(.system(size: <span class="number">20</span>, weight: .semibold, design: .rounded))</span><br><span class="line">                    .padding(.horizontal)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Divider</span>()</span><br><span class="line">                .frame(height: <span class="number">1</span>)</span><br><span class="line">                .background(<span class="type">Color</span>(red: <span class="number">240</span><span class="operator">/</span><span class="number">255</span>, green: <span class="number">240</span><span class="operator">/</span><span class="number">255</span>, blue: <span class="number">240</span><span class="operator">/</span><span class="number">255</span>))</span><br><span class="line">                .padding(.horizontal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>RequirementText</code>视图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RequirementText</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> iconName:<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;xmark.square&quot;</span></span><br><span class="line">    <span class="keyword">var</span> iconColor: <span class="type">Color</span> <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">251</span><span class="operator">/</span><span class="number">255</span>, green: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>, blue: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>)</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> isStrikeThrough: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span>  <span class="comment">//是否划线</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: iconName)</span><br><span class="line">                .foregroundStyle(iconColor)</span><br><span class="line">            <span class="type">Text</span>(text)</span><br><span class="line">                .font(.system(.body, design: .rounded))</span><br><span class="line">                .foregroundStyle(.secondary)</span><br><span class="line">                .strikethrough(isStrikeThrough)</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SignInButton</code>视图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登录按钮</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SignInButton</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;, label: &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;登录&quot;</span>)</span><br><span class="line">                .font(.system(.body, design: .rounded))</span><br><span class="line">                .foregroundStyle(.white)</span><br><span class="line">                .bold()</span><br><span class="line">                .padding()</span><br><span class="line">                .frame(minWidth: <span class="number">0</span>, maxWidth: .infinity)</span><br><span class="line">                .background(<span class="type">LinearGradient</span>(gradient: <span class="type">Gradient</span>(colors: [<span class="type">Color</span>(red: <span class="number">251</span><span class="operator">/</span><span class="number">255</span>, green: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>, blue: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>), <span class="type">Color</span>(red: <span class="number">253</span><span class="operator">/</span><span class="number">255</span>, green: <span class="number">193</span><span class="operator">/</span><span class="number">255</span>, blue: <span class="number">104</span><span class="operator">/</span><span class="number">255</span>)]), startPoint: .leading, endPoint: .trailing))</span><br><span class="line">                .clipShape(<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>))</span><br><span class="line">                .padding(.horizontal)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FooterView</code>视图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 底部视图</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FooterView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;已有账号?&quot;</span>)</span><br><span class="line">                .font(.system(.body, design: .rounded))</span><br><span class="line">                .bold()</span><br><span class="line">                .padding()</span><br><span class="line">            <span class="type">Button</span>(action: &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;, label: &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;注册&quot;</span>)</span><br><span class="line">                    .font(.system(.body, design: .rounded))</span><br><span class="line">                    .bold()</span><br><span class="line">                    .foregroundStyle(<span class="type">Color</span>(red: <span class="number">251</span><span class="operator">/</span><span class="number">255</span>, green: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>, blue: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>))</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding(.top, <span class="number">50</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初识Combine"><a href="#初识Combine" class="headerlink" title="初识Combine"></a>初识Combine</h3><blockquote>
<p>The Combine framework provides a declarative Swift API for processing values over time. These values can represent many kinds of asynchronous events. Combine declares <em>publishers</em> to expose values that can change over time, and <em>subscribers</em> to receive those values from the publishers.</p>
<ul>
<li>The <a href="https://developer.apple.com/documentation/combine/publisher"><code>Publisher</code></a> protocol declares a type that can deliver a sequence of values over time. Publishers have <em>operators</em> to act on the values received from upstream publishers and republish them.</li>
<li>At the end of a chain of publishers, a <a href="https://developer.apple.com/documentation/combine/subscriber"><code>Subscriber</code></a> acts on elements as it receives them. Publishers only emit values when explicitly requested to do so by subscribers. This puts your subscriber code in control of how fast it receives events from the publishers it’s connected to.</li>
</ul>
<p>Several Foundation types expose their functionality through publishers, including <a href="https://developer.apple.com/documentation/foundation/timer"><code>Timer</code></a>, <a href="https://developer.apple.com/documentation/foundation/notificationcenter"><code>NotificationCenter</code></a>, and <a href="https://developer.apple.com/documentation/foundation/urlsession"><code>URLSession</code></a>. Combine also provides a built-in publisher for any property that’s compliant with Key-Value Observing.</p>
<p>You can combine the output of multiple publishers and coordinate their interaction. For example, you can subscribe to updates from a text field’s publisher, and use the text to perform URL requests. You can then use another publisher to process the responses and use them to update your app.</p>
<p>By adopting Combine, you’ll make your code easier to read and maintain, by centralizing your event-processing code and eliminating troublesome techniques like nested closures and convention-based callbacks.</p>
</blockquote>
<p>以上是 Apple 关于<strong>Combine</strong>的介绍，根据这个介绍，我们可以知道<strong>Publisher</strong> 和<strong>Subscriber</strong>是<strong>Combine</strong>中两个重要的元素。</p>
<p>在<strong>Combine</strong>中，<strong>Publisher(发布者)<strong>发送事件，</strong>Subscriber(订阅者)<strong>订阅后接受来自</strong>Publisher</strong>的值。以<code>TextField</code>为例，当使用<strong>Combine</strong>时，每一次的键盘输入都会触发一个值变化的事件，然后<strong>Subscriber</strong>会去监听这些值的的变化，接收到这些值的变化后，就可以做进一步的操作，例如验证。</p>
<p>接着，我们来写一个验证器来对整个注册的表单进行验证。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FormValidator</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> isReadySubmit: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Combine-和-MVVM"><a href="#Combine-和-MVVM" class="headerlink" title="Combine 和 MVVM"></a>Combine 和 MVVM</h3><p><strong>MVVM</strong>的全称是<strong>Model-View-ViewModel</strong>，它是一种开发中常用的设计模式。在实际的 app 开发中，随着项目的越来越复杂，我们不会推荐把所有的内容都放在一个单一的视图中。一般情况下，我们会将视图拆分为<strong>View</strong>和<strong>View Model</strong>两个部分。</p>
<ul>
<li><strong>View</strong>主要负责界面的布局；</li>
<li><strong>View Model</strong>负责持有视图的状态和数据。</li>
</ul>
<p>在我们即将实现的这个例子中，<strong>View Model</strong>持有的数据是：</p>
<ul>
<li>UserName </li>
<li>Password</li>
<li>Password confirm</li>
</ul>
<p>以及一些状态：</p>
<ul>
<li>用户名不能少于 4 个字符；</li>
<li>密码不能少于 8 个字符；</li>
<li>密码只能包含小写字母；</li>
<li>前后两次密码的输入必须一致</li>
</ul>
<p>综上所述，这里的<strong>View Model</strong>将有 7 个属性，并且每一个属性发生变化是都会通知它的订阅者。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FormValidator</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> username: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> password: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> passwordConfirm: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> isUsernameLengthValid: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> isPasswordLengthValid: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> isPasswordCapitalLetter: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> isPasswordConfirmValid: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><p>给<code>FormValidator</code>添加一个无参的初始化方法，在这个方法里面对各个属性进行验证和赋值。</p>
<p><code>username</code>的验证：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="variable">$username</span></span><br><span class="line">       .receive(on: <span class="type">RunLoop</span>.main)</span><br><span class="line">       .map &#123; username <span class="keyword">in</span></span><br><span class="line">           <span class="keyword">return</span> username.count <span class="operator">&gt;=</span> <span class="number">4</span></span><br><span class="line">       &#125;</span><br><span class="line">       .assign(to: \.isUsernameLengthValid, on: <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>

<p>在上面的代码中， <code>$username</code>是我们想要监听的值，因为我们是正在订阅一个 UI 的变化，所以我们调用了<code>receive(on:)</code>方法来确保订阅者能接收到来自主线程的值，即<code>RunLoop.main</code>。</p>
<p>接着，我们使用<code>map</code>这个高阶函数来判断字符串的长度是否满足要求，如果满足则返回<code>true</code>，否则返回<code>false</code>。</p>
<p>最后就是使用<strong>Combine</strong>提供的内置订阅者<code>assign</code>将判断的结果转换给到我们的<code>isUsernameLengthValid</code>属性。</p>
<p>同理，针对<code>password</code>和<code>passwordConfirm</code>的验证如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证长度是否满足</span></span><br><span class="line">      <span class="variable">$password</span></span><br><span class="line">          .receive(on: <span class="type">RunLoop</span>.main)</span><br><span class="line">          .map&#123; password <span class="keyword">in</span></span><br><span class="line">              <span class="keyword">return</span> password.count <span class="operator">&gt;=</span> <span class="number">8</span></span><br><span class="line">          &#125;</span><br><span class="line">          .assign(to: \.isPasswordLengthValid, on: <span class="keyword">self</span>)</span><br><span class="line">      </span><br><span class="line">      <span class="variable">$password</span></span><br><span class="line">          .receive(on: <span class="type">RunLoop</span>.main)</span><br><span class="line">          .map &#123; password <span class="keyword">in</span></span><br><span class="line">              <span class="comment">// 使用正则判断</span></span><br><span class="line">              <span class="keyword">let</span> pattern <span class="operator">=</span> <span class="string">&quot;[A-Z]&quot;</span></span><br><span class="line">              <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">_</span> <span class="operator">=</span> password.range(of: pattern, options: .regularExpression) &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          .assign(to: \.isPasswordCapitalLetter, on: <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>

<p>针对密码的二次验证，使用下面的方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Publishers</span>.<span class="type">CombineLatest</span>(<span class="variable">$password</span>, <span class="variable">$passwordConfirm</span>)</span><br><span class="line">            .receive(on: <span class="type">RunLoop</span>.main)</span><br><span class="line">            .map&#123; (password, passwordConfirm) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> <span class="operator">!</span>passwordConfirm.isEmpty <span class="operator">&amp;&amp;</span> (passwordConfirm <span class="operator">==</span> password)</span><br><span class="line">            &#125;</span><br><span class="line">            .assign(to: \.isPasswordConfirmValid, on: <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>

<p>另外，对于<code>assign</code>方法，它返回的是一个<code>cancellable</code>的实例对象，我们能够使用这个对象在合适的时候需要这个订阅。这里，我们还需要将返回的每一个实例对象进行存储，即调用<code>store</code>方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> cancellableSet: <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt; <span class="operator">=</span> []</span><br></pre></td></tr></table></figure>

<p>将每一个实例对象存储到这个集合中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.store(in: <span class="operator">&amp;</span>cancellableSet)</span><br></pre></td></tr></table></figure>



<h3 id="应用定义好的-ViewModel-管理状态"><a href="#应用定义好的-ViewModel-管理状态" class="headerlink" title="应用定义好的 ViewModel 管理状态"></a>应用定义好的 ViewModel 管理状态</h3><p>回到我们的视图部分，将之前使用<code>@State</code>定义的状态值替换为使用<code>ViewModel</code>来管理。</p>
<p>修改<code>ContentView.swift</code>中的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">private</span> <span class="keyword">var</span> formValidator: <span class="type">FormValidator</span> <span class="operator">=</span> <span class="type">FormValidator</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;创建账号&quot;</span>)</span><br><span class="line">                .font(.system(.largeTitle, design: .rounded))</span><br><span class="line">                .bold()</span><br><span class="line">                .padding(.bottom, <span class="number">30</span>)</span><br><span class="line">            <span class="type">FormTextField</span>(fieldValue: <span class="variable">$formValidator</span>.username, fieldName: <span class="string">&quot;用户名&quot;</span>)</span><br><span class="line">            <span class="type">RequirementText</span>(iconColor:formValidator.isUsernameLengthValid <span class="operator">?</span> <span class="type">Color</span>.secondary : <span class="type">Color</span>(red: <span class="number">251</span><span class="operator">/</span><span class="number">255</span>, green: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>, blue: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>) , text: <span class="string">&quot;用户名不能少于四个字符&quot;</span>, isStrikeThrough: formValidator.isUsernameLengthValid)</span><br><span class="line">                .padding()</span><br><span class="line">            <span class="type">FormTextField</span>( isSecure: <span class="literal">true</span>,fieldValue: <span class="variable">$formValidator</span>.password, fieldName: <span class="string">&quot;密码&quot;</span>)</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">RequirementText</span>(iconName: <span class="string">&quot;lock.open&quot;</span>, iconColor: formValidator.isPasswordLengthValid <span class="operator">?</span> <span class="type">Color</span>.secondary : <span class="type">Color</span>(red: <span class="number">251</span><span class="operator">/</span><span class="number">255</span>, green: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>, blue: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>), text: <span class="string">&quot;密码至少为8个字符&quot;</span>,isStrikeThrough: formValidator.isPasswordLengthValid)</span><br><span class="line">                <span class="type">RequirementText</span>(iconName: <span class="string">&quot;lock.open&quot;</span>, iconColor: formValidator.isPasswordLengthValid <span class="operator">?</span> <span class="type">Color</span>.secondary : <span class="type">Color</span>(red: <span class="number">251</span><span class="operator">/</span><span class="number">255</span>, green: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>, blue: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>), text: <span class="string">&quot;密码至少包含一个大写字母&quot;</span>,isStrikeThrough: formValidator.isPasswordCapitalLetter)</span><br><span class="line">            &#125;</span><br><span class="line">            .padding()</span><br><span class="line">            <span class="type">FormTextField</span>(isSecure: <span class="literal">true</span>, fieldValue: <span class="variable">$formValidator</span>.passwordConfirm, fieldName: <span class="string">&quot;二次确认密码&quot;</span>)</span><br><span class="line">            <span class="type">RequirementText</span>( iconColor: formValidator.isPasswordConfirmValid <span class="operator">?</span> <span class="type">Color</span>.secondary : <span class="type">Color</span>(red: <span class="number">251</span><span class="operator">/</span><span class="number">255</span>, green: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>, blue: <span class="number">128</span><span class="operator">/</span><span class="number">255</span>) ,text: <span class="string">&quot;密码前后输入必须一致&quot;</span>,isStrikeThrough: formValidator.isPasswordConfirmValid)</span><br><span class="line">                .padding()</span><br><span class="line">                .padding(.bottom, <span class="number">50</span>)</span><br><span class="line">            <span class="type">SignInButton</span>()</span><br><span class="line">            <span class="type">FooterView</span>()</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，效果如下：</p>
<p><video controls="controls" width="20%" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311011639411.mp4"></video></p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Combine</tag>
        <tag>MMVM</tag>
        <tag>Form</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI之实现App Store的Hero动画</title>
    <url>/posts/cce56264.html</url>
    <content><![CDATA[<p>最终实现的效果如下：</p>
<p><video width="30%" controls="controls" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311280835667.mp4"></video></p>
<span id="more"></span>

<h3 id="创建头部视图"><a href="#创建头部视图" class="headerlink" title="创建头部视图"></a>创建头部视图</h3><p>定义一个名为<code>HeaderView.swift</code>的文件，在这个文件里面编写头部视图的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HeaderView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">30</span>, content: &#123;</span><br><span class="line">            <span class="type">HStack</span>(alignment: .top ,content: &#123;</span><br><span class="line">                <span class="type">VStack</span>(alignment: .leading ,spacing: <span class="number">8</span>, content: &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Today&quot;</span>)</span><br><span class="line">                        .font(.title.bold())</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;26 November&quot;</span>)</span><br><span class="line">                        .font(.callout.bold())</span><br><span class="line">                        .opacity(<span class="number">0.8</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">                .frame(maxWidth: .infinity, alignment: .leading)</span><br><span class="line">                <span class="type">Image</span>(<span class="string">&quot;post1&quot;</span>)</span><br><span class="line">                    .resizable()</span><br><span class="line">                    .scaledToFill()</span><br><span class="line">                    .frame(width: <span class="number">40</span>, height: <span class="number">40</span>)</span><br><span class="line">                    .clipShape(<span class="type">Circle</span>())</span><br><span class="line">            &#125;)</span><br><span class="line">            .padding(.horizontal)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通过-ViewBuilder定义一个函数用来实现一个-CardView"><a href="#通过-ViewBuilder定义一个函数用来实现一个-CardView" class="headerlink" title="通过@ViewBuilder定义一个函数用来实现一个 CardView"></a>通过@ViewBuilder定义一个函数用来实现一个 CardView</h3><p>首先，定义一个模型数据用来统一管理卡片数据：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardModel</span>: <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> <span class="operator">=</span> <span class="type">UUID</span>().uuidString</span><br><span class="line">    <span class="keyword">var</span> appName:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> appDescription:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> appLogo: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> bannerTitle: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> platformTitle: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> artwork:<span class="type">String</span></span><br><span class="line">  	<span class="keyword">var</span> color: <span class="type">Color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义<code>CardView</code>函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ViewBuilder</span></span><br><span class="line">   <span class="keyword">func</span> <span class="title function_">CardView</span>(<span class="params">item</span>: <span class="type">CardModel</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">       <span class="type">VStack</span>(alignment: .leading, spacing:<span class="number">0</span>, content: &#123;</span><br><span class="line">           <span class="type">ZStack</span>(alignment: .topLeading, content: &#123;</span><br><span class="line">               <span class="type">GeometryReader</span>(content: &#123; geometry <span class="keyword">in</span></span><br><span class="line">                   <span class="keyword">let</span> size <span class="operator">=</span> geometry.size</span><br><span class="line">                   <span class="type">Image</span>(item.artwork)</span><br><span class="line">                       .resizable()</span><br><span class="line">                       .aspectRatio(contentMode: .fill)</span><br><span class="line">                       .frame(width: size.width, height: size.height)</span><br><span class="line">                       .clipped()</span><br><span class="line">                   </span><br><span class="line">                   <span class="type">VStack</span>(alignment: .leading, content: &#123;</span><br><span class="line">                       <span class="type">Spacer</span>()</span><br><span class="line">                       <span class="type">Text</span>(item.platformTitle)</span><br><span class="line">                           .font(.callout.bold())</span><br><span class="line">                       <span class="type">Text</span>(item.bannerTitle)</span><br><span class="line">                           .font(.title.bold())</span><br><span class="line">                       <span class="type">Text</span>(item.appDescription)</span><br><span class="line">                           .font(.title3.bold())</span><br><span class="line">                   &#125;)</span><br><span class="line">                   .frame(maxWidth: .infinity, alignment: .leading)</span><br><span class="line">                   .padding()</span><br><span class="line">                   .foregroundStyle(.white)</span><br><span class="line">                   .background(<span class="type">LinearGradient</span>(colors: [<span class="type">Color</span>.clear, item.color.opacity(<span class="number">0.8</span>)], startPoint: .top, endPoint: .bottom)) <span class="comment">// 设置渐变背景</span></span><br><span class="line">               &#125;)</span><br><span class="line">               .frame(height: <span class="number">400</span>)</span><br><span class="line">               <span class="comment">//.clipShape(.rect(cornerRadius: 20))</span></span><br><span class="line">               .clipShape(.rect(topLeadingRadius: <span class="number">20</span>, topTrailingRadius: <span class="number">20</span>)) <span class="comment">// 设置上边两个角的圆角</span></span><br><span class="line">           &#125;)</span><br><span class="line">           <span class="type">HStack</span>(spacing: <span class="number">12</span>, content: &#123;</span><br><span class="line">               <span class="type">Image</span>(item.appLogo)</span><br><span class="line">                   .resizable()</span><br><span class="line">                   .aspectRatio(contentMode: .fill)</span><br><span class="line">                   .frame(width: <span class="number">50</span>, height: <span class="number">50</span>)</span><br><span class="line">                   .clipShape(.rect(cornerRadius: <span class="number">15</span>))</span><br><span class="line">               <span class="type">VStack</span>( alignment: .leading, spacing: <span class="number">4</span>, content: &#123;</span><br><span class="line">                   <span class="type">Text</span>(item.platformTitle)</span><br><span class="line">                       .font(.caption.bold())</span><br><span class="line">                   <span class="type">Text</span>(item.bannerTitle)</span><br><span class="line">                       .font(.title3.bold())</span><br><span class="line">                   <span class="type">Text</span>(item.appDescription)</span><br><span class="line">                       .font(.caption.bold())</span><br><span class="line">               &#125;)</span><br><span class="line">               .foregroundStyle(.white)</span><br><span class="line">               </span><br><span class="line">               <span class="type">Spacer</span>()</span><br><span class="line">               <span class="type">Button</span>(action: &#123;</span><br><span class="line">                   </span><br><span class="line">               &#125;, label: &#123;</span><br><span class="line">                   <span class="type">Text</span>(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">                       .fontWeight(.bold)</span><br><span class="line">                       .foregroundStyle(.blue)</span><br><span class="line">                       .padding(.vertical, <span class="number">8</span>)</span><br><span class="line">                       .padding(.horizontal, <span class="number">20</span>)</span><br><span class="line">                       .background &#123;</span><br><span class="line">                           <span class="type">Capsule</span>()</span><br><span class="line">                               .fill(.ultraThinMaterial)</span><br><span class="line">                       &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">           &#125;)</span><br><span class="line">           .padding()</span><br><span class="line">           .background(item.color)</span><br><span class="line">           .clipShape(.rect(bottomLeadingRadius: <span class="number">20</span>, bottomTrailingRadius: <span class="number">20</span>))</span><br><span class="line">       &#125;)</span><br><span class="line">       .padding(.horizontal)</span><br><span class="line">       .padding(.bottom)</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="在-ContentView-页面将HeaderView和CardView进行组合"><a href="#在-ContentView-页面将HeaderView和CardView进行组合" class="headerlink" title="在 ContentView 页面将HeaderView和CardView进行组合"></a>在 ContentView 页面将<code>HeaderView</code>和<code>CardView</code>进行组合</h3><p>首先，定义一个元素类型为<code>CardModel</code>的数组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cardItems: [<span class="type">CardModel</span>] <span class="operator">=</span> [</span><br><span class="line">    <span class="type">CardModel</span>(appName: <span class="string">&quot;Hello Kitty Island Adventure&quot;</span>, appDescription: <span class="string">&quot;Island Advanture awaits&quot;</span>, appLogo: <span class="string">&quot;logo1&quot;</span>, bannerTitle: <span class="string">&quot;Adventure with Hello Kitty!&quot;</span>, platformTitle: <span class="string">&quot;Apple Arcade&quot;</span>, artwork: <span class="string">&quot;post1&quot;</span>, color: <span class="type">Color</span>.pink),</span><br><span class="line">    <span class="type">CardModel</span>(appName: <span class="string">&quot;Lies of P&quot;</span>, appDescription: <span class="string">&quot;Deception Shatters Innocence&quot;</span>, appLogo: <span class="string">&quot;logo2&quot;</span>, bannerTitle: <span class="string">&quot;Lies of P&quot;</span>, platformTitle: <span class="string">&quot;Apple Arcade&quot;</span>, artwork: <span class="string">&quot;post2&quot;</span>, color: <span class="type">Color</span>.black),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>接着，就是在<code>ContentView</code>的<code>body</code>部分进行布局：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">       <span class="type">ScrollView</span>(showsIndicators: <span class="literal">false</span>, content: &#123;</span><br><span class="line">           <span class="comment">// 头部</span></span><br><span class="line">           <span class="type">HeaderView</span>()</span><br><span class="line">           <span class="type">ForEach</span>(cardItems) &#123; item <span class="keyword">in</span></span><br><span class="line">               <span class="type">CardView</span>(item: item)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>此时的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202311280837429.png" style="zoom:20%"/>



<h3 id="自定义一个按钮样式"><a href="#自定义一个按钮样式" class="headerlink" title="自定义一个按钮样式"></a>自定义一个按钮样式</h3><p>首先将<code>CardView</code>作为<code>Button</code>的<code>label</code>部分进行包裹，让它可以被进行点击：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">ForEach</span>(cardItems) &#123; item <span class="keyword">in</span></span><br><span class="line">               <span class="type">Button</span>(action: &#123;</span><br><span class="line">                   </span><br><span class="line">               &#125;, label: &#123;</span><br><span class="line">                   <span class="type">CardView</span>(item: item)</span><br><span class="line">                       .multilineTextAlignment(.leading)</span><br><span class="line">               &#125;)</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>接着就是通过实现<code>ButtonStyle</code>实现一个新的按钮样式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ScaleButtonStyle</span>: <span class="title class_">ButtonStyle</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeBody</span>(<span class="params">configuration</span>: <span class="type">Configuration</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        configuration.label</span><br><span class="line">            .scaleEffect(configuration.isPressed <span class="operator">?</span> <span class="number">0.94</span> : <span class="number">1</span>) <span class="comment">// 添加点击之后的缩放效果</span></span><br><span class="line">            .animation(.easeInOut, value: configuration.isPressed) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将<code>CardView</code>外层的<code>button</code>添加这个风格：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.buttonStyle(<span class="type">ScaleButtonStyle</span>())</span><br></pre></td></tr></table></figure>

<p>此时，当我们再次点击任意一个<code>CardView</code>后将会有一个缩放的效果。</p>
<h3 id="显示详情页"><a href="#显示详情页" class="headerlink" title="显示详情页"></a>显示详情页</h3><p>首先，删除添加到<code>CardView</code>中<code>ZStack</code>的下面两个修饰器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.padding(.horizontal)</span><br><span class="line">.padding(.bottom)</span><br></pre></td></tr></table></figure>

<p>在头部定义两个状态变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> currentModel: <span class="type">CardModel</span>?</span><br><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> showDetail: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span> </span><br></pre></td></tr></table></figure>

<p>给<code>CardView</code>添加一个<code>scaleEffect</code>修饰器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.scaleEffect(currentModel<span class="operator">?</span>.id <span class="operator">==</span> item.id <span class="operator">&amp;&amp;</span> showDetail <span class="operator">?</span> <span class="number">1.0</span> : <span class="number">0.90</span>) </span><br></pre></td></tr></table></figure>

<p>在按钮的<code>action</code>部分使用<code>withAnimation</code>添加动画：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">withAnimation(.interactiveSpring(response: <span class="number">0.6</span>, dampingFraction: <span class="number">0.7</span>, blendDuration: <span class="number">0.7</span>)) &#123;</span><br><span class="line">                        currentModel <span class="operator">=</span> item</span><br><span class="line">                        showDetail <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>给<code>ScrollView</code>添加一个<code>overlay</code>，然后在里面显示详情页面。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.overlay &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> currentModel <span class="operator">=</span> currentModel, showDetail  &#123;</span><br><span class="line">                 <span class="type">DetailView</span>(item: currentModel)</span><br><span class="line">                    .ignoresSafeArea(edges: [.top]) <span class="comment">// 忽略顶部的安全区</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>DetailView</code>依然使用函数的方式实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ViewBuilder</span></span><br><span class="line">   <span class="keyword">func</span> <span class="title function_">DetailView</span>(<span class="params">item</span>: <span class="type">CardModel</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">       <span class="type">ScrollView</span>(.vertical, showsIndicators: <span class="literal">false</span>) &#123;</span><br><span class="line">           <span class="type">VStack</span> &#123;</span><br><span class="line">               <span class="type">CardView</span>(item: item)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       .transition(.identity)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在头部定义一个<code>Namespace</code>的变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Namespace</span> <span class="keyword">var</span> animation</span><br></pre></td></tr></table></figure>

<p>将这个变量给到<code>CardView</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.matchedGeometryEffect(id: item.id, in: animation)</span><br></pre></td></tr></table></figure>

<p>此时点击<code>CardView</code>的话已经能看到一个简单的动画效果了。</p>
<p>新增一个状态变量用来记录当前是否是详情页面：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> isAniamtionView: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>当<code>DetailView</code>页面出现的时候将这个值赋值为<code>true</code>，即：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.onAppear &#123;</span><br><span class="line">            withAnimation(.interactiveSpring(response: <span class="number">0.6</span>, dampingFraction: <span class="number">0.7</span>, blendDuration: <span class="number">0.7</span>)) &#123;</span><br><span class="line">                isAniamtionView <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>另外就是隐藏其他的<code>CardView</code>和取消底部的圆角，即给<code>ForEach</code>的 <code>Button</code>添加<code>opacity</code>修饰器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.opacity(showDetail <span class="operator">?</span> (currentModel<span class="operator">?</span>.id <span class="operator">==</span>  item.id <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>) : <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>修改<code>CardView</code>的<code>clipShape</code>修饰器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.clipShape(.rect(bottomLeadingRadius: isAniamtionView <span class="operator">?</span>  <span class="number">0</span> : <span class="number">20</span> , bottomTrailingRadius: isAniamtionView <span class="operator">?</span> <span class="number">0</span> : <span class="number">20</span>))</span><br></pre></td></tr></table></figure>

<p>在<code>DetailView</code>的右上角添加一个关闭的按钮，点击后关闭详情页。这里可以使用添加一个<code>overlay</code>来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.overlay(alignment: .topTrailing ,content: &#123;</span><br><span class="line">            <span class="type">Button</span>(action: &#123;</span><br><span class="line">                withAnimation(.interactiveSpring(response: <span class="number">0.6</span>, dampingFraction: <span class="number">0.7</span>, blendDuration: <span class="number">0.7</span>)) &#123;</span><br><span class="line">                    isAniamtionView <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                withAnimation(.interactiveSpring(response: <span class="number">0.6</span>, dampingFraction: <span class="number">0.7</span>, blendDuration: <span class="number">0.7</span>).delay(<span class="number">0.05</span>)) &#123;</span><br><span class="line">                    currentModel <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">                    showDetail <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, label: &#123;</span><br><span class="line">                <span class="type">Image</span>(systemName: <span class="string">&quot;xmark.circle.fill&quot;</span>)</span><br><span class="line">                    .font(.title)</span><br><span class="line">                    .foregroundStyle(.white)</span><br><span class="line">                    .padding(.trailing, <span class="number">12</span>)</span><br><span class="line">              			.padding(.top, <span class="number">36</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>接着，给<code>DetailView</code>的详情页面添加内容介绍。在<code>DeatilView</code>的<code>CardView</code>下面添加介绍和分享按钮：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span>(spacing: <span class="number">25</span>, content: &#123;</span><br><span class="line">                    <span class="type">Text</span>(dummyText)</span><br><span class="line">                        .multilineTextAlignment(.leading)</span><br><span class="line">                        .lineSpacing(<span class="number">10</span>)</span><br><span class="line">                        .padding(.bottom, <span class="number">20</span>)</span><br><span class="line">                        .padding(.horizontal, <span class="number">10</span>)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">Divider</span>()</span><br><span class="line">                    <span class="type">Button</span>(action: &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;, label: &#123;</span><br><span class="line">                        <span class="type">Label</span>(</span><br><span class="line">                            title: &#123; <span class="type">Text</span>(<span class="string">&quot;Share Story&quot;</span>) &#125;,</span><br><span class="line">                            icon: &#123; <span class="type">Image</span>(systemName: <span class="string">&quot;suqare.and.arrow.up.fill&quot;</span>) &#125;</span><br><span class="line">                        )</span><br><span class="line">                        .foregroundStyle(.black)</span><br><span class="line">                        .padding(.vertical, <span class="number">5</span>)</span><br><span class="line">                        .padding(.horizontal, <span class="number">25</span>)</span><br><span class="line">                        .background&#123;</span><br><span class="line">                            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>, style: .continuous)</span><br><span class="line">                                .fill(.ultraThinMaterial)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure>

<p>到此基本的动画效果就完成了，后续可以给介绍的文字也添加动画。</p>
]]></content>
      <categories>
        <category>SwiftUI 进阶</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>withAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI之形状绘制</title>
    <url>/posts/69def74.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，可以使用内置的形状或者根据路径自定义形状。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202308261003030.png" style="zoom:20%;" />

<h3 id="SwiftUI-中内置的形状"><a href="#SwiftUI-中内置的形状" class="headerlink" title="SwiftUI 中内置的形状"></a>SwiftUI 中内置的形状</h3><p>SwiftUI 中给我们提供了五种常用内置形状：矩形，圆角矩形，圆形，椭圆形和胶囊形状。</p>
<span id="more"></span>

<h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><p>在 SwiftUI 中使用<span style="color:red"> <strong><code>Rectangle</code></strong></span> 类创建一个矩形。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Rectangle</span>()</span><br><span class="line">      .fill(.gray) <span class="comment">// 矩形填充的颜色</span></span><br><span class="line">      .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h4 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h4><p>在 SwiftUI 中使用<span style="color:red"> <strong><code>RoundedRectangle</code></strong></span> 类创建一个圆角矩形，不过它的初始化方法给我们提供了两个属性， <code>cornerSize</code> 和 <code>cornerRadius</code> 。通过配置这两个属性我们都可以创建一个圆角矩形。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过圆角尺寸创建圆角矩形</span></span><br><span class="line"><span class="type">RoundedRectangle</span>(cornerSize: <span class="type">CGSize</span>(width: <span class="number">8</span>, height: <span class="number">8</span>))</span><br><span class="line">          .fill(.red)</span><br><span class="line">          .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过圆角半径创建圆角矩形</span></span><br><span class="line"><span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">8</span>)</span><br><span class="line">           .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>以上两中方式创建出来的圆角矩形形状是一样的。</p>
<h4 id="胶囊形"><a href="#胶囊形" class="headerlink" title="胶囊形"></a>胶囊形</h4><p>创建一个胶囊形状使用 <span style="color:red"> <strong><code>Capsule</code></strong> </span>类。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Capsule</span>()</span><br><span class="line">    .fill(.orange)</span><br><span class="line">    .frame(width: <span class="number">100</span>, height: <span class="number">60</span>)</span><br></pre></td></tr></table></figure>

<p>这里需要注意的一点是，当我们不添加 <code>frame</code> 修饰器时，默认情况下为一个圆形。胶囊的最终形状根据给<code>frame</code> 修饰器的<code>width</code>和<code>height</code> 两个属性决定。</p>
<h4 id="椭圆形"><a href="#椭圆形" class="headerlink" title="椭圆形"></a>椭圆形</h4><p>创建一个椭圆形状使用 <span style="color:red"> <strong><code>Ellipse</code></strong> </span>类。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Ellipse</span>()</span><br><span class="line">     .frame(width: <span class="number">100</span>, height: <span class="number">60</span>)</span><br></pre></td></tr></table></figure>

<p>同样地，当 <code>frame</code> 修饰器中的<code>width</code> 和 <code>height</code> 两个属性值一样时，椭圆形状会变成一个圆形。</p>
<h4 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h4><p>创建一个圆形状使用 <span style="color:red"> <strong><code>Circle</code></strong> </span>类。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Circle</span>()</span><br><span class="line">      .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://developer.apple.com/documentation/swiftui/shapes">Shapes | Apple Developer Documentation</a></p>
]]></content>
      <categories>
        <category>SwiftUI 进阶</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>形状</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI之绘制自定义形状</title>
    <url>/posts/8c78197a.html</url>
    <content><![CDATA[<p>在之前一片文章中，我们介绍了 SwiftUI 中内置的一些图形形状。在一些特殊的工能需求下，我们需要自定义去绘制一些形状，例如五角星⭐️，多边形。</p>
<h3 id="自定义路径"><a href="#自定义路径" class="headerlink" title="自定义路径"></a>自定义路径</h3><p>在 SwiftUI 中可以使用 <span style="color:red"><code>Shape</code></span>协议自定义路径。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义一个结构体，实现 Shape 协议</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DrawRectangleShape</span>: <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">path</span>(<span class="params">in</span> <span class="params">rect</span>: <span class="type">CGRect</span>) -&gt; <span class="type">Path</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> path <span class="operator">=</span> <span class="type">Path</span>()</span><br><span class="line">        path.addRect(rect)</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们自定义了一个实现 <code>Shape</code> 协议的结构体类型，在这个自定义的结构体中我们需要实现一个 <code>path(in:)</code>的协议方法，这个方法要求我们返回一个 <code>Path</code>对象，即我们要绘制的形状路径。</p>
 <span id="more"></span>

<p>在上面的这个例子中，我们直接将传进来的 <code>rect</code> 添加到绘制的路径中。具体表现为下面的代码绘制的是一个红色矩形：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DrawRectangleShape</span>()</span><br><span class="line">            .fill(.red)</span><br><span class="line">            .frame(width: <span class="number">200</span>, height: <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>以及下面的代码绘制结果看起来像是一根红色的线，因为绘制的图像的形状高度为 1。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DrawRectangleShape</span>()</span><br><span class="line">            .fill(.red)</span><br><span class="line">            .frame(width: <span class="number">200</span>, height: <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SwiftUI 进阶</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>自定义形状</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI实践之创建一个待办清单（二）</title>
    <url>/posts/6b5357a8.html</url>
    <content><![CDATA[<h1 id="首页界面开发与点击交互"><a href="#首页界面开发与点击交互" class="headerlink" title="首页界面开发与点击交互"></a>首页界面开发与点击交互</h1><p>项目创建和基础配置介绍完成后，接着我们来完成待办清单的首页开发。</p>
<h2 id="创建文件和文件夹"><a href="#创建文件和文件夹" class="headerlink" title="创建文件和文件夹"></a>创建文件和文件夹</h2><p>在Xcode左侧项目导航栏中，选择二级目录下的项目名，鼠标右键点击 <strong>New Group</strong> 创建一个名为 <strong>View</strong> 的文件夹：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051422276.png" style="zoom:70%"/>

<p>创建后的项目结构如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051423576.png"/>

<p>这个文件夹将来存储我们之后创建的所有视图代码文件。</p>
<span id="more"></span>

<p>在我们新建的 <strong>View</strong> 文件夹下新建一个名为 <strong>HomeView</strong> 的 SwiftUI文件：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051423667.png" style="zoom:70%"/>

<p>此时的项目结构如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051423797.png"/>

<h2 id="创建导航栏"><a href="#创建导航栏" class="headerlink" title="创建导航栏"></a>创建导航栏</h2><p>对初始文件 <code>ContentView.swift</code> 进行修改，修改后的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">HomeView</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView_Previews</span>: <span class="title class_">PreviewProvider</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ContentView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NavigationView</code> 是一个导航视图控件，用来配置导航栏文字和按钮。</p>
<p>在 <code>HomeView.swift</code> 文件中开始编写如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HomeView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// 添加一个ZStack布局</span></span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> 待创建内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        .navigationTitle(<span class="string">&quot;待办清单&quot;</span>) <span class="comment">// 导航栏标题</span></span><br><span class="line">        .navigationBarItems(</span><br><span class="line">            <span class="comment">// 导航栏左侧按钮</span></span><br><span class="line">            leading: <span class="type">EditButton</span>(),</span><br><span class="line">            <span class="comment">// 导航栏右侧按钮</span></span><br><span class="line">            trailing: <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Image</span>(systemName: <span class="string">&quot;plus&quot;</span>)</span><br><span class="line">                    .foregroundColor(.blue) <span class="comment">// 图标颜色</span></span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;添加&quot;</span>)</span><br><span class="line">                    .font(.subheadline) <span class="comment">// 字体大小</span></span><br><span class="line">                    .foregroundColor(.blue) <span class="comment">// 字体颜色</span></span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ZStack</code> : Z轴层叠布局；</li>
<li><code>VStack</code> : 垂直布局；</li>
<li><code>HStack</code> : 水平布局；</li>
<li><code>Image</code> : 显示图片控件，经常和 Apple 提供的 <strong>SF Symbols</strong> 配合使用；</li>
<li><code>EditButton</code> : 编辑按钮；</li>
</ul>
<p><strong>此时，预览效果如下</strong>：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051424443.png" style="zoom:60%"/>

<blockquote>
<p>SF Symbols 介绍和下载地址：<a href="https://developer.apple.com/sf-symbols/">SF Symbols - Apple Developer</a></p>
</blockquote>
<h2 id="创建待办列表"><a href="#创建待办列表" class="headerlink" title="创建待办列表"></a>创建待办列表</h2><p>在 <code>ZStack</code> 的内容部分 <code>// TODO: 待创建内容</code> 注释后面使用 <code>List</code>  创建一个待办列表：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">                <span class="type">HStack</span> &#123;</span><br><span class="line">                    <span class="type">Image</span>(systemName: <span class="string">&quot;checkmark.circle&quot;</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Swift学习&quot;</span>)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                &#125;</span><br><span class="line">                .font(.title2)</span><br><span class="line">                .padding(<span class="number">12</span>) <span class="comment">// 内边距</span></span><br><span class="line">                </span><br><span class="line">                <span class="type">HStack</span> &#123;</span><br><span class="line">                    <span class="type">Image</span>(systemName: <span class="string">&quot;checkmark.circle&quot;</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;健身&quot;</span>)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                &#125;</span><br><span class="line">                .font(.title2)</span><br><span class="line">                .padding(<span class="number">12</span>) <span class="comment">// 内边距</span></span><br><span class="line">                <span class="type">HStack</span> &#123;</span><br><span class="line">                    <span class="type">Image</span>(systemName: <span class="string">&quot;checkmark.circle&quot;</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;阅读&quot;</span>)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                &#125;</span><br><span class="line">                .font(.title2)</span><br><span class="line">                .padding(<span class="number">12</span>) <span class="comment">// 内边距</span></span><br><span class="line">                <span class="type">HStack</span> &#123;</span><br><span class="line">                    <span class="type">Image</span>(systemName: <span class="string">&quot;checkmark.circle&quot;</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;聚餐&quot;</span>)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                &#125;</span><br><span class="line">                .font(.title2)</span><br><span class="line">                .padding(<span class="number">12</span>) <span class="comment">// 内边距</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>此时，预览效果如下</strong>：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051426713.png" style="zoom:60%"/>

<p>在上面的代码中，我们使用复制粘贴的方式使用了大量冗余的代码，接着我们通过自定义视图的方式实现视图的复用，从而减少冗余代码的使用。</p>
<p>在 <strong>View</strong> 文件夹下新建一个名为 <code>TodoItemView.swift</code> 的文件，在文件中添加编写下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TodoItemView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> todo:<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Swift学习&quot;</span> <span class="comment">// 待办事项</span></span><br><span class="line">    <span class="keyword">var</span>  isChecked: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span> <span class="comment">// 是否已完成</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: isChecked <span class="operator">?</span>  <span class="string">&quot;checkmark.circle&quot;</span> : <span class="string">&quot;circle&quot;</span>) <span class="comment">// 根据是否完成显示不同的图标</span></span><br><span class="line">            <span class="type">Text</span>(todo)</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        .font(.title2)</span><br><span class="line">        .padding(<span class="number">12</span>) <span class="comment">// 内边距</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>此时，<code>TodoItemView</code>的预览效果如下</strong>：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051428146.png" style="zoom: 60%"/>

<p>回到 <code>HomeView.swift</code> 视图页面，重新编辑 <code>List</code> 的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">     <span class="type">TodoItemView</span>() <span class="comment">// 使用默认值</span></span><br><span class="line">     <span class="type">TodoItemView</span>(todo: <span class="string">&quot;健身&quot;</span>, isChecked: <span class="literal">true</span>) <span class="comment">// 通过传值的方式自定义显示内容和状态</span></span><br><span class="line">     <span class="type">TodoItemView</span>(todo: <span class="string">&quot;健身&quot;</span>, isChecked: <span class="literal">true</span>) <span class="comment">// 通过传值的方式自定义显示内容和状态</span></span><br><span class="line">     <span class="type">TodoItemView</span>(todo: <span class="string">&quot;阅读&quot;</span>, isChecked: <span class="literal">true</span>) <span class="comment">// 通过传值的方式自定义显示内容和状态</span></span><br><span class="line">     <span class="type">TodoItemView</span>(todo: <span class="string">&quot;聚餐&quot;</span>, isChecked: <span class="literal">true</span>) <span class="comment">// 通过传值的方式自定义显示内容和状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>此时，预览效果如下</strong>：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051428398.png" style="zoom:60%"/>

<p>可以发现和之前效果是一样的，但是我们的代码变得更加简洁了。实际上，我们还可以使用数组和 <code>ForEach</code> 来进一步让我们的代码更加简洁。</p>
<p>在 <code>body</code> 上面定义一个字符串类型的数组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> todos: [<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;SwiftUI 学习&quot;</span>, <span class="string">&quot;健身&quot;</span>, <span class="string">&quot;阅读&quot;</span>, <span class="string">&quot;聚餐&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>使用 <code>ForEach</code> 循环数据创建列表：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">       <span class="type">ForEach</span>(todos, id: \.<span class="keyword">self</span>) &#123; todo <span class="keyword">in</span></span><br><span class="line">            <span class="type">TodoItemView</span>(todo: todo)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里为止，我们只是简单的创建了一个字符串类型的数组，但是我们会发现所有的代码都是同一个状态，所以接下来我们需要创建一个数据模型来定义待办事项。</p>
<p>新建一个名为 <code>Model</code> 的文件夹，在这个文件夹先新一个名为 <code>Todo.swift</code> 的 Swift 文件，<span style="color:red"><strong>注意</strong></span>这里不是SwiftUI文件。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051429117.png"  style="zoom:30%"/>

<p><strong>此时的文件结构如下</strong>：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051430250.png" style="zoom:70%"/>

<p>在 <code>Todo.swift</code> 文件中定义一个结构体类型数据模型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Todo</span>: <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span> <span class="comment">// 唯一ID，ForEach 的时候需要用到</span></span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span>  <span class="comment">// 待办事项</span></span><br><span class="line">    <span class="keyword">let</span> isChecked: <span class="type">Bool</span> <span class="comment">// 待办状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化方法</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">id</span>: <span class="type">String</span> <span class="operator">=</span> <span class="type">UUID</span>().uuidString, <span class="params">title</span>: <span class="type">String</span>, <span class="params">isChecked</span>: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.id <span class="operator">=</span> id</span><br><span class="line">        <span class="keyword">self</span>.title <span class="operator">=</span> title</span><br><span class="line">        <span class="keyword">self</span>.isChecked <span class="operator">=</span> isChecked</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，将我们之前字符串数组进行修改：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> todos: [<span class="type">Todo</span>] <span class="operator">=</span> [</span><br><span class="line">        <span class="type">Todo</span>(title: <span class="string">&quot;SwiftUI学习&quot;</span>, isChecked: <span class="literal">false</span>),</span><br><span class="line">        <span class="type">Todo</span>(title: <span class="string">&quot;健身&quot;</span>, isChecked: <span class="literal">false</span>),</span><br><span class="line">        <span class="type">Todo</span>(title: <span class="string">&quot;阅读&quot;</span>, isChecked: <span class="literal">true</span>),</span><br><span class="line">        <span class="type">Todo</span>(title: <span class="string">&quot;聚餐&quot;</span>, isChecked: <span class="literal">false</span>),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>修改 <code>List</code> 部分的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">       <span class="type">ForEach</span>(todos) &#123; todo <span class="keyword">in</span></span><br><span class="line">          <span class="type">TodoItemView</span>(todo: todo.title, isChecked: todo.isChecked)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们发现，我们在使用 <code>ForEach</code> 循环的时候，不再需要传递 <code>id</code> 参数，这是因为我们在定义模型的时候让 <code>Todo</code> 继承了 <code>Identifiable</code> 协议，并且声明了一个 <code>id</code> 成员，同时初始化的时候使用方法 <code>UUID().uuidString</code> 让每个元素都自动生成了一个独一无二的ID。</p>
<h2 id="数据响应与交互"><a href="#数据响应与交互" class="headerlink" title="数据响应与交互"></a>数据响应与交互</h2><p>接下来，我们要实现点击选中和编辑功能。</p>
<p>在SwiftUI中，响应式的数据交互是它的另外一个主要特点。接下来我们使用通过继承 <code>ObservableObject</code> 协议来创建一个响应式的数据模型。</p>
<p>在 <strong>Model</strong>  文件夹下新建一个名为 <code>ListViewModel.swift</code> 的文件，在这个文件中编辑下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI <span class="comment">// 由于我们定义的是一个响应式的数据，所以这里需要引入SwiftUI框架</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListViewModel</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> todos:[<span class="type">Todo</span>] <span class="operator">=</span> [</span><br><span class="line">        <span class="type">Todo</span>(title: <span class="string">&quot;SwiftUI学习&quot;</span>, isChecked: <span class="literal">false</span>),</span><br><span class="line">        <span class="type">Todo</span>(title: <span class="string">&quot;健身&quot;</span>, isChecked: <span class="literal">false</span>),</span><br><span class="line">        <span class="type">Todo</span>(title: <span class="string">&quot;阅读&quot;</span>, isChecked: <span class="literal">true</span>),</span><br><span class="line">        <span class="type">Todo</span>(title: <span class="string">&quot;聚餐&quot;</span>, isChecked: <span class="literal">false</span>),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义一个响应式数据对象时，我们定义的是一个类即关键字使用的是 <code>class</code> ， 然后自定义的这个类需要继承自 <code>ObservableObject</code> 协议。对于类中的成员变量，如果需要进行响应式交互，我们需要使用关键字 <code>@Published</code> 进行修饰。</p>
<p>接着做以下的几处修改：</p>
<p>1、<code>TodoItemView.swift</code> 文件中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TodoItemView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> todo: <span class="type">Todo</span>  <span class="comment">// 修改1</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">						<span class="comment">// 修改2</span></span><br><span class="line">            <span class="type">Image</span>(systemName: todo.isChecked <span class="operator">?</span>  <span class="string">&quot;checkmark.circle&quot;</span> : <span class="string">&quot;circle&quot;</span>) <span class="comment">// 根据是否完成显示不同的图标</span></span><br><span class="line">            <span class="type">Text</span>(todo.title)</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        .font(.title2)</span><br><span class="line">        .padding(<span class="number">12</span>) <span class="comment">// 内边距</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对预览文件进行修改，如果不需要预览也可以直接删除：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TodoItemView_Previews</span>: <span class="title class_">PreviewProvider</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TodoItemView</span>(todo: .<span class="keyword">init</span>(title: <span class="string">&quot;健身&quot;</span>, isChecked: <span class="literal">false</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、 <code>HomeView.swift</code> 文件中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HomeView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> listModel: <span class="type">ListViewModel</span> <span class="operator">=</span> <span class="type">ListViewModel</span>()  <span class="comment">// 修改1</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// 添加一个ZStack布局</span></span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="type">List</span> &#123;</span><br><span class="line">							<span class="comment">// 修改2</span></span><br><span class="line">                <span class="type">ForEach</span>(listModel.todos) &#123; todo <span class="keyword">in</span></span><br><span class="line">                    <span class="type">TodoItemView</span>(todo: todo)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .navigationTitle(<span class="string">&quot;待办清单&quot;</span>) <span class="comment">// 导航栏标题</span></span><br><span class="line">        .navigationBarItems(</span><br><span class="line">            <span class="comment">// 导航栏左侧按钮</span></span><br><span class="line">            leading: <span class="type">EditButton</span>(),</span><br><span class="line">            <span class="comment">// 导航栏右侧按钮</span></span><br><span class="line">            trailing: <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Image</span>(systemName: <span class="string">&quot;plus&quot;</span>)</span><br><span class="line">                    .foregroundColor(.blue) <span class="comment">// 图标颜色</span></span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;添加&quot;</span>)</span><br><span class="line">                    .font(.subheadline) <span class="comment">// 字体大小</span></span><br><span class="line">                    .foregroundColor(.blue) <span class="comment">// 字体颜色</span></span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的预览或者运行效果和之前的一样。</p>
<p>接下来，我们需要给空间添加交互，例如点击或者滑动。</p>
<p>在 <code>ListViewMode.swift</code> 文件中添加一个状态更新函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新完成状态</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateTodoStatus</span>(<span class="params">todo</span>: <span class="type">Todo</span>) &#123;</span><br><span class="line">        <span class="comment">// 查询ID相同的第一个元素索引，可能为空，所以使用 if-let 进行解析</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index <span class="operator">=</span> todos.firstIndex(where: &#123;<span class="variable">$0</span>.id <span class="operator">==</span> todo.id&#125;) &#123;</span><br><span class="line">            todos[index].isChecked <span class="operator">=</span> <span class="operator">!</span>todos[index].isChecked <span class="comment">// 完成状态取反</span></span><br><span class="line">            <span class="built_in">print</span>(todo)</span><br><span class="line">            <span class="built_in">print</span>(todos)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>给 <code>TodoItemView</code> 添加一个 <code>onTapGesture</code> 点击手势交互修饰器，在里面实现点击后状态更新的逻辑：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">ForEach</span>(listModel.todos) &#123;  todo <span class="keyword">in</span></span><br><span class="line">    <span class="type">TodoItemView</span>(todo: todo).onTapGesture &#123;</span><br><span class="line">           listModel.updateTodoStatus(todo: todo)</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>将项目运行在模拟器上或者在预览视图中直接运行，我们会发现点击后控价并没有发生任何的变化。</p>
<p>这是因为我们在声明一个继承自 <code>ObservableObject</code> 协议的类对象时，需要使用<code>@ObservedObject</code> 关键字进行修饰，即修改下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ObservedObject</span> <span class="keyword">var</span> listModel: <span class="type">ListViewModel</span> <span class="operator">=</span> <span class="type">ListViewModel</span>()</span><br></pre></td></tr></table></figure>

<p><strong>此时，再运行我们的项目，点击任意一个待办事项，效果如下</strong>：</p>
<video type="video/mp4"  width="30%" height="50%" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051431958.mp4" controls="controls"/>

]]></content>
      <categories>
        <category>使用SwiftUI创建一个待办清单</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>待办清单</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI控件NavigationStack进阶</title>
    <url>/posts/307cc34b.html</url>
    <content><![CDATA[<p>在SwiftUI中，如果我们想要给app添加一个到导航栏，可以使用<strong>NavigationStack</strong>控件，需要注意的是<strong>NavigationStack是iOS 16之后增加的，旨在替代原来的NavigationView，所以如果你的app 运行在iOS 16之前的版本需要使用NavigationView</strong>。</p>
<p>在之前的文章中，我们已经接受了<strong>NavigationStack</strong>的基本使用，接下来我们将主要介绍<strong>NavigationStack</strong>自定义，即自定义导航栏样式。</p>
<p>初始项目代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> books: [<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;三国演义&quot;</span>,<span class="string">&quot;水浒传&quot;</span>, <span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;西游记&quot;</span>]</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationStack</span> &#123;</span><br><span class="line">            <span class="type">List</span>(books, id: \.<span class="keyword">self</span>) &#123; book <span class="keyword">in</span></span><br><span class="line">                <span class="type">NavigationLink</span> &#123;</span><br><span class="line">                    <span class="type">DetailContentView</span>(book: book)</span><br><span class="line">                &#125; label: &#123;</span><br><span class="line">                    <span class="type">Text</span>(book)</span><br><span class="line">                        .bold()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;四大名著&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DetailContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> book: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(book)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="自定义导航栏字体和文字颜色"><a href="#自定义导航栏字体和文字颜色" class="headerlink" title="自定义导航栏字体和文字颜色"></a>自定义导航栏字体和文字颜色</h3><p>目前，SwiftUI中并没有提供可以定义导航栏样式的修饰器，这里我们需要使用UIKit提供的<code>UINavigationBarAppearance</code> API 来实现。</p>
<p>例如，如果我们想要自定义导航栏上的标题字体和颜色，可以使用下面的方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">      <span class="keyword">let</span> navigationBarAppearance <span class="operator">=</span> <span class="type">UINavigationBarAppearance</span>()</span><br><span class="line">      <span class="comment">// 大标题字体样式</span></span><br><span class="line">      navigationBarAppearance.largeTitleTextAttributes <span class="operator">=</span> [.foregroundColor: <span class="type">UIColor</span>.red, .font: <span class="type">UIFont</span>(name: <span class="string">&quot;Nunito-Regular&quot;</span>, size: <span class="number">30</span>)<span class="operator">!</span>]</span><br><span class="line">      <span class="comment">// 小标题字体样式</span></span><br><span class="line">      navigationBarAppearance.titleTextAttributes <span class="operator">=</span> [.foregroundColor: <span class="type">UIColor</span>.red, .font: <span class="type">UIFont</span>(name: <span class="string">&quot;Nunito-Regular&quot;</span>, size: <span class="number">20</span>)<span class="operator">!</span>]</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 标准样式</span></span><br><span class="line">      <span class="type">UINavigationBar</span>.appearance().standardAppearance <span class="operator">=</span> navigationBarAppearance</span><br><span class="line">      <span class="type">UINavigationBar</span>.appearance().scrollEdgeAppearance <span class="operator">=</span> navigationBarAppearance</span><br><span class="line">      <span class="type">UINavigationBar</span>.appearance().compactAppearance <span class="operator">=</span> navigationBarAppearance</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们是在<code>ContetnView</code>进行初始化的时候就来设置导航栏的标题，即</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">   		</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ContentView的初始化方法</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义返回按钮的图片和颜色"><a href="#自定义返回按钮的图片和颜色" class="headerlink" title="自定义返回按钮的图片和颜色"></a>自定义返回按钮的图片和颜色</h3><p>如果我们只是想要改变默认的返回按钮的图片和颜色，那么我们只需修改<code>UINavigationBarAppearance</code>实例对象的属性即可，即</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">navigationBarAppearance.setBackIndicatorImage(<span class="type">UIImage</span>(systemName: <span class="string">&quot;arrow.turn.up.left&quot;</span>), transitionMaskImage: <span class="type">UIImage</span>(systemName: <span class="string">&quot;arrow.turn.up.left&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>如果是改变返回按钮字体的颜色，只需要修改<code>NavigationStack</code>强调色或者说添加<code>tint</code>修饰器，即</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NavigationStack</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">.tint(.black)</span><br></pre></td></tr></table></figure>



<p>但是，如果我们想要完全自定义个返回按钮，就需要先隐藏<code>NavigationStack</code>原来默认的按钮，使用SwiftUI 提供的<code>navigationBarBackButtonHidden</code>修饰器。</p>
<p>需要注意的是，这个修饰器需要添加到跳转后的子视图上面，在这个例子中就是我们的<code>DetailContentView</code>视图，即</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DetailContentView</span>(book: book)</span><br><span class="line">                        .navigationBarBackButtonHidden(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>此时，当我们再点击跳转过去的时候，下一个页面已经没有默认的返回按钮了。</p>
<p>接着，我们可以使用<code>toolBar</code>给<code>DetailContentView</code>自定义一个返回的按钮，具体实现的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DetailContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> book: <span class="type">String</span></span><br><span class="line">    <span class="meta">@Environment</span>(\.dismiss) <span class="keyword">var</span> dismiss <span class="comment">// 通过dismiss 关键字获取dismiss方法，实现返回上一页</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(book)</span><br><span class="line">            .toolbar &#123;</span><br><span class="line">                <span class="type">ToolbarItem</span>(placement: .cancellationAction) &#123;</span><br><span class="line">                    <span class="type">Button</span>(action: &#123;</span><br><span class="line">                        dismiss()</span><br><span class="line">                    &#125;, label: &#123;</span><br><span class="line">                        <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(Image(systemName: <span class="string">&quot;chevron.left&quot;</span>))</span> <span class="subst">\(book)</span>&quot;</span>)</span><br><span class="line">                            .foregroundStyle(.blue)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 导航栏调整为小标题样式</span></span><br><span class="line">            .navigationBarTitleDisplayMode(.inline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用<code>toolBar</code>修饰器和<code>ToolBarItem</code>控件去定义了一个位于左上角的返回按钮，然后使用<code>Environment</code>获取到了<code>dismiss</code>方法来帮助我们返回上一页。</p>
<p>需要<span style="color:red"><strong>注意</strong></span>的一点是，在<strong>iOS 15.0</strong>之前的系统中，想要实现返回上一页需要使用下面的这种方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Environment</span>(\.presentationMode) <span class="keyword">var</span> presentationMode</span><br></pre></td></tr></table></figure>

<p>然后在按钮的<code>action</code>部分调用下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">presentationMode.wrappedValue.dismiss()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>NavigationStack</tag>
        <tag>NavigationView</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI实践之创建一个待办清单（一）</title>
    <url>/posts/5b45bb70.html</url>
    <content><![CDATA[<h1 id="项目创建和基础配置说明"><a href="#项目创建和基础配置说明" class="headerlink" title="项目创建和基础配置说明"></a>项目创建和基础配置说明</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>1、打开Xcode</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051352356.png" style="zoom:30%"/>

<p>Xcode的初始界面存在三种不同的项目创建方式：</p>
<p><strong>Create a new Xcode project</strong>: 创建一个全新的工程项目，最常用的项目创建方式；</p>
<p><strong>Cone an existing project</strong>: 克隆一个项目，适用于已经存在并且使用Git或SVN版本管理工具管理的项目；</p>
<p><strong>Open a project or file</strong>： 打开一个本机已经存在的项目或文件。</p>
<span id="more"></span>

<p>2、选择第一个，创建一个全新的Xcode项目：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051354165.png" style="zoom:15%"/>

<p>首先需要注意是，我们可以创建不同平台的应用项目，例如<span style="color:red"> iOS、macOS、watchOS、tvOS</span> 或者是同时运行多个平台的项目。</p>
<p>这里我们选择 <strong>iOS</strong>，因为我们的应用只需要运行在iPhone或者iPad上。</p>
<p>针对我们常见的APP开发，我们有两个选项，分别是 <strong>App</strong> 和 <strong>App Playground。</strong> 二者的区别在于：</p>
<ul>
<li><strong>App</strong> 选项创建的项目是一个工程文件，包含多个文件； <strong>App Playground</strong> 选项创建的项目是一个扩展名为 <code>.swiftpm</code> 的文件；</li>
<li><strong>App</strong> 选项创建的项目<strong>只能</strong>通过Mac电脑上的Xcode编译运行和二次开发；<strong>App Playground</strong> 选项创建的项目可以使用Xcode、iPad或者Mac上的 <strong>Swift Playgrounds</strong> 应用程序运行和二次开发。</li>
<li><strong>App</strong> 选项创建的项目项目更加灵活，适用于大型项目或者多人协同开发；<strong>App Playground</strong> 选项创建的项目适用于个人或者小型软件开发；</li>
</ul>
<p>细心的同学可能已经注意都一点，<strong>App Playground</strong> 选项创建的项目和在iPad上使用<strong>Swift Playgrounds</strong>创建的项目是一样的。</p>
<blockquote>
<p>其他的一些项目创建选项主要用于一些特殊的应用开发，例如开发游戏、开发一个AR的应用以及开发软件包等。赶兴趣的同学可以自行了解。</p>
</blockquote>
<p>选择 <strong>App</strong> 选项，点击 <strong>Next</strong>：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051356228.png" style="zoom:30%"/>

<p>项目的配置信息：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051357254.png" style="zoom:50%"/>

<p><strong>Product Name</strong>: 项目名称或者工程名称；</p>
<p><strong>Team</strong>:  开发团队名称，即开发者的Apple ID；</p>
<p><strong>Organization Identifier</strong>: 组织ID，一般为公司域名倒过来。例如正式域名为 <a href="http://www.qingmaoedu.com/">www.qingmaoedu.com</a> 倒过来就是 <code>com.qingmaoedu.www </code>；</p>
<p><strong>Bundle Identifier</strong>: Xcode 使用组织名+项目名自动为应用生成的一个标识ID，这个ID在进行应用上架时会非常关键，也可以后续在Xcode中自行修改。需要注意的一点是，这个ID在App Store 中相当于应用的身份证号，且是唯一存在的；</p>
<p><strong>Interface</strong>: 应用开发要使用的技术框架，存在两个选项 <strong>SwiftUI</strong> 和 <strong>Storyboard，</strong>前者使用SwiftUI 作为主要的技术框架，后者使用UIKit作为主要的技术框架。当然这二者在后续的项目中可以混合使用。UIKit 是SwiftUI推出之前，开发iOS应用的唯一开发框架，用来实现界面的构建；</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051359529.png" style="zoom:100%"/>

<p><strong>Language</strong> : 开发语言，有 <strong>Swift</strong> 和 <strong>Objective-C</strong> 两种开发语言；</p>
<p><strong>Use Core Data</strong> : 项目是否使用 Core Data 框架；Core Data 是Apple提供的数据存储框架，可以实现本地存储和云存储；</p>
<p><strong>Include Tests</strong> : 是否包含测试到项目中，项目开发完成后进行功能和UI测试的时候会用到来编写测试用例。</p>
<p>最终项目配置如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051401234.png" style="zoom:70%"/>

<p>点击 <strong>Next</strong> 选择一个项目文件的存储位置，</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051401477.png" style="zoom:40%"/>

<p><span style="color:red"><strong>注意</strong></span>，这里有一个是否使用 Git 来对项目做一个版本管理的选项，如果我们熟悉Git和GitHub的使用或者这个项目需要多个人共同开发可以进行勾选。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051403037.png"/>



<h2 id="项目结构介绍和基础配置"><a href="#项目结构介绍和基础配置" class="headerlink" title="项目结构介绍和基础配置"></a>项目结构介绍和基础配置</h2><p>1、项目结构</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051403741.png"/>

<p>项目创建后，默认下的两个 Swift文件和我们之前使用 <strong>Swift Playgrounds</strong> 创建的一致。我们需要注意的是一个蓝色资源文件夹 <strong>Assets</strong> ，这个文件用存放我们项目中所有的素材 资源，例如图片、音视频、颜色数值等。</p>
<p>2、基础配置</p>
<p>选中项目的根目录，在 <strong>TARGETS→General</strong> 中可以找到项目的一些通用的基础配置：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051403718.png" style="zoom:30%"/>

<p>在这个基础配置页面，我们比较常用的配置包括：</p>
<p><strong>Supported Destinations</strong> : 项目支持的硬件平台。我们可以在这里使用应用支持运行的平台，例如iPhone、iPad、Mac 或者Apple TV。</p>
<p><strong>Minimum Deployments</strong> : 项目最低支持的运行系统版本。例如这里显示的iOS 16.4 意味着如果我们不进行修改，那么我们开发完成的项目将无法在低于 iOS 16.4 的系统上运行。</p>
<p><strong>Identify</strong> ： 应用的标识。</p>
<ul>
<li><p><strong>App Category</strong> : 使用SwiftUI创建的项目可以在这里设置一个应用的默认图标；</p>
</li>
<li><p><strong>Display Name</strong> : 应用展示在桌面的名称，例如我们手机上常见的“淘宝”、“抖音”、“支付宝”等等，如果不进行设置默认为我们创建时设置的项目包名；</p>
</li>
<li><p><strong>Bundle Identifier</strong> : 应用的标识ID，默认自动生成，我们也可以进行修改，需要注意的是应用上架审核时这个ID必须是唯一存在的；</p>
</li>
<li><p><strong>Version</strong> : 应用版本号；</p>
</li>
<li><p><strong>Build</strong>: 应用编译版本号。</p>
<p>版本号和编译版本后在应用上架审核时用的比较多，平时基本不需要进行修改。</p>
</li>
</ul>
<p><strong>Deployment Info</strong>: 配置应用在设备上运行时可以支持的设备方向和状态栏默认的样式。</p>
<p>关于设备的方向：</p>
<ul>
<li><strong>Portrait :</strong>  设备与地面垂直，Home 键位于底部或者面容识别位于顶部；</li>
<li><strong>Upside Down</strong> ：设备与地面垂直，Home 键位于顶部或者面容识别位于底部；</li>
<li><strong>Landscape Left ：</strong>设备的面容识别位于右侧或者Home 键位于左侧；</li>
<li><strong>Landscape Right ：</strong>设备的面容识别位于左侧或者Home 键位于右侧；</li>
</ul>
<blockquote>
<p>API开发文档：<a href="https://developer.apple.com/documentation/uikit/uideviceorientation">UIDeviceOrientation | Apple Developer Documentation</a></p>
</blockquote>
<p>打开 <code>ContentView.swift</code> 文件，同时打开预览界面，点击预览界面从左往右数的第三个选项按钮，然后打开 <strong>Orientation</strong> 的选项开即可调整预览界面中设备的不同方向。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051404012.png" style="zoom:40%"/>



<p>在刚刚的<strong>Deployment Info</strong> 配置中，除了可以设置应用运行后的方向，也可以设置应用中顶部状态栏的样式:</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051405925.png"/>

<ul>
<li><strong>Default</strong> ：默认样式，根据页面的样式进行选择；</li>
<li><strong>Dark Content</strong> : 状态栏背景为白色，文字和图标为黑色，即白底黑字；</li>
<li><strong>Light Content</strong> :  状态栏背景为黑色，文字和图标为白色，即黑底白字；</li>
</ul>
<h2 id="配置项目和演示"><a href="#配置项目和演示" class="headerlink" title="配置项目和演示"></a>配置项目和演示</h2><p>在 <strong>Xcode</strong>的顶部选择一个我们指定运行的模拟器：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051406328.png" style="zoom:40%"/>

<p>如果没有想要的模拟器，可以点击底部的 <strong>Manage Run Destinations</strong> 选项去添加不同系统版本和型号的模拟器：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051406713.png" style="zoom:30%"/>

<p>在后面的课程中，我们也将使用WiFi或者数据线的方式将应用运行在我们的手机上，即真机测试。</p>
<p>选中模拟器后，点击底部类似于播放▶️的按钮运行我们的项目，习惯使用快捷键的同学也可以使用 <strong><code>Commond + R</code></strong> 快捷键运行项目<strong>。</strong></p>
<p>不修改任何配置的情况下，运行的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051407884.png" style="zoom:50%"/>

<p>点击模拟器顶部的 <strong>Home</strong> 键回到桌面，我们可以看到应用使用了一个默认的白色线框图标以及应用的名称为我们的项目名称。 </p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309051407389.png"/>

<p>需要注意的一点是，当我们通过上面介绍的这些设置去配置项目时，会发现存在以下的一些问题：</p>
<ul>
<li>设置 <strong>App Category</strong> 和 <strong>Status Bar Style</strong> 都没有出现我们预期的效果。但是我们可以使用其他的方式去设置这个选项，例如在资源文件中添加我们自己的应用图标到 <strong>AppIcon</strong> 里面可以设置应用的图标，后续我们可以使用代码的方式去设置状态栏的样式。</li>
<li>当我们只给应用设置一个方向时，无论后续如何旋转我们的设备，界面布局都不会发生变化。即我们可以通过指定应用只能竖屏或者横屏的模式下运行，这样一来我们在开发的使用就不需要考虑不同屏幕方向下的界面布局了。</li>
</ul>
]]></content>
      <categories>
        <category>使用SwiftUI创建一个待办清单</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>待办清单</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI控件之 List（一）</title>
    <url>/posts/57a1224a.html</url>
    <content><![CDATA[<p>在很多 app 中，我们经常能看到上下滚动的列表，在 SwiftUI 中，我们可以使用<strong>List</strong> 实现这样的功能。</p>
<h4 id="创建一个列表"><a href="#创建一个列表" class="headerlink" title="创建一个列表"></a>创建一个列表</h4><p>要实现一个列表，我们需要先创建一个<strong>数组</strong>类型的数据源：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> books: [<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;西游记&quot;</span>, <span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;三国演义&quot;</span>, <span class="string">&quot;水浒传&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>使用 <code>ForEach</code> 遍历数组，将元素显示到 <code>List</code>中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">    <span class="type">ForEach</span>(books, id: \.<span class="keyword">self</span>) &#123; book <span class="keyword">in</span></span><br><span class="line">         <span class="type">Text</span>(<span class="string">&quot;《<span class="subst">\(book)</span>》&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 除了上面的这种方式，我们还可以直接将数据元给到<code>List</code>，然它进行循环创建列表：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>(books, id: \.<span class="keyword">self</span>) &#123; book <span class="keyword">in</span></span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;《<span class="subst">\(book)</span>》&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们注意到，不管是我们使用哪种方式，我们都需要设置一个<code>id</code>的参数，这是因为<code>List</code> 要求每一行的元素都要有一个<span style="color:red"><strong>唯一</strong></span>的id，以便我们后续对<strong>List</strong> 进行编辑操作。这里我们是直接将循环出来的元素对象本身作为id 给它。</p>
<p><span style="color:red"><strong>注意，这在数据源中元素不会出现重复的情况下是可行，但是如果存在重复相同的元素，就会出现编辑异常的情况。</strong></span></p>
<span id="more"></span>

<h4 id="不同的-listStyle"><a href="#不同的-listStyle" class="headerlink" title="不同的 listStyle"></a>不同的 <code>listStyle</code></h4><p>我们可以通过 <code>listStyle</code> 修饰器来定义<strong>List</strong> 不同的风格样式，<code>insetGrouped</code>、<code>inset</code>、<code>grouped</code>、<code>plain</code>、<code>sidebar</code>、<code>automatic</code>。</p>
<p>注意，在不同的系统中样式显示也不一致。例如<code>sidebar</code> 样式在 iPadOS 中显示为侧边栏样式，在 iOS 中则为默认的样式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.listStyle(.automatic)</span><br></pre></td></tr></table></figure>

<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309121039437.png"/>

<h4 id="List-分组和设置-footer-、-header"><a href="#List-分组和设置-footer-、-header" class="headerlink" title="List 分组和设置  footer 、 header"></a>List 分组和设置  footer 、 header</h4><p>如果我们想要实现 List 分组的效果，可以使用 <strong>Section</strong> ，然后<strong>Section</strong> 的构造方法分别给每个分组设置<strong>header</strong> 和<strong>footer</strong>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">    <span class="type">Section</span> &#123;</span><br><span class="line">        <span class="type">ForEach</span>(books, id: \.<span class="keyword">self</span>) &#123; book <span class="keyword">in</span></span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;《<span class="subst">\(book)</span>》&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; header: &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;四大名著&quot;</span>)</span><br><span class="line">            .bold()</span><br><span class="line">    &#125; footer: &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;推荐阅读书籍&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Section</span> &#123;</span><br><span class="line">        <span class="type">ForEach</span>(books, id: \.<span class="keyword">self</span>) &#123; book <span class="keyword">in</span></span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;《<span class="subst">\(book)</span>》&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; header: &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;四大名著&quot;</span>)</span><br><span class="line">            .bold()</span><br><span class="line">    &#125; footer: &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;推荐阅读书籍&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309121055074.png" style="zoom:40%"/>

]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>List</tag>
        <tag>Identifier</tag>
        <tag>ForEach</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI控件之 List（二）</title>
    <url>/posts/37193cc1.html</url>
    <content><![CDATA[<h4 id="创建-List"><a href="#创建-List" class="headerlink" title="创建 List"></a>创建 List</h4><p>在之前的<strong>List</strong> 使用中，我们是直接使用<code>ForEach</code> 循环遍历一个数组来实现的，在遍历的时候我们把<code>self</code> 作为<strong>List</strong>中必须的<strong>ID</strong>。接下来，我们通过自定义一个数据对象同时让它实现<code>Identifiable</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Ocean</span>: <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name:  <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span> <span class="operator">=</span> <span class="type">UUID</span>().uuidString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们自定义了一个结构体类型的对象<code>Ocean</code> ，同时让它实现了<code>Identifiable</code> 协议。在实现这个协议之后，它需要结构体的有一个名为<code>id</code>的成员属性，然后这个属性的值我们直接通过<code>UUID().uuisString</code> 创建一个字符串类型的值给它，这样可以实现之后创建的每一个<code>Ocean</code> 实例对象都有一个<strong>唯一</strong>的<strong>ID</strong>，便于我们在<strong>List</strong> 遍历时使用。</p>
<span id="more"></span>

<p>同样地，使用数组的方式创建一些数据源。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> oceans <span class="operator">=</span> [</span><br><span class="line">    <span class="type">Ocean</span>(name: <span class="string">&quot;Pacific&quot;</span>),</span><br><span class="line">    <span class="type">Ocean</span>(name: <span class="string">&quot;Atlantic&quot;</span>),</span><br><span class="line">    <span class="type">Ocean</span>(name: <span class="string">&quot;Indian&quot;</span>),</span><br><span class="line">    <span class="type">Ocean</span>(name: <span class="string">&quot;Southern&quot;</span>),</span><br><span class="line">    <span class="type">Ocean</span>(name: <span class="string">&quot;Arctic&quot;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>使用<code>List</code> 和 <code>ForEach</code>创建一个<strong>List</strong>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">    <span class="type">ForEach</span>(oceans) &#123; ocean <span class="keyword">in</span></span><br><span class="line">        <span class="type">Text</span>(ocean.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><span style="color:red">注意：</span>在上面的代码中，由于<code>ForEach</code>遍历的对象实现了<code>Identifiable</code>协议，所以我们就不再需要去单独设置<code>id</code>。</strong></p>
<p>或者可以直接讲数据源给到<code>List</code>来创建：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>(oceans) &#123; ocean <span class="keyword">in</span></span><br><span class="line">    <span class="type">Text</span>(ocean.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码也可以通过语法进行简写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>(oceans) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="variable">$0</span>.name)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>简写前和简写后的效果是一样的，简写代码中的<code>$0</code>表示遍历的第一个参数，还可以有类似于<code>$1</code>、<code>$2</code> …等这样的形式。</p>
<h4 id="List-中的多选"><a href="#List-中的多选" class="headerlink" title="List 中的多选"></a>List 中的多选</h4><p>首先将<code>List</code>嵌套到<code>NavigationStack</code>中实现一个带顶部导航栏的样式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NavigationStack</span> &#123;</span><br><span class="line">    <span class="type">List</span>(oceans) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="variable">$0</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    .navigationTitle(<span class="string">&quot;Oceans&quot;</span>) <span class="comment">// 导航栏的标题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，通过<code>toolBar</code>添加一个<code>EditButton</code> 按钮：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.toolbar &#123;</span><br><span class="line">                <span class="type">EditButton</span>()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> oceans <span class="operator">=</span> [</span><br><span class="line">        <span class="type">Ocean</span>(name: <span class="string">&quot;Pacific&quot;</span>),</span><br><span class="line">        <span class="type">Ocean</span>(name: <span class="string">&quot;Atlantic&quot;</span>),</span><br><span class="line">        <span class="type">Ocean</span>(name: <span class="string">&quot;Indian&quot;</span>),</span><br><span class="line">        <span class="type">Ocean</span>(name: <span class="string">&quot;Southern&quot;</span>),</span><br><span class="line">        <span class="type">Ocean</span>(name: <span class="string">&quot;Arctic&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> multiSelection <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationStack</span> &#123;</span><br><span class="line">            <span class="type">List</span>(oceans, selection: <span class="variable">$multiSelection</span>) &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="variable">$0</span>.name)</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;Oceans&quot;</span>) <span class="comment">// 导航栏的标题</span></span><br><span class="line">            .toolbar &#123;</span><br><span class="line">                <span class="type">EditButton</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;当前选中：<span class="subst">\(multiSelection.count)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，实现了一下几步：</p>
<ol>
<li>通过<code>NavigationStack</code> 实现了导航栏；</li>
<li>在<code>toolBar</code>上添加了一个<code>EditButton</code>，当点击 <strong>EditButton</strong>后<strong>List</strong> 将进入<strong>可编辑模式</strong>；</li>
<li>使用<code>@State</code> 定义了一个元素类型和<code>Ocean</code> 中<code>id</code> 类型（<strong>String</strong>）一致的动态元祖变量，然后将这个变量和<strong>List</strong>中的<code>selection</code>绑定，当 <strong>List</strong> 进入编辑模式之后我们就可以获取到被选中的<strong>List</strong>中<strong>唯一</strong>的<strong>ID</strong>。</li>
</ol>
<p>效果如下：</p>
<p><video width="30%" height="50%" controls="controls" src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309161014389.mp4"> </video></p>
<h4 id="List-的下拉刷新加载"><a href="#List-的下拉刷新加载" class="headerlink" title="List 的下拉刷新加载"></a>List 的下拉刷新加载</h4><p>首先将数据源<code>oceans</code> 使用<code>@State</code> 声明为动态的响应式类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> oceans <span class="operator">=</span> [</span><br><span class="line">       <span class="type">Ocean</span>(name: <span class="string">&quot;Pacific&quot;</span>),</span><br><span class="line">       <span class="type">Ocean</span>(name: <span class="string">&quot;Atlantic&quot;</span>),</span><br><span class="line">       <span class="type">Ocean</span>(name: <span class="string">&quot;Indian&quot;</span>),</span><br><span class="line">       <span class="type">Ocean</span>(name: <span class="string">&quot;Southern&quot;</span>),</span><br><span class="line">       <span class="type">Ocean</span>(name: <span class="string">&quot;Arctic&quot;</span>)</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>

<p>然后给<code>List</code>添加一个<code>refreshable </code>修饰器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.refreshable &#123;</span><br><span class="line">                <span class="comment">// 每次刷新向 oceans 数组中添加一个新的元素</span></span><br><span class="line">                oceans.append(.<span class="keyword">init</span>(name: <span class="string">&quot;Other&quot;</span>))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>此时，当程序运行后，每次下拉刷新<strong>List</strong> 中都将添加一个新的名为<code>Other</code> 的元素。</p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>List</tag>
        <tag>NavigationStack</tag>
        <tag>Identifier</tag>
        <tag>EditButton</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI控件之 NavigationStack</title>
    <url>/posts/80d98b55.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，<strong>NavigationStack</strong> 用来作为一个根视图（root view）使得我们能够将一个新的视图展示在这个根视图上。</p>
<h3 id="创建一个带导航栏和标题的app"><a href="#创建一个带导航栏和标题的app" class="headerlink" title="创建一个带导航栏和标题的app"></a>创建一个带导航栏和标题的app</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationStack</span> &#123;</span><br><span class="line">            <span class="type">List</span> &#123;</span><br><span class="line">                <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">10</span>,id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;当前行<span class="subst">\(index)</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;导航栏标题&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在上面的代码中，</p>
<ol>
<li>将一个<code>NavigationStack</code> 作为整个页面的根视图；</li>
<li>给 <code>NavigationStack</code> 的第一个子视图<code>List</code>添加<code>navigationTitle</code>修饰器，<span style="color:red"><strong>注意，</strong></span>这个修饰器的作为就是给导航栏添加标题。</li>
<li>使用<code>ForEach</code>创建<code>List</code>的显示内容。</li>
</ol>
<p>此时，效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309201401648.png" style="zoom:20%"/>

<h3 id="导航栏风格"><a href="#导航栏风格" class="headerlink" title="导航栏风格"></a>导航栏风格</h3><p>在默认情况下，iOS 中的导航栏为大标题的样式。可以通过<code>navigationBarTitleDisplayMode</code>修改标题的样式：</p>
<ul>
<li><code>inline</code>：小标题样式，之前 UIKit中常用的样式；</li>
<li><code>larget</code>：大标题样式，SwiftUI app 中的默认样式。</li>
</ul>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309201404954.png" style="zoom:20%"/>

<p>不过，即使在大标题的样式下，当我们向下滑动时，当标题样式也会变为小标题样式，向上滑动到顶部时又会重新变为原来的样式。</p>
<h3 id="使用NavigationLink-实现页面跳转和展示"><a href="#使用NavigationLink-实现页面跳转和展示" class="headerlink" title="使用NavigationLink 实现页面跳转和展示"></a>使用NavigationLink 实现页面跳转和展示</h3><p>文章开头我们说过，使用<code>NavigationStack</code>作为根视图来实现页面的展示。要想实现其他视图的展示或者常见的导航栏页面跳转需要和<code>NavigationLink</code>一起使用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NavigationLink</span> &#123;</span><br><span class="line">    <span class="comment">// 要展示的视图</span></span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;当前页面<span class="subst">\(index)</span>&quot;</span>)</span><br><span class="line">&#125; label: &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;当前行<span class="subst">\(index)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们使用的是<code> NavigationLink(destination: () -&gt; View, label: () -&gt; View)</code>函数，<code>destination</code>参数表示的展示的视图，<code>label</code>表示通过那个视图来触发展示的内容，即被点击的视图。</p>
<p>当我们添加了<code>NavigationLink</code>之后，<code>List</code>中的每一行视图都会变成可点击的样式，然后我们点击任意一行之后都将跳转或者展示对应的页面。具体效果如下：</p>
<p><video src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309201433629.mp4" width="30%" height="50%" controls="controls"></video></p>
<p>在上面的演示效果中，我们会发现，当我们进入展示的目标视图页面，目标视图页面本身也会带上导航栏并且自带返回功能。</p>
<p><span style="color:red"><strong>注意，</strong></span>在一些旧版本的 SwiftUI 代码中，使用的是<code>NavigationView</code>实现相同的功能，目前<code>NavigationView</code>已被逐步放弃，官方更推荐我们使用<code>NavigationLink</code>。</p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>NavigationStack</tag>
        <tag>NavigationLink</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI控件之 PhotosPicker</title>
    <url>/posts/3f68e07.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，有一个特殊的<strong>Picker（选择器）</strong>，叫做<strong>PhotosPicker（相册选择器）</strong>，使用它可以帮助快速获取手机相册中的照片。</p>
<h3 id="创建一个-PhotosPicker"><a href="#创建一个-PhotosPicker" class="headerlink" title="创建一个 PhotosPicker"></a>创建一个 PhotosPicker</h3><p><strong>PhotosPicker</strong>本身并不属于 <strong>SwiftUI</strong>这个模块中，它属于<strong>PhotosUI</strong>模块，所以我们首先需要在头部导入这个模块：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> PhotosUI</span><br></pre></td></tr></table></figure>

<p>使用 <code>@State</code> 定义一个变量用来和<code>PhotosPicker</code>进行绑定：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> selectedImages: <span class="type">PhotosPickerItem</span>?</span><br></pre></td></tr></table></figure>

<p>创建<code>PhotoPicker</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">PhotosPicker</span>(<span class="string">&quot;选择喜欢的照片&quot;</span>, selection: <span class="variable">$selectedImages</span>)</span><br></pre></td></tr></table></figure>

<p>此时的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309280923302.png" style="zoom:20%"/>

<p><span style="color:red"><strong>注意</strong>：</span>上图的效果为 iOS 17 以后的效果。</p>
<span id="more"></span>

<p>因为相册里面的照片属于用户的<strong>敏感隐私数据</strong>，所以访问的时候会有隐私数据的提示。一般情况下，Apple 希望我们在隐私设置中添加访问敏感隐私数据的使用说明。</p>
<p>点击我们都项目<strong>根目录</strong>，在<strong>TARGETS</strong>中找到<strong>Info</strong>选项，在<strong>Custom iOS Target Properties</strong>中添加一个访问手机相册说明。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309280929340.png" style="zoom:20%"/>



<p>添加的记录如下，它是以<strong>Key-Value</strong>的形式存在的：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309280932456.png"/>

<h3 id="使用选中后的照片"><a href="#使用选中后的照片" class="headerlink" title="使用选中后的照片"></a>使用选中后的照片</h3><p>使用<strong>PhotosPicker</strong>选中后的照片为 <code>PhotosPickerItem</code>类型，我们要想让选中的照片使用<code>Image</code>进行显示需要使用 <code>loadTransferable(type:completionHandler:)</code> 方法，具体使用如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> selectedImages: <span class="type">PhotosPickerItem</span>?</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> avatarImage: <span class="type">Image</span>?</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">PhotosPicker</span>(<span class="string">&quot;选择喜欢的照片&quot;</span>, selection: <span class="variable">$selectedImages</span>)</span><br><span class="line">            <span class="comment">// 非空时显示</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> avatarImage &#123;</span><br><span class="line">                avatarImage</span><br><span class="line">                    .resizable()</span><br><span class="line">                    .frame(width: <span class="number">200</span>, height: <span class="number">200</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前 selectedImages的值发生变化时调用</span></span><br><span class="line">        .onChange(of: selectedImages) &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 创建一个异步任务</span></span><br><span class="line">            <span class="type">Task</span> &#123;</span><br><span class="line">                <span class="comment">// 将选中的 PhotosPickerItem 类型转换为要显示的 Image</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> image <span class="operator">=</span> <span class="keyword">try?</span> <span class="keyword">await</span> selectedImages<span class="operator">?</span>.loadTransferable(type: <span class="type">Image</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">                    avatarImage <span class="operator">=</span> image</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，实现的步骤如下：</p>
<ol>
<li>使用<code>@State</code> 定义一个 <code>Image</code>类型的变量用来接收转换后的照片；</li>
<li>使用<code>onChange</code>修饰器监听<code>selectedImages</code>变量值的的变化，当发生变化时将新的值转换为<code>Image</code>进行显示；</li>
<li>转换的过程中使用了<code>Task</code>创建了<strong>异步</strong>任务配合<code>loadTransferable</code>方法使用；</li>
<li>当<code>avataImage</code>的值不为<code>nil</code>时显示照片。</li>
</ol>
<h3 id="配置-PhotosPicker-可选择的范围"><a href="#配置-PhotosPicker-可选择的范围" class="headerlink" title="配置 PhotosPicker 可选择的范围"></a>配置 PhotosPicker 可选择的范围</h3><p>在 iOS ，我们平时拍的照片、截图、录的视频或者下载保存的视频都是存储在相册中的，<code>PhotosPicker</code>提供了一个<code>matching</code>参数用来设置应用可以选择的相册范围。</p>
<p>例如，如果想要应用只能选择视频，可以像下面这样设置：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">PhotosPicker</span>(<span class="string">&quot;选择喜欢的照片&quot;</span>, selection: <span class="variable">$selectedImages</span>, matching: .videos)</span><br></pre></td></tr></table></figure>

<p>它来提供了很多的范围可选，例如：</p>
<ul>
<li><p><code>panoramas</code>：全景照片；</p>
</li>
<li><p><code>images</code>: 所有照片；</p>
</li>
<li><p><code>videos</code>: 所有视频；</p>
</li>
<li><p><code>screenshots</code>: 截图</p>
<p>……</p>
</li>
</ul>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Picker</tag>
        <tag>PhotosPicker</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI控件之 Label</title>
    <url>/posts/8bd109ea.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，<strong>Label</strong> 用来展示一个文本和图标（icon）。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用<strong>Assets</strong> 中的图片作为<strong>Label</strong> 的图标：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Label(&quot;avatar&quot;, image: &quot;avatar&quot;)</span><br></pre></td></tr></table></figure>

<p>使用<strong>SF Symbols</strong> 中的图标作为<strong>Label</strong> 的图标：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Label</span>(<span class="string">&quot;apple&quot;</span>, systemImage: <span class="string">&quot;apple.logo&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="设置不同的Label样式"><a href="#设置不同的Label样式" class="headerlink" title="设置不同的Label样式"></a>设置不同的<strong>Label</strong>样式</h4><p>可以使用<code>labelStyle</code> 修饰器来定义 Label 的样式：</p>
<ul>
<li><code>iconOnly</code> : 只显示图标；</li>
<li><code>titleAndIcon</code>: 显示文字和图标，默认样式；</li>
<li><code>titleOnly</code> ： 只显示文字；</li>
<li><code>automatic</code>：自动。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Label</span>(<span class="string">&quot;apple&quot;</span>, systemImage: <span class="string">&quot;apple.logo&quot;</span>)</span><br><span class="line">   .labelStyle(.automatic)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="使用一个-View作为-Label-的图标"><a href="#使用一个-View作为-Label-的图标" class="headerlink" title="使用一个 View作为 Label 的图标"></a>使用一个 View作为 Label 的图标</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Label</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Felix&quot;</span>)</span><br><span class="line">        .font(.body)</span><br><span class="line">        .foregroundStyle(.primary)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Zhao&quot;</span>)</span><br><span class="line">        .font(.subheadline)</span><br><span class="line">        .foregroundStyle(.secondary)</span><br><span class="line">    </span><br><span class="line">&#125; icon: &#123;</span><br><span class="line">    <span class="type">Circle</span>()</span><br><span class="line">        .fill(.red)</span><br><span class="line">        .frame(width: <span class="number">44</span>, height: <span class="number">44</span>)</span><br><span class="line">        .overlay(<span class="type">Text</span>(<span class="string">&quot;F&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的Label 中，我们使用两个不同样式的<code>Text</code> 作为<strong>Label</strong> 要显示的文字内容；使用一个<code>Circle</code> 作为<strong>Label</strong>的自定义图标视图。</p>
<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309131405868.png"/>

]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Label</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI控件之 Button(一)</title>
    <url>/posts/d48dbb48.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，<strong>Button</strong> 是一个视图，它可以响应触摸点击事件。Button 视图有一个基本的结构，包括<strong>标题（label）</strong>和<strong>动作（action）</strong>。动作是一个在按钮被点击时触发的函数。</p>
<h3 id="按钮的定义"><a href="#按钮的定义" class="headerlink" title="按钮的定义"></a>按钮的定义</h3><p>下面是一个简单的 Button 示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">&quot;按钮&quot;</span>) &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;按钮被点击了&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们定义了按钮的文字<code>按钮</code>和点击的响应事件<code>print(&quot;按钮被点击了&quot;)</code>。除了这种方式，我们还可以使用另外一种常用的方式定义一个按钮：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;按钮被点击了&quot;</span>)</span><br><span class="line">&#125; label: &#123;</span><br><span class="line">   <span class="type">Text</span>(<span class="string">&quot;按钮&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在后面的这种方式中，我们是使用一个<code>Text(&quot;按钮&quot;)</code> 作为按钮的<strong>label</strong>，这样做的好处是可以更多的自定义按钮标题的样式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span> &#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;按钮被点击了&quot;</span>)</span><br><span class="line">&#125; label: &#123;</span><br><span class="line">     <span class="type">Text</span>(<span class="string">&quot;按钮&quot;</span>)</span><br><span class="line">         .foregroundStyle(.black)</span><br><span class="line">         .background(.gray)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了使用<strong>Text</strong> 作为<strong>label</strong> 的要显示的内容，也可以使用其他的控件，例如<strong>Image</strong>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(systemName: <span class="string">&quot;apple.logo&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="按钮的样式"><a href="#按钮的样式" class="headerlink" title="按钮的样式"></a>按钮的样式</h3><p><strong>Button</strong>的风格可以通过<code> .buttonStyle</code> 修饰器来进行修改，我们可以定义以下的几种风格：</p>
<p><code>automatic</code>、<code>bordered</code>、<code>borderedProminent</code>、<code>borderless</code>和<code>plain</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="type">VStack</span>(spacing: <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;风格1&quot;</span>) &#123;</span><br><span class="line">                &#125;.buttonStyle(.automatic)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;automatic&quot;</span>)</span><br><span class="line">                    .font(.system(size: <span class="number">12</span>))</span><br><span class="line">                    .foregroundStyle(.red)</span><br><span class="line">                    .fontWeight(.bold)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Divider</span>()</span><br><span class="line">            <span class="type">VStack</span>(spacing:<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;风格2&quot;</span>) &#123;</span><br><span class="line">                &#125;.buttonStyle(.bordered)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;.bordered&quot;</span>)</span><br><span class="line">                    .font(.system(size: <span class="number">12</span>))</span><br><span class="line">                    .foregroundStyle(.red)</span><br><span class="line">                    .fontWeight(.bold)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Divider</span>()</span><br><span class="line">            <span class="type">VStack</span>(spacing:<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;风格3&quot;</span>) &#123;</span><br><span class="line">                &#125;.buttonStyle(.borderedProminent)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;.borderedProminent&quot;</span>)</span><br><span class="line">                    .font(.system(size: <span class="number">12</span>))</span><br><span class="line">                    .foregroundStyle(.red)</span><br><span class="line">                    .fontWeight(.bold)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Divider</span>()</span><br><span class="line">            <span class="type">VStack</span>(spacing:<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;风格4&quot;</span>) &#123;</span><br><span class="line">                &#125;.buttonStyle(.borderless)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;.borderless&quot;</span>)</span><br><span class="line">                    .font(.system(size: <span class="number">12</span>))</span><br><span class="line">                    .foregroundStyle(.red)</span><br><span class="line">                    .fontWeight(.bold)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Divider</span>()</span><br><span class="line">            <span class="type">VStack</span>(spacing:<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;风格5&quot;</span>) &#123;</span><br><span class="line">                &#125;.buttonStyle(.plain)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;.plain&quot;</span>)</span><br><span class="line">                    .font(.system(size: <span class="number">12</span>))</span><br><span class="line">                    .foregroundStyle(.red)</span><br><span class="line">                    .fontWeight(.bold)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309071011683.png"  style="zoom:20%"/>

<h3 id="几种特殊的-Button"><a href="#几种特殊的-Button" class="headerlink" title="几种特殊的 Button"></a>几种特殊的 Button</h3><h4 id="EditButton"><a href="#EditButton" class="headerlink" title="EditButton"></a>EditButton</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">EditButton</span>()</span><br></pre></td></tr></table></figure>

<p><strong>EditButton</strong> 经常配合<strong>List</strong> 一起使用，实现<strong>List</strong> 的编辑功能。</p>
<h4 id="SignInWithAppleButton"><a href="#SignInWithAppleButton" class="headerlink" title="SignInWithAppleButton"></a>SignInWithAppleButton</h4><p>使用<strong>SignInWithAppleButton</strong> 按钮，我们可以快速实现使用 <strong>Apple ID</strong> 的快速登录和登出。</p>
<p>首先，如果需要使用<strong>SignInWithAppleButton</strong> 控件，需要导入<strong>AuthenticationServices</strong> 模块：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> AuthenticationServices</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">SignInWithAppleButton</span>(.signIn,</span><br><span class="line">                                  onRequest: &#123; request <span class="keyword">in</span></span><br><span class="line">                <span class="comment">// 发起登录、登出请求</span></span><br><span class="line">                request.requestedScopes <span class="operator">=</span> [.fullName, .email]</span><br><span class="line">            &#125;,</span><br><span class="line">                                  onCompletion: &#123; result <span class="keyword">in</span></span><br><span class="line">                <span class="comment">// 请求完成后的回调</span></span><br><span class="line">                <span class="keyword">switch</span> result &#123;</span><br><span class="line">                <span class="keyword">case</span> .success(<span class="keyword">let</span> authResults):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Authorization successful.&quot;</span>)</span><br><span class="line">                <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Authorization failed: &quot;</span> <span class="operator">+</span> error.localizedDescription)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .frame(width: <span class="number">200</span>, height: <span class="number">50</span>)</span><br><span class="line">            .signInWithAppleButtonStyle(.whiteOutline) <span class="comment">// 按钮的风格</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<strong>SignInWithAppleButton</strong> 和普通的<strong>Button</strong> 不同，它可以根据我们的需要设置为<code>signIn</code>和<code>signUp</code>两种不同的状态，除此之外还需要实现两个回调。</p>
<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309071035663.png" style="zoom:20%"/>

<p><strong>SignInWithAppleButton</strong> 也可以使用 <code>signInWithAppleButtonStyle</code> 修饰器进行样式的定义，可以定义以下三种样式：</p>
<p><code>whiteOutline</code>、<code>black</code>、<code>white</code>。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309071038752.png" style="zoom:20%"/>

<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://developer.apple.com/documentation/swiftui/button">Button | Apple Developer Documentation</a></p>
<p><a href="https://developer.apple.com/documentation/swiftui/editbutton/">EditButton | Apple Developer Documentation</a></p>
<p><a href="https://developer.apple.com/documentation/authenticationservices/signinwithapplebutton/">SignInWithAppleButton | Apple Developer Documentation</a></p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Button</tag>
        <tag>EditButton</tag>
        <tag>SignInWithAppleButton</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI控件之 Picker</title>
    <url>/posts/bd95df5.html</url>
    <content><![CDATA[<p>在我们做一些信息表单填写时，经常需要用到<strong>选择器（Picker）</strong>。</p>
<h3 id="创建-Picker"><a href="#创建-Picker" class="headerlink" title="创建 Picker"></a>创建 Picker</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Picker</span>(<span class="string">&quot;今天周几&quot;</span>,  selection: <span class="variable">$selectedOptions</span>) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期一&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期二&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期三&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期四&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期五&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期六&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期天&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>@State</code>创建一个动态响应的变量，用于和<code>Picker</code>进行绑定，当选中某一项时，这个变量对应的值也会发生变化。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> selectedOptions:<span class="type">Int</span> <span class="operator">=</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>此时默认的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309240934896.png" style="zoom:50%"/>

<p>但是如果我们此时选择任意一个其他的选项，发现并没有什么变化，而且控制台会输入下面的信息：</p>
<p><span style="color:red"><strong>Picker: the selection “0” is invalid and does not have an associated tag, this will give undefined results.</strong></span></p>
<span id="more"></span>

<p>这是因为我们没有给<code>Picker</code>的每一个选项设置一个不同的<code>Tag</code>值，我们只需要做下面的修改就可以解决这个问题。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Picker</span>(<span class="string">&quot;今天周几&quot;</span>,  selection: <span class="variable">$selectedOptions</span>) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期一&quot;</span>)</span><br><span class="line">        .tag(<span class="number">0</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期二&quot;</span>)</span><br><span class="line">        .tag(<span class="number">1</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期三&quot;</span>)</span><br><span class="line">        .tag(<span class="number">2</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期四&quot;</span>)</span><br><span class="line">        .tag(<span class="number">3</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期五&quot;</span>)</span><br><span class="line">        .tag(<span class="number">4</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期六&quot;</span>)</span><br><span class="line">        .tag(<span class="number">5</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;星期天&quot;</span>)</span><br><span class="line">        .tag(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样解释了为什么我们在声明绑定的动态变量<code>selectedOptions</code>时，将它声明为<code>Int</code>类型了。</p>
<h3 id="使用循环遍历的方式创建选项"><a href="#使用循环遍历的方式创建选项" class="headerlink" title="使用循环遍历的方式创建选项"></a>使用循环遍历的方式创建选项</h3><p>在上面的示例中，我们都是直接定义每个选项的内容，当我们的选项很多的时候我们可以使用<code>ForEach</code>循环创建选项：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Picker</span>(<span class="string">&quot;今天周几&quot;</span>,  selection: <span class="variable">$selectedOptions</span>) &#123;</span><br><span class="line">    <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">7</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;选项<span class="subst">\(index<span class="operator">+</span><span class="number">1</span>)</span>&quot;</span>)</span><br><span class="line">            .tag(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们直接使用每次循环的索引作为选项的<code>Tag</code>值。</p>
<h3 id="设置-Picker的不同风格"><a href="#设置-Picker的不同风格" class="headerlink" title="设置 Picker的不同风格"></a>设置 Picker的不同风格</h3><p>和 SwiftUI 中很多其他的控件一样，<strong>Picker</strong>也提供了很多的样式，我们可以通过<code>pickerStyle</code>进行设置。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Picker</span>(<span class="string">&quot;今天周几&quot;</span>,  selection: <span class="variable">$selectedOptions</span>) &#123;</span><br><span class="line">                   <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">7</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                       <span class="type">Text</span>(<span class="string">&quot;选项<span class="subst">\(index<span class="operator">+</span><span class="number">1</span>)</span>&quot;</span>)</span><br><span class="line">                           .tag(index)</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               .pickerStyle(.inline)</span><br></pre></td></tr></table></figure>

<p>我们可以设置这些风格 <code>inline</code>、<code>segmented</code>、<code>wheel</code>、<code>palette</code>、<code>menu</code>、<code>navigationLink</code>。</p>
<p>不同风格的样式呈现如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309241012504.png" style="zoom:20%"/>

<p><span style="color:red"><strong>注意：</strong></span>，<code>navigationLinke</code>样式需要和 <strong>NavigationStack</strong> 一起配合使用，即在父视图外面嵌套一个<code>NavigationStack</code>，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NavigationStack</span> &#123;</span><br><span class="line">    <span class="type">Picker</span>(<span class="string">&quot;今天周几&quot;</span>,  selection: <span class="variable">$selectedOptions</span>) &#123;</span><br><span class="line">        <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">7</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;选项<span class="subst">\(index<span class="operator">+</span><span class="number">1</span>)</span>&quot;</span>)</span><br><span class="line">                .tag(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .pickerStyle(.navigationLink)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的展示效果如下：</p>
<p><video src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309241054945.mp4" width="20%" height="50%" controls="controls"> </video></p>
<p>除了基础的<strong>Picker</strong>外，还有<strong>DatePicker（日期选择器）</strong> 和 <strong>ColorPicker（颜色选择器）</strong>，我们将在后面的内容中详细介绍它们的使用。</p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Picker</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI控件之 ScrollView(二)</title>
    <url>/posts/ff84e235.html</url>
    <content><![CDATA[<h3 id="实现快速滚动到顶部或底部的效果"><a href="#实现快速滚动到顶部或底部的效果" class="headerlink" title="实现快速滚动到顶部或底部的效果"></a>实现快速滚动到顶部或底部的效果</h3><p>在很多的<strong>ScrollView</strong> 的应用中，我们经常见到点击“回到顶部”按钮实现快速回到顶部的效果。</p>
<p>在 SwiftUI中，如果我们想要实现这样的效果，我们可以使用<strong>ScrollViewRader</strong>和<strong>ScrollView</strong>来实现。<strong>ScrollViewRader</strong>可以让我们通过编程的方式实现滚动到一个已知的子视图的位置。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Namespace</span> <span class="keyword">var</span> topID</span><br><span class="line">    <span class="meta">@Namespace</span> <span class="keyword">var</span> bottomID</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ScrollViewReader</span> &#123; proxy <span class="keyword">in</span></span><br><span class="line">            <span class="type">ScrollView</span> &#123;</span><br><span class="line">                <span class="comment">// 顶部的按钮</span></span><br><span class="line">                <span class="type">Button</span> &#123;</span><br><span class="line">                    withAnimation &#123;</span><br><span class="line">                        proxy.scrollTo(bottomID)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; label: &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;滚动到底部&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                .id(topID)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 滚动视图</span></span><br><span class="line">                <span class="type">VStack</span>(spacing: <span class="number">0.1</span>) &#123;</span><br><span class="line">                    <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">100</span>) &#123;i <span class="keyword">in</span></span><br><span class="line">                        color(fraction: <span class="type">Double</span>(i) <span class="operator">/</span> <span class="number">100</span>)</span><br><span class="line">                            .frame(height: <span class="number">32</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 顶部的按钮</span></span><br><span class="line">                <span class="type">Button</span>(action: &#123;</span><br><span class="line">                    withAnimation &#123;</span><br><span class="line">                        proxy.scrollTo(topID)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, label: &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;滚动到顶部&quot;</span>)</span><br><span class="line">                    </span><br><span class="line">                &#125;)</span><br><span class="line">                .id(bottomID)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建颜色</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">color</span>(<span class="params">fraction</span>: <span class="type">Double</span>) -&gt; <span class="type">Color</span> &#123;</span><br><span class="line">        <span class="type">Color</span>(red: fraction, green: <span class="number">1</span> <span class="operator">-</span> fraction, blue: <span class="number">0.5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在上面的示例代码中，实现了一下几个步骤：</p>
<ol>
<li>在<code>ScrollView</code>外面嵌套了一层<code>ScrollViewReader</code>；</li>
<li><code>ScrollView</code>的子视图包括顶部按钮、 100 个渐变颜色子视图和底部按钮是三个部分；</li>
<li>使用<code>@NameSpace</code>创建了<code>topID</code> 和<code>bottomID</code> 两个变量，然后将它们分别给到顶部和底部按钮；</li>
<li>利用<code>ScrollViewRader</code> 提供的<code>proxy</code> 在点击两个按钮的时候滚动到指定的 ID 的子视图位置。</li>
</ol>
<p>效果如下：</p>
<p><video src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309180948602.mp4" width="30%" height="50%" controls="controls"></video></p>
<h3 id="实现滚动到指定索引的位置"><a href="#实现滚动到指定索引的位置" class="headerlink" title="实现滚动到指定索引的位置"></a>实现滚动到指定索引的位置</h3><p>创建一个数据结构：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NameModel</span>: <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span> <span class="operator">=</span> <span class="type">UUID</span>().uuidString</span><br><span class="line">    <span class="keyword">let</span> index: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成一些测试使用的数据源：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据源</span></span><br><span class="line"><span class="keyword">var</span> nameDatas:[<span class="type">NameModel</span>] &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        (<span class="number">0</span><span class="operator">..&lt;</span><span class="number">100</span>).map &#123;</span><br><span class="line">            <span class="type">NameModel</span>(name: <span class="string">&quot;我是-<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>, index: <span class="variable">$0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>界面布局：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">       <span class="type">ScrollViewReader</span> &#123; proxy <span class="keyword">in</span></span><br><span class="line">           <span class="type">ScrollView</span> &#123;</span><br><span class="line">               <span class="type">Button</span>(action: &#123;</span><br><span class="line">                   withAnimation &#123;</span><br><span class="line">                       proxy.scrollTo(nameDatas[scrollToIndex].index)</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;, label: &#123;</span><br><span class="line">                   <span class="type">Text</span>(<span class="string">&quot;滚动到索引为<span class="subst">\(scrollToIndex)</span>的地方&quot;</span>)</span><br><span class="line">               &#125;)</span><br><span class="line">               <span class="type">ForEach</span>(nameDatas) &#123; data <span class="keyword">in</span></span><br><span class="line">                   <span class="type">Text</span>(data.name)</span><br><span class="line">                       .padding(<span class="number">4</span>)</span><br><span class="line">                       .id(data.index)</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>此时的效果为当我们点击按钮后，<strong>ScrollView</strong>将滚动到子视图 ID为 70 的位置：</p>
<p><video src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309181236721.mp4" width="30%" height="50%" controls="controls"></video></p>
<p><span style="color:red"><strong>注意：</strong></span>这里目前依然存在一个问题，当我们使用数据模型的<code>id</code>属性作为<strong>ScrollView</strong>子视图的ID 时，即 <code>.id(data.id)</code>，无法实现类似的效果。</p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>ScrollView</tag>
        <tag>ScrollViewReader</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI控件之 TextField</title>
    <url>/posts/edbc1019.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，<strong>TextField</strong> 用来展示和接收用户编辑的文本内容。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在创建一个<strong>TextField</strong>之前，需要先定义一个<strong>响应式</strong>类型的状态变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> userName:<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>在创建<strong>TextField</strong> 时，使用<code>$userName</code> 的形式绑定这个状态变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">TextField</span>(<span class="string">&quot;User Name&quot;</span>,text: <span class="variable">$userName</span>)</span><br></pre></td></tr></table></figure>

<p>当<code>userName</code> 这个变量和<strong>TextField</strong> 绑定后，当我们在输入框中输入或者删除内容时，<code>userName</code> 对应的值也会跟着发生变化。</p>
<span id="more"></span>

<h4 id="TextField-的不同风格"><a href="#TextField-的不同风格" class="headerlink" title="TextField 的不同风格"></a>TextField 的不同风格</h4><p>使用<code>textFieldStyle</code> 修饰器来定义<strong>TextField</strong>的不同风格：</p>
<ul>
<li><code>roundedBorder</code>： 圆角边框样式；</li>
<li><code>plain</code> ： 默认的无边框样式；</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span>(spacing: <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="type">TextField</span>(<span class="string">&quot;User Name&quot;</span>,text: <span class="variable">$userName</span>)</span><br><span class="line">        .textFieldStyle(.roundedBorder)</span><br><span class="line">    </span><br><span class="line">    <span class="type">TextField</span>(<span class="string">&quot;User Name&quot;</span>,text: <span class="variable">$userName</span>)</span><br><span class="line">        .textFieldStyle(.plain)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309131432602.png"/>

<h4 id="SecureField"><a href="#SecureField" class="headerlink" title="SecureField"></a>SecureField</h4><p>除了常见的<strong>TextField</strong> ，还可以使用<strong>SecureField</strong> 来获取一些隐私数据的输入，例如密码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SecureField</span>(<span class="string">&quot;Password&quot;</span>,text: <span class="variable">$password</span>)</span><br></pre></td></tr></table></figure>

<p>使用安全输入框时，当用户输入类似于密码之类的隐私数据时，会以**<code>····</code>** 形式呈现，从而起到保护隐私数据的作用。</p>
<h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p><a href="https://developer.apple.com/documentation/swiftui/textfield">TextField | Apple Developer Documentation</a></p>
<p><a href="https://developer.apple.com/documentation/swiftui/securefield">SecureField | Apple Developer Documentation</a></p>
]]></content>
      <categories>
        <category>SwiftUI 基础</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>TextField</tag>
        <tag>SecureField</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift中的条件语句</title>
    <url>/posts/964c101d.html</url>
    <content><![CDATA[<p>Swift提供了<strong>if</strong>和<strong>switch</strong>两种条件语句，<code>if</code>语句用来判断简单的条件，<code>switch</code>语句适合复杂的条件。</p>
<span id="more"></span>

<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>当只有一个单一的条件时：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">8</span></span><br><span class="line"><span class="keyword">if</span>(a<span class="operator">&lt;</span><span class="number">10</span>)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a小于10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>if</strong>语句也提供else分句，当条件为false时使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">8</span></span><br><span class="line"><span class="keyword">if</span>(a<span class="operator">&lt;</span><span class="number">10</span>)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a小于10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a大于或等于10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要判断多个条件时，可以使用<strong>else-if</strong>配合if语句使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">8</span></span><br><span class="line"><span class="keyword">if</span>(a<span class="operator">&lt;</span><span class="number">10</span>)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a小于10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a<span class="operator">&gt;</span><span class="number">10</span>)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a大于10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等于10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>每一个 <code>switch</code> 语句都由多个可能的情况组成，每一个情况都以 case 关键字开始。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> <span class="type">A</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;q&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;常量A等于字符串q&quot;</span>)</span><br><span class="line"><span class="keyword">case</span>  <span class="string">&quot;a&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;常量A等于字符串a&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;其他字符&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常量A等于字符串a</span><br></pre></td></tr></table></figure>

<p><code>switch</code>语句要求仅可能的提供所有可能的值，但是当我们无法对所有可能的情况进行判断时，我们可以时关键字<strong>default</strong>进行标记，这表示其他没有提供的情况执行这部分的代码块。</p>
<h5 id="多条件的匹配："><a href="#多条件的匹配：" class="headerlink" title="多条件的匹配："></a>多条件的匹配：</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="keyword">switch</span> <span class="type">A</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;q&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;常量A等于字符串q&quot;</span>)</span><br><span class="line"><span class="keyword">case</span>  <span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;常量A等于字符串a或b&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;其他字符&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们在<code>case</code>后面添加了一个新的条件，条件之间使用逗号隔开。当常量A等于”a”或”b”时执行的结果都是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常量A等于字符串a或b</span><br></pre></td></tr></table></figure>

<h5 id="区间匹配："><a href="#区间匹配：" class="headerlink" title="区间匹配："></a>区间匹配：</h5><p><code>switch</code>语句也可以配个区间运算符一起使用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">23</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="operator">..&lt;</span><span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a小于0&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a大于等于0小于10&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span><span class="operator">..&lt;</span><span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a大于等于10小于100&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a大于或等于100&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">a大于等于<span class="number">10</span>小于<span class="number">100</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift 基础语法</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>条件语句</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift中的函数</title>
    <url>/posts/66bf2022.html</url>
    <content><![CDATA[<h3 id="认识函数"><a href="#认识函数" class="headerlink" title="认识函数"></a>认识函数</h3><p>函数是一段独立的代码块，用来执行一些特定的操作。我们可以通过给函数一个名字来定义它的功能，当我们需要执行这段代码块的时候通过函数的名字来进行调用。</p>
<h4 id="定义和调用函数"><a href="#定义和调用函数" class="headerlink" title="定义和调用函数"></a>定义和调用函数</h4><p>定义函数使用关键字<strong>func</strong>,每个函数都需要有一个函数名，它描述函数执行的任务。<br>下面我们定义一个函数名为<code>sayHi</code>的函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHi</span>()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">sayHi()</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你好</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="带参数和返回值的函数"><a href="#带参数和返回值的函数" class="headerlink" title="带参数和返回值的函数"></a>带参数和返回值的函数</h4><p>在一些特定的情况下，我们需要给函数传入一些数据，传入的数据我们称之为<strong>参数</strong>。另外，我们也可能需要函数给我们返回一些代码块执行的结果，这就是<strong>返回值</strong>。</p>
<h5 id="带参数的函数"><a href="#带参数的函数" class="headerlink" title="带参数的函数"></a>带参数的函数</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHi</span>(<span class="params">name</span>:<span class="type">String</span>)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好，<span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义带参数的函数时，需要声明参数的数据类型，声明的方式类似于变量的声明，但是不需要加<strong>var</strong>关键字。</p>
<p>调用带参函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">sayHi(<span class="string">&quot;Felix&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，在调用函数的时候，传入的参数类型要和函数定义时的数据类型一致。上面的实例中参数的数据类型是<strong>String</strong>类型，所以函数调用是我们只能传入一个字符串。</p>
</blockquote>
<h5 id="带返回值的函数"><a href="#带返回值的函数" class="headerlink" title="带返回值的函数"></a>带返回值的函数</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHi</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;你好&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义带返回值的函数我们需要使用返回箭头<code>-&gt;</code>箭头后面跟的是返回值的数据类型。另外，在代码块执行结束后我们需要使用<strong>return</strong>关键字返回数据。</p>
<p>函数调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let result = sayHi()</span><br></pre></td></tr></table></figure>

<p>在调用带返回值的函数时，我们一般会把返回的结果赋给一个常量，以便之后使用。当然我们也可以直接使用<strong>print</strong>直接将结果打印。<code>print(sayHi())</code></p>
<h5 id="同时带参数和返回值的函数"><a href="#同时带参数和返回值的函数" class="headerlink" title="同时带参数和返回值的函数"></a>同时带参数和返回值的函数</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sum</span>(<span class="params">a</span>:<span class="type">Int</span>,<span class="params">b</span>:<span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实例中我们定义来一个求和函数来计算任何两个整数的值，并将求和后的结果返回。另外，这个函数定义了两个参数，所以函数调用的时候需要传入两个参数。</p>
<p>函数调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(sum(a: <span class="number">100</span>, b: <span class="number">24</span>))</span><br></pre></td></tr></table></figure>

<h5 id="多返回值函数"><a href="#多返回值函数" class="headerlink" title="多返回值函数"></a>多返回值函数</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">calculate</span>(<span class="params">a</span>:<span class="type">Int</span>,<span class="params">b</span>:<span class="type">Int</span>) -&gt; (sum:<span class="type">Int</span>,sub:<span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> sum <span class="operator">=</span> a <span class="operator">+</span> b</span><br><span class="line">    <span class="keyword">let</span> sub <span class="operator">=</span> a <span class="operator">-</span> b</span><br><span class="line">    <span class="keyword">return</span> (sum,sub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个计算函数，我们分别计算传入的两个参数的和与差，然后将和与差返回。</p>
<p>函数调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> calculate(a: <span class="number">102</span>, b: <span class="number">23</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;两数之和为：<span class="subst">\(result.sum)</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;两数之差为：<span class="subst">\(result.sub)</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">两数之和为：<span class="number">125</span></span><br><span class="line">两数之差为：<span class="number">79</span></span><br></pre></td></tr></table></figure>

<h4 id="函数的实际参数标签和形式参数名"><a href="#函数的实际参数标签和形式参数名" class="headerlink" title="函数的实际参数标签和形式参数名"></a>函数的实际参数标签和形式参数名</h4><p>每个函数的形式参数都包含实际参数标签和形式参数名。实际参数标签在函数调用的时候使用，形式参数名在函数的内部使用。默认情况下，Swift使用形式参数名作为实际参数标签，在上面所有的函数定义中，我们都没有特别声明实际参数标签。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">calculate</span>(<span class="params">first</span> <span class="params">a</span>:<span class="type">Int</span>, <span class="params">second</span> <span class="params">b</span>:<span class="type">Int</span>) -&gt; (sum:<span class="type">Int</span>,sub:<span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> sum <span class="operator">=</span> a <span class="operator">+</span> b</span><br><span class="line">    <span class="keyword">let</span> sub <span class="operator">=</span> a <span class="operator">-</span> b</span><br><span class="line">    <span class="keyword">return</span> (sum,sub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的实例中<code>second</code>和<code>first</code>就是实际参数标签，<code>a</code>和<code>b</code>就是形式参数名。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> calculate(first: <span class="number">102</span>, second: <span class="number">23</span>)</span><br></pre></td></tr></table></figure>

<p>我们注意到，我们在进行函数调用的时候使用的实际参数标签。使用实际参数标签可以帮助我们提高代码的可读性。</p>
<h5 id="省略实际参数标签"><a href="#省略实际参数标签" class="headerlink" title="省略实际参数标签"></a>省略实际参数标签</h5><p>在某些情况下，我们可能想要在调用函数的时候省略实际参数标签，那么我们可以借助<code>_</code>通配符实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">calculate</span>(<span class="keyword">_</span> <span class="params">a</span>:<span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>:<span class="type">Int</span>) -&gt; (sum:<span class="type">Int</span>,sub:<span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> sum <span class="operator">=</span> a <span class="operator">+</span> b</span><br><span class="line">    <span class="keyword">let</span> sub <span class="operator">=</span> a <span class="operator">-</span> b</span><br><span class="line">    <span class="keyword">return</span> (sum,sub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> calculate(<span class="number">102</span>, <span class="number">23</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，在函数调用的时候我们已经可以不用写实际参数标签了。</p>
]]></content>
      <categories>
        <category>Swift 基础语法</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode必备技巧（一）</title>
    <url>/posts/3249ee52.html</url>
    <content><![CDATA[<h3 id="Xcode-中常用的快捷键"><a href="#Xcode-中常用的快捷键" class="headerlink" title="Xcode 中常用的快捷键"></a>Xcode 中常用的快捷键</h3><p><strong>1. Command + 0</strong></p>
<p>显示&#x2F;隐藏左侧文件导航栏</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310151015899.gif" style="zoom: 30%"/>

<p><strong>2. Command + Shift + O</strong> </p>
<span id="more"></span>

<p>打开有一个快捷搜索，通过关键字快速定位到对应的文件、函数或者变量。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310151044891.gif" style="zoom:30%"/>

<p><strong>3. Command + Shift + J</strong></p>
<p>快速定位当前文件的所在的位置。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310151047955.gif" style="zoom:30%"/>

<p><strong>4. Command + Shift + Y</strong> </p>
<p>快速显示&#x2F;隐藏Xcode 底部的调试区域，即输出控制台部分。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310151048412.gif" style="zoom:30%"/>

<p><strong>5. Command + Option + [</strong></p>
<p>光标所在行的代码向上移动。</p>
<p><strong>6.Command + Option + ]</strong></p>
<p>光标所在行的代码向下移动。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310151050647.gif" style="zoom:30%"/>



<p><strong>7. Command + Option + 0</strong> </p>
<p>显示&#x2F;隐藏右侧区域。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310151058674.gif" style="zoom:30%"/>

<p><strong>8. Control + I</strong></p>
<p>光标所在行的代码进行随进对齐。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310151101493.gif" style="zoom:30%"/>

<p>经常和<strong>Command + A</strong> 一起使用，即全选当前文件的所有代码，然后对所有的代码进行美化操作。</p>
<h3 id="Xcode-中的多光标编辑"><a href="#Xcode-中的多光标编辑" class="headerlink" title="Xcode 中的多光标编辑"></a>Xcode 中的多光标编辑</h3><p>Xcode 和很多的其他开发工具一样，也支持多光标的编辑操作。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310151108330.gif" style="zoom:80%"/>

<p>Xcode 中有多种添加多光标的方式：</p>
<p><strong>方式一：Control + Shift + 单击鼠标左键</strong>。</p>
<p><strong>方式二： Control + Shift + 方向上下键</strong><span style="color:red"><strong>(推荐方式)</strong></span>。</p>
<h3 id="Xcode-中开启拼写检查"><a href="#Xcode-中开启拼写检查" class="headerlink" title="Xcode 中开启拼写检查"></a>Xcode 中开启拼写检查</h3><p>在开发过程中，我们会经常遇到各种命名拼写错误的情况，为了尽量避免这个情况的出现，Xcode 给我们提供了一个<strong>拼写检查</strong>的功能。</p>
<p>开启路径如下：</p>
<p>Xcode 左上角的菜单栏中<strong>Edit -&gt; Format -&gt; Spelling and Grammar -&gt; Check Spelling While Typing</strong>， 勾选住这个设置选项即可。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310151138115.png" style="zoom:20%"/>

<p>开启前的效果：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310151145517.png" style="zoom:30%"/>

<p>开启后的效果：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310151145166.png" style="zoom: 30%"/>

<p>当出现拼写错误的时候，可以选中这个拼写错误的单词，然后鼠标右键就可以看到 Xcode 给我们提供的修改建议和处理方法了。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310151146632.png" style="zoom:20%"/>
]]></content>
      <categories>
        <category>Xcode 使用技巧</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>工欲善其事，必先利其器（Xcode 常见设置）</title>
    <url>/posts/b2a2499d.html</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="Xcode-基础设置"><a href="#Xcode-基础设置" class="headerlink" title="Xcode 基础设置"></a>Xcode 基础设置</h2><h3 id="设置代码编辑器的字体和整体样式"><a href="#设置代码编辑器的字体和整体样式" class="headerlink" title="设置代码编辑器的字体和整体样式"></a>设置代码编辑器的字体和整体样式</h3><p>创建好项目之后，使用快捷 <strong><code>Command + ,</code></strong> 或者顶部菜单栏的 <strong>Xcode→Settings</strong> 打开Xcode的偏好设置，在 <strong>Themes</strong> 主题选项部分可以选择或者设置代码编辑器的代码风格和字体大小：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309061748945.png" style="zoom:30%"/>

<span id="more"></span>

<p>另外一个常用的设置是 <strong>显示&#x2F;隐藏</strong> 文件的扩展名，也可以根据需要指定需要隐藏&#x2F;显示 的文件类型：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309061749630.png" style="zoom:80%"/>

<p>显示文件扩展名：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309061750955.png"/>

<p> 隐藏文件扩展名：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309061751694.png"/>

<h3 id="Xcode-整体布局设置"><a href="#Xcode-整体布局设置" class="headerlink" title="Xcode 整体布局设置"></a>Xcode 整体布局设置</h3><p><strong>显示&#x2F;隐藏</strong> SwiftUI项目的预览区：</p>
<p>在Xcode的右上角部分，点击从右往左数的第二个图标，<strong>选中&#x2F;取消选中</strong> <strong>Canvas  选项即可显示或关闭预览区：</strong></p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202309061752415.png" style="zoom:30%"/>

<p>另一个比较常用的设置是代码区域的预览小地图，按照上面的方式勾选 <strong>Minimap</strong> 即可在代码编辑区域的右上角显示代码预览，当一个代码文件的代码行数很多时，我们可以通过快速点击预览到达指定的代码位置。</p>
<p>上面的设置是我们比较常用，同时也是能极大提升我们开发效率的设置，随着对Xcode越来越熟悉也可以逐渐了解Xcode中更多的使用技巧。</p>
<p>除了上面的一些基础设置，接着我们来介绍几个Xcode中常用的快捷键：</p>
<ul>
<li><code>Command + B</code> ： 快速进行项目的编译，可以在不运行的情况下检查我们的代码编写是否存在错误；</li>
<li><code>Command + R</code> ： 在指定模拟下运行项目；</li>
<li><code>Command + N</code> ： 在项目中创建一个文件；</li>
<li><code>Command + Option + P</code> ：重新加载SwiftUI的预览界面。在默认情况下，我们在代码区域编写完成SwiftUI的代码后，右边的预览区域会自动进行加载，但是当我们的SwiftUI代码很多或者自动加载失败时就可以使用这个快捷方式重新快速加载预览而无须通过鼠标点击的方式进行。</li>
</ul>
]]></content>
      <categories>
        <category>Xcode 使用技巧</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>如何让 Text 中的文本内容自动进行调整</title>
    <url>/posts/585c3fa7.html</url>
    <content><![CDATA[<p>在 SwiftUI 中，使用<strong>Text</strong> 添加了<code>frame</code>修饰器后文本内容经常出现显示不完整的情况，例如下面的场景：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310021032152.png"/>

<p>如果我们希望在指定控件的范围内让文本内容尽可能地显示完整，我们可以给<code>Text</code>添加 <code>minimumScaleFactor</code>修饰器，即设置<strong>Text</strong>的<strong>最小比例因子</strong>。它的作用就是指定文本内容能按照设定的<code>font</code>原始尺寸缩小的最小比例，从而让文本内容尽可能的显示完整。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span>(spacing:<span class="number">20</span>) &#123;</span><br><span class="line">         <span class="type">Text</span>(<span class="string">&quot;Swift is a powerful and intuitive programming language for all Apple platforms. It’s easy to get started using Swift, with a concise-yet-expressive syntax and modern features you’ll love. Swift code is safe by design and produces software that runs lightning-fast.&quot;</span>)</span><br><span class="line">             .font(.headline)</span><br><span class="line">         </span><br><span class="line">         <span class="type">Text</span>(<span class="string">&quot;Swift is a powerful and intuitive programming language for all Apple platforms. It’s easy to get started using Swift, with a concise-yet-expressive syntax and modern features you’ll love. Swift code is safe by design and produces software that runs lightning-fast.&quot;</span>)</span><br><span class="line">             .font(.headline)</span><br><span class="line">             .minimumScaleFactor(<span class="number">0.5</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     .padding()</span><br><span class="line">     .frame(height: <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>因为我们给<code>HStack</code>设置了<code>frame</code>，并把高度限制为<code>200</code>，所以在这个高度范围内是无法完整显示两个<code>Text</code>内容的。如果不给最后一个<code>Text</code>设置<code>minimumScaleFator</code>，它展示的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310021040860.png"/>

<p>设置后的效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310021041405.png"/>

<p>通过前后两种效果的比较我们可以发现，在设置了<code>minimumScaleFactor</code>为 <code>0.5</code>后，后一个<code>Text</code>的字体大小在原来设置的<code>font(.headline)</code>的基础上进行缩小操作。</p>
<span id="more"></span>

<p>注意，<strong>它并不是缩小为原来尺寸的<code>0.5</code>，它只是在能显示完整内容的基础上进行了缩小，只是我们设定了最小能缩小的值为原来的<code>0.5</code>。</strong></p>
<p>当我们把<code>HStack</code>的<code>frame</code>的<code>height</code>设置能完整显示两个<code>Text</code>时，字体就不会进行缩放了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.frame(height: <span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310021053426.png"/>



<p>同样地，如果把<code>height</code>设置的很小，后一个文本字体最小能缩放的范围也只是原来的<code>0.5</code>.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.frame(height: <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310021055994.png"/>

<p>如果把<code>minimumScaleFactor</code>设置为 <code>0.1</code>，它就可以缩的更小。</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202310021056910.png"/>

]]></content>
      <categories>
        <category>SwiftUI 技巧</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Text</tag>
      </tags>
  </entry>
  <entry>
    <title>在SwiftUI 中创建一个内容切换效果</title>
    <url>/posts/d4605c9a.html</url>
    <content><![CDATA[<h3 id="文字内容切换效果"><a href="#文字内容切换效果" class="headerlink" title="文字内容切换效果"></a>文字内容切换效果</h3><p>界面布局：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> text: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;$<span class="subst">\(text)</span>&quot;</span>)</span><br><span class="line">                .font(.largeTitle.bold())</span><br><span class="line">                .contentTransition(.numericText(value: <span class="type">Double</span>(text)))</span><br><span class="line">            <span class="type">Button</span> &#123;</span><br><span class="line">                withAnimation(.bouncy) &#123;</span><br><span class="line">                    text <span class="operator">=</span> .random(in: <span class="number">100</span><span class="operator">...</span><span class="number">10000</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; label: &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Update&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202308291020904.mp4" style="zoom:20%"></img></p>
<span id="more"></span> 

<p><span style="color:red"><strong>注意</strong></span>：<code>contentTransition</code> 修饰器的系统要求为： <code>@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)</code>。</p>
<h3 id="SF-Symbol-切换效果"><a href="#SF-Symbol-切换效果" class="headerlink" title="SF Symbol 切换效果"></a>SF Symbol 切换效果</h3><p>界面布局：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> sfImage: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;house.fill&quot;</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> sfCount: <span class="type">Int</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: sfImage)</span><br><span class="line">                .font(.largeTitle.bold())</span><br><span class="line">                .contentTransition(.symbolEffect(.automatic))</span><br><span class="line">            <span class="type">Button</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> images:[<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;suit.heart.fill&quot;</span>, <span class="string">&quot;house.fill&quot;</span>, <span class="string">&quot;gearshape&quot;</span>, <span class="string">&quot;person.circle.fill&quot;</span>, <span class="string">&quot;iphone&quot;</span>, <span class="string">&quot;macbook&quot;</span>]</span><br><span class="line">                withAnimation(.bouncy) &#123;</span><br><span class="line">                   sfCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                    sfImage <span class="operator">=</span> images[sfCount <span class="operator">%</span> images.count]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; label: &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Update&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img data-src="https://swift-blogs.oss-cn-shanghai.aliyuncs.com/202308291039418.mp4"  style="zoom:20%"/>

<p><span style="color:red"><strong>注意</strong></span>：</p>
<ul>
<li><p><code>contentTransition</code> 修饰器的系统要求为： <code>@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)</code>;</p>
</li>
<li><p><code>symbolEffect</code> 修饰器的系统要求为：<code>@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>SwiftUI 进阶</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>动画</tag>
        <tag>SF Symbol</tag>
      </tags>
  </entry>
</search>
